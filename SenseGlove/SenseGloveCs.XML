<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SenseGloveCs</name>
    </assembly>
    <members>
        <member name="T:SenseGloveCs.Devices.SenseArm">
            <summary> An exoskeleton that can provide force feedback to the gross movement of the arm. </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArm.deviceID">
            <summary> Unique ID used in DeviceScanning and Logistics </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArm.deviceVersion">
            <summary> The hardware version of the Sense Arm, used for debugging and backwards compatibility. </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArm.firmwareVersion">
            <summary> Version of the Code that runs on the Sense Arm Microcontroller. Used for maintentance and backwards compatibility. </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArm.dataLoaded">
            <summary> Whether or not constants have been recieved and the device is ready to calculate. </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArm.isRight">
            <summary> Determines if this is a left- or right sided Sense Arm. </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArm.brakeAmount">
            <summary> The amount of brakes on this SenseArm </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArm.brakeComandByte">
            <summary> Sent before brake magnitudes to let the SenseArm know this is a Brake command. </summary>
        </member>
        <member name="M:SenseGloveCs.Devices.SenseArm.DeviceID">
            <summary> Retrieve the unique identifier of this SenseArm </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Devices.SenseArm.IsReady">
            <summary> Check if this object's data has been loaded. </summary>
            <returns></returns>
        </member>
        <member name="P:SenseGloveCs.Devices.SenseArm.DeviceVersion">
            <summary> The hardware version of this Sense Arm </summary>
        </member>
        <member name="P:SenseGloveCs.Devices.SenseArm.IsRight">
            <summary> If true, this is a right handed Sense Arm </summary>
        </member>
        <member name="P:SenseGloveCs.Devices.SenseArm.FirmwareVersion">
            <summary> The firmware version running on the Sense Arm  </summary>
        </member>
        <member name="P:SenseGloveCs.Devices.SenseArm.NumberOfBrakes">
            <summary> The number of brakes that this Sense Arm posesses. </summary>
        </member>
        <member name="M:SenseGloveCs.Devices.SenseArm.#ctor(SenseGloveCs.Communicator)">
            <summary> Create a new SenseArm object in the chosen communications address. </summary>
            <param name="source"></param>
        </member>
        <member name="M:SenseGloveCs.Devices.SenseArm.Disconnect">
            <summary> Manually disconnect this SenseGlove. </summary>
        </member>
        <member name="M:SenseGloveCs.Devices.SenseArm.ParseConstants(System.String)">
            <summary>  </summary>
            <param name="C"></param>
        </member>
        <member name="M:SenseGloveCs.Devices.SenseArm.StopFeedback">
            <summary> Stops all froms of feedback on the SenseArm. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Devices.SenseArm.SendBrakeCmd(System.Int32[])">
            <summary> Send a brake command to this Sense Arm. </summary>
            <param name="magnitudes"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Devices.SenseArmConstants">
            <summary> Contains definitions for the SenseArm Constants </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArmConstants.ConstantsOpen">
            <summary> Part that is only used to determine if this is a constants command "{C:" </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArmConstants.DeviceID">
            <summary> Unique identifier (string , length > 0) </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArmConstants.HardwareVersion">
            <summary> Hardware version (string, length > 0) </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArmConstants.FirmwareVersion">
            <summary> Code version on MC. Parsed to float (ex. 1.0, 2.2) </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArmConstants.Side">
            <summary> Whether this is a left or right sided Sense Arm. </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArmConstants.Functions">
            <summary> Which specific Sense Arm function this hardware has over others. </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArmConstants.BrakeNumber">
            <summary> The amount of brakes on this Sense Arm. </summary>
        </member>
        <member name="F:SenseGloveCs.Devices.SenseArmConstants.All">
            <summary> Utility value used to check the length of constants.split(). </summary>
        </member>
        <member name="T:SenseGloveCs.Util.SGHardware">
            <summary> Utility Class containing several Sense Glove Related (calibration) values. </summary>
        </member>
        <member name="T:SenseGloveCs.Util.SGHardware.CalibrationProfile">
            <summary> Which profile is used to calibrate this glove. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SGHardware.CalibrationProfile.Default">
            <summary> All angles set ot 0. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SGHardware.CalibrationProfile.StaticJig">
            <summary> The first created (static) Calibration Jig. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SGHardware.CalibrationProfile.AutoJig">
            <summary> Automated Calibration Jig. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SGHardware.ADCtoAngle">
            <summary> Multiplied with ADC to get the angle. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SGHardware.AngleToADC">
            <summary> Multiplied with an Angle to get an ADC value. </summary>
        </member>
        <member name="M:SenseGloveCs.Util.SGHardware.CalibrateSensor(System.Int32,System.Single,System.Int32,System.Single,System.Int32)">
            <summary> Calibrate a single sensor. </summary>
            <param name="Xr">Latest Value</param>
            <param name="Ar">Angle corresponding to latest value</param>
            <param name="Xc">Angle of the calibration profile</param>
            <param name="Yc">angle corresponding to the calibration profile</param>
            <param name="dir"> The direction of the sensor, where -1 is inverted to its default value, used when Yc != Yr </param>
            <returns> An ADC conversion offset, added to the glove's raw sensor value so that at ADC Xc, the output will be Yc. </returns>
        </member>
        <member name="M:SenseGloveCs.Util.SGHardware.SensorDirections(System.String,System.String,System.Single)">
            <summary>  </summary>
            <param name="deviceID"></param>
            <param name="hardwareVer"></param>
            <param name="fwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Util.SGHardware.GetProfile(SenseGloveCs.Util.SGHardware.CalibrationProfile,System.Boolean)">
            <summary> Retrieve a reference profile, based on the calibration jig used. </summary>
            <param name="calibrationJig"></param>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Util.SGHardware.GenerateCalString(System.String,System.Single[][],System.Single[][],System.Int32[][],System.Boolean)">
            <summary> Generate a Calibration string based on proflies and parameters gathered from this same class. </summary>
            <param name="deviceID"></param>
            <param name="gloveValues"></param>
            <param name="refAngles"></param>
            <param name="dirs"></param>
            <param name="addDirs"></param>
            <returns></returns>
        </member>
        <member name="F:SenseGloveCs.Util.SGHardware.newLinks">
            <summary>
            one Dk1.2 finger length set
            </summary>
        </member>
        <member name="M:SenseGloveCs.Util.SGHardware.GetCString(System.String,System.String,System.Single,System.Boolean)">
            <summary> Retrieve a C-String (Hacky) </summary>
            <param name="deviceID"></param>
            <param name="hwVer"></param>
            <param name="fwVer"></param>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Util.InterpolationSet_IMUGlove">
            <summary> A set of joint angle interpolations used to create  </summary>
        </member>
        <member name="F:SenseGloveCs.Util.InterpolationSet_IMUGlove.myAngles">
            <summary> Contains the interpolation values, from [Finger][IntAngles_IMU] </summary>
        </member>
        <member name="M:SenseGloveCs.Util.InterpolationSet_IMUGlove.#ctor(System.Boolean)">
            <summary> Create a default set of interpolation angles. </summary>
        </member>
        <member name="M:SenseGloveCs.Util.InterpolationSet_IMUGlove.#ctor(SenseGloveCs.Kinematics.InterpolationValue[][])">
            <summary> Create a new Interpolation Set </summary>
            <param name="angles"></param>
        </member>
        <member name="M:SenseGloveCs.Util.InterpolationSet_IMUGlove.Basic">
            <summary> Retrieve a basic [0, 1, 0, 1] interpolation set that can be edited. Note; this is not the default set. Use InterpolationSet() for that. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Util.InterpolationSet_IMUGlove.GetAngle(System.Single,System.Boolean,SenseGloveCs.Finger,SenseGloveCs.Kinematics.IntAngles_IMU_Finger)">
            <summary> Interpolate over a specific set of angles of the fingers </summary>
            <param name="x"></param>
            <param name="applyLimits"></param>
            <param name="finger"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Util.InterpolationSet_IMUGlove.GetThumbAngle(System.Single,System.Boolean,SenseGloveCs.Kinematics.IntAngles_IMU_Thumb)">
            <summary>  Get a specific set of angles from the thumb  </summary>
            <param name="x"></param>
            <param name="applyLimits"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Util.SimpleGloveData">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.isRight">
            <summary> Whether this glove is left or right. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.gloveVersion">
            <summary> The glove version (as string) </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.parsedGloveVersion">
            <summary> The glove version (as a float) </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.functionalities">
            <summary> The functions of this glove </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.interpolation">
            <summary> The IMU interpolation values of this SimpleSenseGlove. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.fingers">
            <summary> The values of the IMU sensors. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.rawWrist">
            <summary> Raw IMU values of the wrist </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.wrist">
            <summary> The quaternion orientation of the wrist. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.imuAngles">
            <summary>
            
            </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.handAngles">
            <summary> The (euler) angles of the hand. </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleGloveData.handRotations">
            <summary> Absolute Quaternion Orientations </summary>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleGloveData.#ctor">
            <summary> Create a new SimpleGloveData block. </summary>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleGloveData.ParseConstants(System.String)">
            <summary> Parse and apply constants. </summary>
            <param name="c"></param>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleGloveData.ParseSensorStream(System.String[])">
            <summary>
            Parse a sensor string as recieved from the Communicator.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleGloveData.Update(System.Boolean,System.Boolean,System.Boolean,System.Boolean,SenseGloveCs.Kinematics.Quat)">
            <summary> Update the mathematical model of this Simple Sense Glove. </summary>
            <param name="updateFingers"></param>
            <param name="limitFingers"></param>
            <param name="updateWrist"></param>
            <param name="limitWrist"></param>
            <param name="qLowerArm"></param>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleGloveData.ToInterpolatable(SenseGloveCs.Kinematics.Quat)">
            <summary> Convert an (imu) rotation to values (roll/pitch/yaw) that can be interpolated. </summary>
            <param name="qThimble"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Util.SimpleSenseGlove">
            <summary> A SenseGlove using IMU's  </summary>
        </member>
        <member name="F:SenseGloveCs.Util.SimpleSenseGlove.simpleData">
            <summary> The data of the Simple Sense Glove </summary>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.#ctor">
            <summary> Create a new Simple Sense Glove </summary>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.#ctor(SenseGloveCs.Communicator)">
            <summary> Create a new instance of the SimpleSenseGlove,  </summary>
            <param name="source"></param>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.Finalize">
            <summary> Disconnect when the object is destoryed. </summary>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.IsReady">
            <summary> Check whether or not this glove has loaded all of its variables. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.GetData(System.Boolean)">
            <summary> Retrieve the Glove Data. </summary>
            <param name="recalculate"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.Update(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single[])">
            <summary>
            Update and retrieve the SimpleSenseGlove.
            </summary>
            <param name="updateFingers"></param>
            <param name="limitFingers"></param>
            <param name="updateWrist"></param>
            <param name="limitWrist"></param>
            <param name="qLowerArm"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.ParseConstants(System.String)">
            <summary> Parse the constants from this glove. </summary>
            <param name="C"></param>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.ParseMetaData(System.String)">
            <summary> Parse the glove's metadata. </summary>
            <param name="M"></param>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.Calibrate(SenseGloveCs.Kinematics.Quat,SenseGloveCs.Kinematics.Quat[])">
            <summary>
            Calibrate the Sense Glove.
            </summary>
            <param name="calibrationPose"></param>
            <param name="qLowerArm"></param>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.CalibrationPose(System.Boolean)">
            <summary> Retrieve quaternions to calibrate the finger positions. </summary>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Util.SimpleSenseGlove.DeviceID">
            <summary> Retrieve the device's unique ID </summary>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.IO.SerialWrapper">
            <summary> Wrapper class that combines a SerialPort and a continous ReadThread. </summary>
        </member>
        <member name="F:SenseGloveCs.IO.SerialWrapper.recieveData">
            <summary> 
            Controls if the ReadThread should still be reading data. 
            Set to false to force the thread to exit as a last resort. The Disconnect() function is neater.
            </summary>
        </member>
        <member name="F:SenseGloveCs.IO.SerialWrapper._port">
            <summary> The Serial Port that sends / recieves the data. </summary>
        </member>
        <member name="F:SenseGloveCs.IO.SerialWrapper.readThread">
            <summary> The worker thread that receives serial data. </summary>
        </member>
        <member name="F:SenseGloveCs.IO.SerialWrapper.processing">
            <summary> Semaphore for character processing </summary>
        </member>
        <member name="F:SenseGloveCs.IO.SerialWrapper.commandBuffer">
            <summary> The buffer of unfinished commands coming in. Allows us to intercept smaller commands interrupting larger ones. </summary>
        </member>
        <member name="F:SenseGloveCs.IO.SerialWrapper.lastChar">
            <summary> The character that was received before the current measurement, used mostly to catch escape characters. </summary>
        </member>
        <member name="F:SenseGloveCs.IO.SerialWrapper.isSending">
            <summary> Is true while the Communicator is Writing to the SerialPort. </summary>
        </member>
        <member name="F:SenseGloveCs.IO.SerialWrapper.sendByByte">
            <summary> If set to true, the SerialWrapper sends its commands by byte. </summary>
        </member>
        <member name="P:SenseGloveCs.IO.SerialWrapper.IsConnected">
            <summary> Check if the Serial Port is (still) connected. </summary>
            <returns></returns>
        </member>
        <member name="P:SenseGloveCs.IO.SerialWrapper.Address">
            <summary> Retrieve the name of the Serial Port. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.#ctor(System.String)">
            <summary> Create a new USB communication line on the specified COMPort </summary>
            <param name="COMPort"></param>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.Finalize">
            <summary> Deconstructor. Ensure disconenct(?) </summary>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.Open">
            <summary> (Re)Connect to the Serial USB device. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.Close(SenseGloveCs.Diagnostics.ExitCodes)">
            <summary>  Disconnect from this device, destroys worker thread. </summary>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.Read">
            <summary>
            Function that is run within the ReadThread and keeps it in scope.
            </summary>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.ProcessNextChar(System.Int32)">
            <summary> Processes the next byte coming in from the Serial Port. Fires within the ReadThread. </summary>
            <param name="nextByte"></param>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.Write(System.String)">
            <summary> Send command(s) to the MicroController aboard the Sense Glove. </summary>
            <param name="command">The command to send</param>
            <returns>Returns true if the command has been fired.</returns>
        </member>
        <member name="T:SenseGloveCs.IO.SerialWrapper.ConnectionLostEventHandler">
            <summary> Event Delegate for the Disconnected event </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SenseGloveCs.IO.SerialWrapper.Disconnected">
            <summary> Fires when this wrapper lost its connection for any reason. </summary>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.OnDisconnect(SenseGloveCs.Diagnostics.ExitCodes)">
            <summary> Fires the Disconnected event. </summary>
            <param name="exitCode"></param>
        </member>
        <member name="T:SenseGloveCs.IO.SerialWrapper.CommandEventHandler">
            <summary> Delegate function implemented by subscribers to the OnFingerCalibrationFinished event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SenseGloveCs.IO.SerialWrapper.CommandRecieved">
            <summary> Fires when the new finger lengths and joint positions are calculated. </summary>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.OnCommandRecieved(System.String)">
            <summary>  Used to call the OnFingerCalibrationFinished event in all subscribers. </summary>
        </member>
        <member name="T:SenseGloveCs.IO.SerialWrapper.SenseDataHandler">
            <summary> Delegate function implemented by subscribers to the OnFingerCalibrationFinished event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SenseGloveCs.IO.SerialWrapper.DataRecieved">
            <summary> Fires when the new finger lengths and joint positions are calculated. </summary>
        </member>
        <member name="M:SenseGloveCs.IO.SerialWrapper.OnDataRecieved(System.String)">
            <summary>  Used to call the OnFingerCalibrationFinished event in all subscribers. </summary>
        </member>
        <member name="T:SenseGloveCs.IO.DisconnectArgs">
            <summary>  Arguments to pass ExitCodes in between objects. </summary>
        </member>
        <member name="P:SenseGloveCs.IO.DisconnectArgs.ExitCode">
            <summary> The ExitCode with which the SerialWrapper has disconnected. </summary>
        </member>
        <member name="M:SenseGloveCs.IO.DisconnectArgs.#ctor(SenseGloveCs.Diagnostics.ExitCodes)">
            <summary> Create a new instance of DisconnectArgs. </summary>
            <param name="code"></param>
        </member>
        <member name="T:SenseGloveCs.IO.DeviceArgs">
            <summary> Arguments of DeviceDetected / DeviceDisconnected events. </summary>
        </member>
        <member name="F:SenseGloveCs.IO.DeviceArgs.device">
            <summary> The device that has been detected / disconnected, wrapped with an Accessor. </summary>
        </member>
        <member name="M:SenseGloveCs.IO.DeviceArgs.#ctor(SenseGloveCs.IODevice)">
            <summary> Create a new instance of the DeviceArgs, limited to the Dll. </summary>
            <param name="detectedDevice"></param>
        </member>
        <member name="P:SenseGloveCs.IO.DeviceArgs.Device">
            <summary> The device that has been detected / disconnected. </summary>
        </member>
        <member name="T:SenseGloveCs.UnitTest.UnitTestCommunicator">
            <summary> Simulates a specific type of IODevice. Used for Unit Tests </summary>
        </member>
        <member name="F:SenseGloveCs.UnitTest.UnitTestCommunicator.simulatedType">
            <summary> Which DeviceType this Communicator is simulating. </summary>
        </member>
        <member name="F:SenseGloveCs.UnitTest.UnitTestCommunicator.myAddress">
            <summary> The simulated address, used to create multiple UnitTests with similar addresses. </summary>
        </member>
        <member name="F:SenseGloveCs.UnitTest.UnitTestCommunicator.isConnected">
            <summary> Set to true / false, depending on the Connect() / Disconnect() method. </summary>
        </member>
        <member name="M:SenseGloveCs.UnitTest.UnitTestCommunicator.#ctor(System.String,SenseGloveCs.DeviceType)">
            <summary> Create a new Communicator simulationof the chosen DeviceType. </summary>
            <param name="address"></param>
            <param name="simulateType"></param>
        </member>
        <member name="M:SenseGloveCs.UnitTest.UnitTestCommunicator.Address">
            <summary> Retrieve the address of this Communicator. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.UnitTest.UnitTestCommunicator.Connect">
            <summary> Connect to this Communicator for the first time. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.UnitTest.UnitTestCommunicator.Disconnect(SenseGloveCs.Diagnostics.ExitCodes)">
            <summary> Disconnect from this Communicator </summary>
            <param name="exitCode"></param>
        </member>
        <member name="M:SenseGloveCs.UnitTest.UnitTestCommunicator.IsConnected">
            <summary> Check if this Communicator is still connected </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.UnitTest.UnitTestCommunicator.Send2Device(System.String)">
            <summary> Send a command to this device. </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.UnitTest.UnitTestCommunicator.Send2Device(System.Char)">
            <summary> Send a single character to this device. </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.UnitTest.UnitTestCommunicator.Send2Device(System.Byte[])">
            <summary> Send an array of bytes to this  </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.CalibrateVariable">
            <summary> Which variable of a SenseGlove HandModel or Solver to calibrate; which determines what algorithm is used. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CalibrateVariable.FingerLengths">
            <summary> Calibrate the finger lengths, but no the thumb </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CalibrateVariable.FingerPositions">
            <summary> Calibrate the MCP joint positions of the fingers (not the thumb) relative to the glove. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CalibrateVariable.FingerVariables">
            <summary> Calibrate both variables of the fingers, FingerLengths and FingerPositions  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CalibrateVariable.Interpolation_Flexion">
            <summary> Calibrate Sensor Interpolation for the flexion of the fingers. </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.CalibrationAlgorithm">
            <summary> An algorithm that can calibrate GloveData and/or solvers based on a set of snapshots. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CalibrationAlgorithm.whatToCalibrate">
            <summary> Stored here, tells us what to calibrate during the actual algorithm. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationAlgorithm.RequiredSnapshots">
            <summary> The number of snapshots required to calibrate with this algorithm. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationAlgorithm.Calibrate(SenseGloveCs.Kinematics.SenseGloveSolver[]@,SenseGloveCs.GloveData@,SenseGloveCs.GloveData[]@)">
            <summary> Calibrate a Sense Glove Model. </summary>
            <param name="model"></param>
            <param name="solvers">To calibrate Solvers, and also to respond to different solvers as input. </param>
            <param name="snapshots"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationAlgorithm.RevelantFingers">
            <summary> Which fingers will be calibrated by this algorithm, represented in a bool array of size 5. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationAlgorithm.IsValid(SenseGloveCs.Kinematics.CalibrationAlgorithm)">
            <summary> Check if the CalibrationAlgorithm has any valid fingers. </summary>
            <param name="algorithm"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationAlgorithm.ValidateTotalLength(System.Single,System.Int32)">
            <summary> Validate the total length of the fingers </summary>
            <param name="length"></param>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationAlgorithm.GetAlgorithm(SenseGloveCs.Kinematics.CalibrateVariable)">
            <summary> Based on the chosen parameters, determine which calibration algorithm to use. </summary>
            <param name="whatToCalibrate"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.CircleMovement2D">
            <summary> Calculates the MCP position and total finger lengths, by assuming the fingertip moves in a semicircle, with the MCP joint as a center. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CircleMovement2D.calibrateJoints">
            <summary> Whether or not to apply the calculated MCP joint positions. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CircleMovement2D.calibrateLengths">
            <summary> Whether or not to apply the calculated finger lengths. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CircleMovement2D.#ctor(SenseGloveCs.Kinematics.CalibrateVariable)">
            <summary> Create a new instance of this Calibration Algorithm. </summary>
            <param name="whatTo"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CircleMovement2D.RequiredSnapshots">
            <summary> This algorithm requires 3 points. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CircleMovement2D.RevelantFingers">
            <summary> This algorithm is relvant to the fingers, but not the thumb. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CircleMovement2D.Calibrate(SenseGloveCs.Kinematics.SenseGloveSolver[]@,SenseGloveCs.GloveData@,SenseGloveCs.GloveData[]@)">
            <summary> Calibrate the joint positions and finger lengths using three points on a circle motion. </summary>
            <param name="solvers"></param>
            <param name="model"></param>
            <param name="snapshots"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CircleMovement2D.MCPPosition2D(SenseGloveCs.Kinematics.Vect3D[])">
            <summary> Calculate the position of the MCP joint, based on three 2D points in the xz plane. </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.Calibration.SensorFlex">
            <summary> Calculates the flexion/extension interpolation parameters, based on two gestures from the hand. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Calibration.SensorFlex.fingers">
            <summary> Which fingers to  apply the calibration to. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Calibration.SensorFlex.#ctor(System.Boolean[],SenseGloveCs.Kinematics.CalibrateVariable)">
            <summary> Create a new instance of the SensorFlex Algorithm. </summary>
            <param name="whichFingers"></param>
            <param name="whatTo"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Calibration.SensorFlex.Calibrate(SenseGloveCs.Kinematics.SenseGloveSolver[]@,SenseGloveCs.GloveData@,SenseGloveCs.GloveData[]@)">
            <summary> Can Calibrate both the 2 and 4 interpolation sensors. </summary>
            <param name="solvers"></param>
            <param name="model"></param>
            <param name="snapshots"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Calibration.SensorFlex.GetFlexion(SenseGloveCs.Kinematics.JointChain)">
            <summary> Retrieve the total y (flexion) angles from the glove chain. </summary>
            <param name="chain"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Calibration.SensorFlex.RequiredSnapshots">
            <summary> Check how many snapshots this calibration algorithm requires (2). </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Calibration.SensorFlex.RevelantFingers">
            <summary> Which fingers to check for 'steadyness' </summary>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.CollectionMethod">
            <summary> Determines how the calibration points are gathered. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CollectionMethod.Manual">
            <summary> Collect a new calibration point when the NextCalibrationStep function is called. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CollectionMethod.SemiAutomatic">
            <summary> Automatically collect new points during the Update() method, if they are distinct enough from the others. </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.CalibrationCollector">
            <summary> Collects Calibration Points to be used with a Calibration Algorithm for specific solver(s). </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CalibrationCollector.calibrator">
            <summary> The Calibration algorithm used to calibrate this solver. </summary>
            <remarks> Placed inside the collector because the two are never used separately. </remarks>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CalibrationCollector.snapshots">
            <summary> All snapshots so far collected by the collector. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.CalibrationCollector.currentStep">
            <summary> The amount of collected snapshots. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.TotalSteps">
            <summary> Check how many snapshots will need to be collected before calculation can begin. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.CurrentStep">
            <summary> Check how many of the required calibration points have been collected so far. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.DoneCollecting">
            <summary> Check if the collector has all the points it needs. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.IsAutomated">
            <summary> Check if this calibration method can recieve new data points through the Update() function.  </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.IsContinuous">
            <summary> Check if this calibration method can recieve new data points through the Update() function.  </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.AddDataPoint(SenseGloveCs.GloveData)">
            <summary> Check if this datapoint can be added to the collector </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.AddSnapshot(SenseGloveCs.GloveData)">
            <summary> Actually add a datapoint to the collector </summary>
            <param name="data"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.Calibrate(SenseGloveCs.Kinematics.SenseGloveSolver[]@,SenseGloveCs.GloveData@)">
            <summary> Wrapper to calibrate the algorithm of this collector. </summary>
            <param name="solvers"></param>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.CalibrationCollector.Reset">
            <summary> Reset this calibration sequence back to its original points. </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.ManualCollector">
            <summary> An non-automated collector, that waits for the user to indicate they want to add a new point. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.ManualCollector.#ctor(System.Int32)">
            <summary> Create a new Manual Collector. </summary>
            <param name="totalSteps"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.ManualCollector.IsAutomated">
            <summary> This calibration method is not automated. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.ManualCollector.IsContinuous">
            <summary> This is not a continous calibration sequence. </summary>
            <returns></returns>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SemiAutoCollector.minimumDistance">
            <summary> Distance (in mm) between the next point(s) to call them 'Distinct' from one another. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SemiAutoCollector.steadyDistance">
            <summary> Distance (in mm) that the  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SemiAutoCollector.steadyTime">
            <summary> Time (in seconds) that the data must be steady for. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SemiAutoCollector.lastSteadyTime">
            <summary> The time the positions were steady. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SemiAutoCollector.lastSteadyPos">
            <summary> The five last steady positions </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SemiAutoCollector.#ctor(System.Int32,System.Single,System.Single,System.Single)">
            <summary> Create a new Semi-Automatic Calibration collector. </summary>
            <param name="requiredSteps"></param>
            <param name="distinctDistance"></param>
            <param name="steadyTimer"></param>
            <param name="steadyDist"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SemiAutoCollector.IsAutomated">
            <summary> Check every Update if we can add a new point. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SemiAutoCollector.IsContinuous">
            <summary> Semi-Auto calibration is not continuous, meaning it will not start again  </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SemiAutoCollector.AddDataPoint(SenseGloveCs.GloveData)">
            <summary> Check if a new DataPoint can be added. </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SemiAutoCollector.IsStable(SenseGloveCs.GloveData)">
            <summary> Check if this snapshot is stable. </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SemiAutoCollector.IsDistinct(SenseGloveCs.GloveData)">
            <summary> Check if a variable is distinct enough from the previous steps. </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.DistanceBasedSolver">
            <summary> A solver based on Virtual Hand Models, that calculates joint angles so that the distance between virtual fingertips is the same as the glove exo. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.DistanceBasedSolver.glove_fingerOffset">
            <summary> Offset between thimble and fingertip. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.DistanceBasedSolver.glove_thumbOffset">
            <summary> Offset between thimble and fingertip. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.DistanceBasedSolver._followFinger">
            <summary> Which of the fingers that thumb will follow. </summary>
        </member>
        <member name="P:SenseGloveCs.Kinematics.DistanceBasedSolver.FollowFinger">
            <summary> Access which of the fingers the thumb will follow. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.DistanceBasedSolver.#ctor(System.Boolean)">
            <summary> Create a new instance of the Distance-Based solver, for either a right or left hand. </summary>
            <param name="isRight"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.DistanceBasedSolver.Solve(SenseGloveCs.Kinematics.SenseGloveModel@,System.Single[][],System.Boolean,System.Boolean[])">
            <summary> Solve the thumb and fingers. </summary>
            <param name="model"></param>
            <param name="sensorAngles"></param>
            <param name="naturalLimits"></param>
            <param name="fingers"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.DistanceBasedSolver.CalculateThumbFlexion(SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Vect3D[],SenseGloveCs.Kinematics.InterpolationValue,System.Boolean)">
            <summary> Calculate the thumb flexion angles required to place the thumb fingertip at the tip projection. </summary>
            <param name="tipProj"></param>
            <param name="thumbLengths"></param>
            <param name="IPflex"></param>
            <param name="naturalLimit"></param>
            <returns> Returns a Vect3d containing CMC, MCP and IP angles </returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.FlexibleFingers.FlexibleVariable">
            <summary> Which variable of this solver should be flexible. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.FlexibleFingers.FlexibleVariable.FingerLenghts">
            <summary> The total finger lengths scale to match that of the  </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.Interp2Sensors">
            <summary> The poor man's interpolation solver; using the proximal sensor for flexion and the distal one for abduction. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Interp2Sensors.imu_interpolations">
            <summary> The interpolation set of this solver. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Interp2Sensors.#ctor(System.Boolean)">
            <summary> Create a new solver. </summary>
            <param name="isRight"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Interp2Sensors.ResetParameters(System.Boolean)">
            <summary> Reset the interpolations back to basics. </summary>
            <param name="isRight"></param>
        </member>
        <member name="T:SenseGloveCs.Kinematics.InterpolationSet_IMU">
            <summary> A set of joint angle interpolations used to create  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.InterpolationSet_IMU.myAngles">
            <summary> Contains the interpolation values, from [Finger][IntAngles_IMU] </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationSet_IMU.#ctor(System.Boolean)">
            <summary> Create a default set of interpolation angles. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationSet_IMU.#ctor(SenseGloveCs.Kinematics.InterpolationValue[][])">
            <summary> Create a new Interpolation Set </summary>
            <param name="angles"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationSet_IMU.Basic">
            <summary> Retrieve a basic [0, 1, 0, 1] interpolation set that can be edited. Note; this is not the default set. Use InterpolationSet() for that. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationSet_IMU.GetAngle(System.Single,System.Boolean,SenseGloveCs.Finger,SenseGloveCs.Kinematics.IntAngles_IMU_Finger)">
            <summary> Interpolate over a specific set of angles of the fingers </summary>
            <param name="x"></param>
            <param name="applyLimits"></param>
            <param name="finger"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationSet_IMU.GetThumbAngle(System.Single,System.Boolean,SenseGloveCs.Kinematics.IntAngles_IMU_Thumb)">
            <summary>  Get a specific set of angles from the thumb  </summary>
            <param name="x"></param>
            <param name="applyLimits"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationSet_IMU.Serialize">
            <summary> Serialize values into a string format </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationSet_IMU.Deserialize(System.String,System.Boolean)">
            <summary> Deserialize a string into an InterpolationSet. </summary>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.IntAngles_IMU_Finger">
            <summary> Interpolation angles that are calculated ba an IMU_Based interpolation for the finger </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Finger.MCP_Abd">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Finger.MCP_FE">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Finger.PIP_FE">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Finger.DIP_FE">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Finger.All">
            <summary> Utility value, using it in the Get() function will return 0. </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.IntAngles_IMU_Thumb">
            <summary> Interpolation angles that are calculated ba an IMU_Based interpolation for the thumb  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Thumb.CMC_Abd">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Thumb.CMC_FE">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Thumb.CMC_TW">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Thumb.MCP_FE">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Thumb.IP_FE">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IntAngles_IMU_Thumb.All">
            <summary> Utility value, using it in the Get() function will return 0. </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.InterpolationValue">
            <summary> Used to ease interpolation of a (joint) angle  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.InterpolationValue.x0">
            <summary> The first input, whcih results in y0 </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.InterpolationValue.y0">
            <summary> The resulting angle at x0 </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.InterpolationValue.x1">
            <summary> The second input, which results in y1 </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.InterpolationValue.y1">
            <summary> The resulting angle at x1 </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.InterpolationValue.minValue">
            <summary> The minimum possible angle, [-Pi...Pi] </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.InterpolationValue.maxValue">
            <summary> The maximim possible angle, [-Pi...Pi] </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationValue.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new Interpolation angle without limits </summary>
            <param name="_x0"></param>
            <param name="_x1"></param>
            <param name="_y0"></param>
            <param name="_y1"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationValue.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new interpolation angle with predefined limits </summary>
            <param name="_x0"></param>
            <param name="_x1"></param>
            <param name="_y0"></param>
            <param name="_y1"></param>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationValue.Get(System.Single,System.Boolean,System.Boolean)">
            <summary> Interpolate a value to a joint angle </summary>
            <param name="x"></param>
            <param name="applyLimits"></param>
            <param name="asAngle"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationValue.SetXVals(System.Single,System.Single)">
            <summary> Set the X interpolaton values of this Set (Calibration) </summary>
            <param name="X0"></param>
            <param name="X1"></param>
        </member>
        <member name="F:SenseGloveCs.Kinematics.InterpolationValue.valDelim">
            <summary> Used for deserialization </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationValue.Serialize">
            <summary> Serialize this InterpolationValue </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.InterpolationValue.Deserialize(System.String)">
            <summary> Create a new InterpolationValue from a string representation </summary>
            <param name="raw"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.Joint">
            <summary> A representation of a joint, from either a hand or hardware component </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Joint.position">
            <summary> The 3D position of the joint, relative to its shared origin. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Joint.rotation">
            <summary> The current Quaternion rotation relative to its shared origin. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Joint.relativeAngle">
            <summary> The angle of this joint relative to the previous one. If no previous joint exists, it is relative to the origin. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Joint.#ctor">
            <summary> Create a new joint with all value sset to 0. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Joint.#ctor(SenseGloveCs.Kinematics.Vect3D)">
            <summary> Create a new joint with all value sset to 0. </summary>
            <param name="pos"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Joint.#ctor(SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Quat,SenseGloveCs.Kinematics.Vect3D)">
            <summary> Create a new joint with specific variables. </summary>
            <param name="pos"></param>
            <param name="rot"></param>
            <param name="angles"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Joint.#ctor(SenseGloveCs.Kinematics.Joint)">
            <summary> Create a copy of this Joint </summary>
            <param name="J"></param>
        </member>
        <member name="T:SenseGloveCs.Kinematics.JointChain">
            <summary> Represents a chain of N joints, connected by N-1 rigidbodies. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.JointChain.joints">
            <summary> The (N) joints that make up the chain, from proximal [0] to distal [N].</summary>
            <remarks>  
            The first joint position represents the starting position of this joint chain, 
            but its rotation represents that of the combined first rotation and start rotation.
            </remarks> 
        </member>
        <member name="F:SenseGloveCs.Kinematics.JointChain.lengths">
            <summary> The (N-1) lengths connecting the joints in the chain. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.JointChain.startRotation">
            <summary> The starting rotation of the joint chain. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.JointChain.#ctor(SenseGloveCs.Kinematics.Vect3D[],SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Quat)">
            <summary> Create a new joint chain from a set of bodies with a specific start position- and rotation. </summary>
            <param name="bodies"></param>
            <param name="startPos"></param>
            <param name="startRot"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.JointChain.#ctor(SenseGloveCs.Kinematics.Vect3D[])">
            <summary> Create a new JointChain where only the lengths are known </summary>
            <param name="bodies"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.JointChain.#ctor(System.Single[],SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Quat)">
            <summary> Create a new Joint chain for a single finger, using only a set of lengths </summary>
            <param name="fingerLengths"></param>
            <param name="startPos"></param>
            <param name="startRot"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.JointChain.#ctor(System.Int32)">
            <summary> Create a new joint chain with a specified number of lengths that will be filled in later. </summary>
            <param name="N"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.JointChain.CreateNodes(System.Int32)">
            <summary> Creates N+1 joints. </summary>
            <remarks> Placed in a separate method as C# does not allow constructor overloading. </remarks>
            <param name="N"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.JointChain.ForwardKinematics(SenseGloveCs.Kinematics.Vect3D[])">
            <summary> Update all Joints based on a series of relativeAngles. </summary>
            <param name="relativeAngles"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.JointChain.ForwardKinematics(SenseGloveCs.Kinematics.Quat[],SenseGloveCs.Kinematics.Vect3D[])">
            <summary> Update all joints based on their absolute rotations. (Note, these are not comulative). Can also add relativeAngles to avoid gimball locks. </summary>
            <param name="absRotations"></param>
            <param name="relativeAngles"></param>
        </member>
        <member name="P:SenseGloveCs.Kinematics.JointChain.LastPosition">
            <summary> Retrieve the position of the last element </summary>
            <returns></returns>
        </member>
        <member name="P:SenseGloveCs.Kinematics.JointChain.LastRotation">
            <summary> Retrieve the rotation of the last element </summary>
            <returns></returns>
        </member>
        <member name="P:SenseGloveCs.Kinematics.JointChain.LastJoint">
            <summary> Retrieve the last element in the chain. </summary>
            <returns></returns>
        </member>
        <member name="P:SenseGloveCs.Kinematics.JointChain.TotalAngles">
            <summary> Returns the sum of all the relative angles used for forward kinematics on this joint chain (may need normalization). </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.JointChain.GetTipPosition(SenseGloveCs.Kinematics.Vect3D)">
            <summary> Calculate a fingertip position using a specific offset. </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.Quat">
            <summary> A quaternion rotation representation. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Quat.x">
            <summary> component of the Quaternion rotation. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Quat.y">
            <summary> component of the Quaternion rotation. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Quat.z">
            <summary> component of the Quaternion rotation. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Quat.w">
            <summary> component of the Quaternion rotation. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.#ctor">
            <summary> Create a quaternion representing a rotation of 0, 0, 0 </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new instance of a Quaternion representation </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Z"></param>
            <param name="W"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.#ctor(System.Single[])">
            <summary> Create a Quaternion from an array containing its xyzw values. </summary>
            <param name="Q"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.#ctor(SenseGloveCs.Kinematics.Quat)">
            <summary> Create a copy of another Quaternion </summary>
            <param name="Q"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.#ctor(System.String,System.Char)">
            <summary> Parse a quaternion from a string representation (IMU) </summary>
            <param name="s"></param>
            <param name="delimiter"></param>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Quat.identity">
            <summary> Quaternion representing a rotation of 0, 0, 0. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.op_Multiply(SenseGloveCs.Kinematics.Quat,SenseGloveCs.Kinematics.Quat)">
            <summary>
            Add two quaternions together Using a Hamilton product.
            NOTE: Q2 is applies first, followed by Q1, as per muliplication order of quaternions!
            </summary>
            <remarks>
            A rotation by Q1 followed by one of Q2 requires to operation Q2*Q1, using the Hamilton Multiplication.
            https://en.wikipedia.org/wiki/Quaternion
            </remarks>
            <param name="q1"></param> //xyzw
            <param name="q2"></param> //xyzw
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.ToString">
            <summary> Creates a string representation of the Quaternion. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.IsIdentity">
            <summary> Check if this quaternion is an identity quaternion; and does not rotate anything. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.Equals(System.Object)">
            <summary> Check if two quaternions equal each other. </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.GetHashCode">
            <summary> Returns Base.GetHashCode() </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.ToEuler">
            <summary> Convert this quaternion into an euler-angle representation. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.Inverse(SenseGloveCs.Kinematics.Quat)">
            <summary> Invert this quaternion (reverse its rotation) </summary>
            <param name="Q"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.Conjugate(SenseGloveCs.Kinematics.Quat)">
            <summary> Invert this quaternion (reverse its rotation) </summary>
            <param name="Q"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.FromAngleAxis(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new quaternion from an angle-axis notation </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.FromAngleAxis(System.Single,SenseGloveCs.Kinematics.Vect3D)">
            <summary> Create a new quaternion from an angle-axis notation </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.FromEuler(System.Single,System.Single,System.Single)">
            <summary> Create a new Quaternion from its Euler angle representation </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.FromEuler(SenseGloveCs.Kinematics.Vect3D)">
            <summary> Create a new Quaternion from its Euler angle representation </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Quat.FromEuler(System.Single[])">
            <summary> Create a new Quaternion from its Euler angle representation </summary>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.SenseGloveModel">
            <summary>   </summary>
            <remarks> Replaces HandKinematics </remarks>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SenseGloveModel.isRight">
            <summary> Determines if this handmodel belongs to a right hand. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SenseGloveModel.gloveRelRot">
            <summary> The glove's rotation relative to the wrist </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SenseGloveModel.gloveRelPos">
            <summary> Teh gloves position relative to the wrist joint. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SenseGloveModel.gloveLinks">
            <summary> The glove sections; from thumb to pinky, from proximal to distal. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SenseGloveModel.fingers">
            <summary> The finger phalanges; from thumb to pinky, from proximal to distal. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SenseGloveModel.thimbleCompD">
            <summary> Positional difference between the glove thimble and fingertip.  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SenseGloveModel.thimbleCompR">
            <summary> Rotation difference between the glove thimble and fingertip. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.SenseGloveModel.approximations">
            <summary> Indicates whether or not the latest solution was an approximation. </summary>
            <remarks> Can be used to skip a solution during data processing </remarks>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveModel.#ctor(System.Boolean)">
            <summary> Default; a.k.a. no glove information is available. </summary>
            <param name="rightHand"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveModel.#ctor(System.Boolean,SenseGloveCs.Kinematics.Vect3D[][],SenseGloveCs.Kinematics.Vect3D[],SenseGloveCs.Kinematics.Quat[],SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Quat)">
            <summary> Create a new SenseGloveModel with specific parameters. </summary>
            <param name="rightHand"></param>
            <param name="links"></param>
            <param name="startPositions"></param>
            <param name="startRotations"></param>
            <param name="glovePos">
            <param name="gloveRot"></param></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveModel.SetupHandModel(System.Boolean)">
            <summary> Create a new hand model, with all default values. </summary>
            <param name="isRight"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveModel.UpdateGlove(SenseGloveCs.Kinematics.Vect3D[][])">
            <summary> Update the fingers using a set of relative angles. </summary>
            <param name="relativeAngles"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveModel.UpdateHand(SenseGloveCs.Kinematics.Vect3D[][])">
            <summary> Update the fingers using a set of relative angles </summary>
            <param name="relativeAngles"></param>
        </member>
        <member name="P:SenseGloveCs.Kinematics.SenseGloveModel.FingerLengths">
            <summary> The lengths of the finger phalanges (x-values) in mm.  </summary>
        </member>
        <member name="P:SenseGloveCs.Kinematics.SenseGloveModel.JointPositions">
            <summary> The joint positions of the fingers, from thumb to pinky, relative to the shared origin. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveModel.FingerTipPositions">
            <summary>
            Retrieve the fingertip positions; which is the thimble positions plus their compensation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveModel.ResetHand">
            <summary> Reset the hand values (joint positions, finger lengths) back to their default values. </summary>
        </member>
        <member name="P:SenseGloveCs.Kinematics.SenseGloveModel.Thumb">
            <summary> Access the virtual Thumb properties. </summary>
        </member>
        <member name="P:SenseGloveCs.Kinematics.SenseGloveModel.Index">
            <summary> Access the virtual Index Finger properties. </summary>
        </member>
        <member name="P:SenseGloveCs.Kinematics.SenseGloveModel.Middle">
            <summary> Access the virtual Middle Finger properties. </summary>
        </member>
        <member name="P:SenseGloveCs.Kinematics.SenseGloveModel.Ring">
            <summary> Access the virtual Ring Finger properties. </summary>
        </member>
        <member name="P:SenseGloveCs.Kinematics.SenseGloveModel.Pinky">
            <summary> Access the virtual Pinky Finger properties. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveModel.ToGloveAngles(System.Single[][])">
            <summary> Convert a set of sensor input into a  </summary>
            <param name="sensorInput"></param>
            <returns></returns>
            <remarks> Placed here because it is used to update the glove. </remarks>
        </member>
        <member name="T:SenseGloveCs.Kinematics.IKSolver">
            <summary> Inverse-Kinematics of the real hand. Hard to calibrate but very accurate if succesfull. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IKSolver.a">
            <summary> Values used to calculate the thumb twist angle based on thumb abduction; ax^2 + bx + c. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IKSolver.b">
            <summary> Values used to calculate the thumb twist angle based on thumb abduction; ax^2 + bx + c. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IKSolver.c">
            <summary> Values used to calculate the thumb twist angle based on thumb abduction; ax^2 + bx + c. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IKSolver.minTwist">
            <summary> The limits of the thumb twist. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IKSolver.maxTwist">
            <summary> The limits of the thumb twist. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.#ctor">
            <summary> Creates a new instance of the Inverse Kinematic Solver. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.SetThumbInterpolation(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Set the thumb twist estimation values. </summary>
            <param name="A"></param>
            <param name="B"></param>
            <param name="C"></param>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.ParseThumbInterpolation(System.String,System.Boolean)">
            <summary> Apply thumb interpolation; parsed from a constants string. </summary>
            <param name="rawInterpolation"></param>
            <param name="isRight"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.EstimateThumbTwist(System.Single)">
            <summary> Estimate the thumb twist based on the abduction / adduction </summary>
            <param name="abd"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.ResetParameters(System.Boolean)">
            <summary> Reset the parameters specific to this Solver. </summary>
            <param name="isRight"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.Solve(SenseGloveCs.Kinematics.SenseGloveModel@,System.Single[][],System.Boolean,System.Boolean[])">
            <summary>
            Solve and update the SenseGloveModel using an Inverse-Kinematic Approach
            </summary>
            <param name="model"></param>
            <param name="sensorAngles"></param>
            <param name="naturalLimits"></param>
            <param name="fingers"></param>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IKSolver.mcpAbdMin">
            <summary> Utility Values for now. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.IKSolver.mcpAbdMax">
            <summary> Utility Values for now. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.SolveIKThumb(SenseGloveCs.Kinematics.JointChain,SenseGloveCs.Kinematics.JointChain@,SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Quat,System.Boolean)">
            <summary> Solve the inverse kinematics of the thumb </summary>
            <param name="glove"></param>
            <param name="thumb"></param>
            <param name="thimbleCompD"></param>
            <param name="thimbleCompR"></param>
            <param name="limitAngles"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.SolveIKFinger(SenseGloveCs.Kinematics.JointChain,SenseGloveCs.Kinematics.JointChain@,SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Quat,System.Boolean)">
            <summary> Solve the inverse Kinematics of the finger  </summary>
            <param name="glove"></param>
            <param name="finger"></param>
            <param name="thimbleCompD"></param>
            <param name="thimbleCompR"></param>
            <param name="limitAngles"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.IKSolver.Solve2ArmSystem(SenseGloveCs.Kinematics.Vect3D,System.Single,System.Single)">
            <summary> Solve a 2-arm inverse kinematic system. </summary>
            <param name="P">A point P relative to an origin O</param>
            <param name="L1">The body between L2 to the origin. </param>
            <param name="L2">The body between L1 and point P </param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.SenseGloveSolver">
            <summary> Solves a kinematic system of the hand, based on the Sense Glove  </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveSolver.Solve(SenseGloveCs.Kinematics.SenseGloveModel@,System.Single[][],System.Boolean,System.Boolean[])">
            <summary> Update a SenseGlove Kinematics model of the hand using this solver. </summary>
            <param name="model"></param>
            <param name="sensorAngles"></param>
            <param name="naturalLimits"></param>
            <param name="fingers"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveSolver.ResetParameters(System.Boolean)">
            <summary> Reset the parameters of this solver back to default values </summary>
            <remarks>Includes things like finger lengths and interpolation values.</remarks>
        </member>
        <member name="M:SenseGloveCs.Kinematics.SenseGloveSolver.ValidateFingers(System.Boolean[])">
            <summary> Validate the optional input for the fingers, ensuring it has enough values and is not null. </summary>
            <param name="fingers"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Kinematics.Interp4Sensors">
            <summary> Interpolate over 4 sensors. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Interp4Sensors.imu_interpolations">
            <summary> The interpolation set of this solver. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Interp4Sensors.#ctor(System.Boolean)">
            <summary> Create a new solver. </summary>
            <param name="isRight"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Interp4Sensors.Solve(SenseGloveCs.Kinematics.SenseGloveModel@,System.Single[][],System.Boolean,System.Boolean[])">
            <summary>
            Solve the Sense Glove algorithm by interpolating the sum of the sensor angles.
            Also updates the glove!
            </summary>
            <param name="model"></param>
            <param name="sensorAngles"></param>
            <param name="naturalLimits"></param>
            <param name="fingers"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Interp4Sensors.GetFingerAngles(SenseGloveCs.Finger,SenseGloveCs.Kinematics.InterpolationSet_IMU@,System.Single,System.Single,System.Single,System.Boolean)">
            <summary> Retrieve the finger angles from a set of interpolation values. </summary>
            <param name="finger"></param>
            <param name="interpolationSet"></param>
            <param name="abd"></param>
            <param name="flex"></param>
            <param name="twist"></param>
            <param name="naturalLimits"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Interp4Sensors.ResetParameters(System.Boolean)">
            <summary> Reset the interpolation set(s) </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Interp4Sensors.NormalizeAngles(System.Single[][])">
            <summary> Normalize angles into a -180 ..180 range, except for the last bit; which is interpolated to be in the -60...300 range.  </summary>
            <param name="inAngles"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Interp4Sensors.InterpolateThumbIMU(System.Single,System.Single,System.Single,System.Boolean,SenseGloveCs.Kinematics.InterpolationSet_IMU@,SenseGloveCs.Kinematics.JointChain@)">
            <summary> Solve the thumb IMU-interpolation; while also applying forward kinematics. </summary>
            <param name="roll"></param>
            <param name="pitch"></param>
            <param name="yaw"></param>
            <param name="limitJoints"></param>
            <param name="interpolation"></param>
            <param name="finger"></param>
        </member>
        <member name="T:SenseGloveCs.Kinematics.Vect3D">
            <summary> Representation of a vector in 3D space, with proper operations. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Vect3D.x">
            <summary> Vector component </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Vect3D.y">
            <summary> Vector component </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Vect3D.z">
            <summary> Vector component </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.#ctor">
            <summary> Create a new instance of a 3D Vector, with all values set to 0. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.#ctor(SenseGloveCs.Kinematics.Vect3D)">
            <summary> Create a copy fo an existing vector </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.#ctor(System.Single[])">
            <summary> Create a new Vector from a floating point array </summary>
            <param name="V"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.#ctor(System.Single,System.Single,System.Single)">
            <summary> Create a new instance of a 3D Vector </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Z"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.#ctor(System.String,System.Char)">
            <summary> Parse a vector from a string representation </summary>
            <param name="s"></param>
            <param name="delimiter"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.op_Addition(SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Vect3D)">
            <summary> Add two vectors together. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.op_Subtraction(SenseGloveCs.Kinematics.Vect3D,SenseGloveCs.Kinematics.Vect3D)">
            <summary> Subtract two vectors from each other. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.op_Multiply(System.Single,SenseGloveCs.Kinematics.Vect3D)">
            <summary> Scale the vector v by factor S. </summary>
            <param name="S"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.op_Multiply(SenseGloveCs.Kinematics.Quat,SenseGloveCs.Kinematics.Vect3D)">
            <summary>
            Rotate a vector v by quaternion q
            </summary>
            <param name="q"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="P:SenseGloveCs.Kinematics.Vect3D.Magnitude">
            <summary> Retruns the current magnitude (length) of the vector </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.DistanceTo(SenseGloveCs.Kinematics.Vect3D)">
            <summary> Calculate the distance between this vector and another </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.RotateX(System.Single)">
            <summary> Rotate this vector around its Z axis by zAngle (in radians). It is a right-handed coordinate system. </summary>
            <param name="xAngle"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.RotateY(System.Single)">
            <summary> Rotate this vector around its Z axis by zAngle (in radians). It is a right-handed coordinate system. </summary>
            <param name="yAngle"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.RotateZ(System.Single)">
            <summary> Rotate this vector around its Z axis by zAngle (in radians). It is a right-handed coordinate system. </summary>
            <param name="zAngle"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.Rotate3D(System.Single,System.Single,System.Single)">
            <summary> Rotate this vector by three angles, using a ZYX euler rotation(s). </summary>
            <param name="xAngle"></param>
            <param name="yAngle"></param>
            <param name="zAngle"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.Rotate3D(SenseGloveCs.Kinematics.Vect3D)">
            <summary> Rotate this vector in a 3D rotation, using the XYZ angles stored in R </summary>
            <param name="R"></param>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.Normalize">
            <summary> Normaliz this vector such that its length becomes 1 </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.ToString">
            <summary> Return a string representation of this vector. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.Equals(System.Object)">
            <summary> Check if one vector equals another </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.GetHashCode">
            <summary> Returns Base.GetHashCode() </summary>
            <returns></returns>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Vect3D.zero">
            <summary> A 'zero' vector. </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.X">
            <summary> The Z-Axis </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.Y">
            <summary> The Z-Axis </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Vect3D.Z">
            <summary> The Z-Axis </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.JointLimit">
            <summary> Utility enum to access minimum and maximum joint limits </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.JointLimit.Min">
            <summary> Access the minimum joint value. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.JointLimit.Max">
            <summary> Access the maximum joint value. </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.JointMovement">
            <summary> Joint movements that can be limited </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.JointMovement.Twist">
            <summary> Roll or twisting motion arounf the x-axis, mostly used for the thumb. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.JointMovement.Flexion">
            <summary> Flexing of the fingers around the y-axis Used by all fingers. </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.JointMovement.Abduction">
            <summary> Sideways motionaround the z-axis that displaces the flexion plane. </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.FingerJoint">
            <summary> Finger joints, from proximal to distal  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.FingerJoint.MCP">
            <summary> The first finger joint (MetaCarpal-Phalangeal joint). </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.FingerJoint.PIP">
            <summary> The second finger joint (Proximal-InterPhalangeal joint). </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.FingerJoint.DIP">
            <summary> The third finger joint (Distal-InterPhalangeal joint). </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.ThumbJoint">
            <summary> Thumb Joints, from proximal to distal </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.ThumbJoint.CMC">
            <summary> The first thumb joint (Carpo-Metacarpal joint) </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.ThumbJoint.MCP">
            <summary> The second thumb joint (MetaCarpal-Phalangeal joint). </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.ThumbJoint.IP">
            <summary> Tehe third thumb joint (InterPhalangeal Joint) </summary>
        </member>
        <member name="T:SenseGloveCs.Kinematics.Anatomy">
            <summary> Utility Class containing hard-coded anatomical data.  </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Anatomy.PI">
            <summary>
            No float conversion required.
            </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Anatomy.fingerLengthRatios">
            <summary>
            The finger Length Ratio's used for calibration
            </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Anatomy.fingerJointLimits">
            <summary>
            The minimum- and maximum joint angles of the fingers,
            sorted by joint (MCP, PIP, DIP) and per movement (pronation/supination, flexion/extension, abduction/adduction).
            Empty limits means there are none.
            </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Anatomy.GetFingerLimit(SenseGloveCs.Kinematics.FingerJoint,SenseGloveCs.Kinematics.JointMovement,SenseGloveCs.Kinematics.JointLimit)">
            <summary> Retrieve a specific finger joint limit. </summary>
            <param name="joint"></param>
            <param name="movement"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Anatomy.LimitFingerAngle(System.Single,SenseGloveCs.Kinematics.FingerJoint,SenseGloveCs.Kinematics.JointMovement)">
            <summary> Limit a finger joint angle between the minimum and maximum of a specific joint [0..2] </summary>
            <param name="value"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Anatomy.thumbJointLimits">
            <summary>
            The minimum- and maximum joint angles of the thumb.
            sorted by joint (CMC, MCP, IP) and per movement (pronation/supination, flexion/extension, abduction/adduction).
            Empty limits means there are none.
            </summary>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Anatomy.GetThumbLimit(SenseGloveCs.Kinematics.ThumbJoint,SenseGloveCs.Kinematics.JointMovement,SenseGloveCs.Kinematics.JointLimit)">
            <summary> Retrieve a specific thumb joint limit. </summary>
            <param name="joint"></param>
            <param name="movement"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Kinematics.Anatomy.LimitThumbAngle(System.Single,SenseGloveCs.Kinematics.ThumbJoint,SenseGloveCs.Kinematics.JointMovement)">
            <summary> Limit the angle around a specific thumb joint [0..2] </summary>
            <param name="value"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Anatomy.wristLimits">
            <summary>
            Limits of the wrist (pronation/supination, dorsal/palmar flexion, radial/ulnar deviation)
            </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Anatomy.P95HandLengths">
            <summary>
            The length of the 95th percentile male population.
            Index finger length based on DINED Dutch Students, male (2016) * 1.1, other lengths based on this variable
            </summary>
        </member>
        <member name="F:SenseGloveCs.Kinematics.Anatomy.P5HandLengths">
            <summary>
            The length of the 5th percentile female population.
            Index finger length based on DINED Dutch Students, female (2016) * 0.9,  other lengths based on this variable
            </summary>
        </member>
        <member name="T:SenseGloveCs.CalibrationArgs">
            <summary> Sent when any type of calibration completes; containing a snapshot from 'before' and 'after'. </summary>
        </member>
        <member name="F:SenseGloveCs.CalibrationArgs.before">
            <summary> A copy of glove data before calibration. </summary>
        </member>
        <member name="F:SenseGloveCs.CalibrationArgs.after">
            <summary> A copy of the glove data after calibration finises. </summary>
        </member>
        <member name="M:SenseGloveCs.CalibrationArgs.#ctor(SenseGloveCs.GloveData)">
            <summary> Create a new instance of CalibrationArgs where the before situaltion is exatly the same as the after. </summary>
            <param name="befr"></param>
        </member>
        <member name="M:SenseGloveCs.CalibrationArgs.#ctor(SenseGloveCs.GloveData,SenseGloveCs.GloveData)">
            <summary> Creates a new Instance of CalibrationArgs. </summary>
        </member>
        <member name="T:SenseGloveCs.Algorithm">
            <summary> The Type of Calibration to initate </summary>
        </member>
        <member name="F:SenseGloveCs.Algorithm.PointsOnACircle2D">
            <summary> Calculate the joint positions and finger lengths based on the origin and radius of a circle. </summary>
        </member>
        <member name="F:SenseGloveCs.Algorithm.TwoGestures2D">
            <summary> Calculate joint positions and finger lengths based on two predefined gestures and a set of finger length ratio's </summary>
        </member>
        <member name="F:SenseGloveCs.Algorithm.ThreeGestures2D">
            <summary> Calculate the joint positions and finger lengths based on three predefined gestures. </summary>
        </member>
        <member name="T:SenseGloveCs.CalibrationType">
            <summary> The way that new datapoints are gathered for the calibration algorithm, </summary>
        </member>
        <member name="F:SenseGloveCs.CalibrationType.Manual">
            <summary> The developer decides when the snapshots are gathered. </summary>
        </member>
        <member name="F:SenseGloveCs.CalibrationType.SemiAutomatic">
            <summary> The algorithm decides when to add a snapshot if the glove is stable and the points are far away enough. </summary>
        </member>
        <member name="F:SenseGloveCs.CalibrationType.Automatic">
            <summary> The SenseGlove collects snapshots, then chooses the most likely points to perform calibration with. </summary>
        </member>
        <member name="T:SenseGloveCs.DataBlock">
            <summary> A block of data containing a 'snapshot' of a device </summary>
        </member>
        <member name="F:SenseGloveCs.DataBlock.deviceID">
            <summary> The deviceID of this SenseGlove </summary>
        </member>
        <member name="F:SenseGloveCs.DataBlock.firmwareVersion">
            <summary> The Firmware version parsed to a floating point (example v2.19 -> 2.19f) </summary>
        </member>
        <member name="F:SenseGloveCs.DataBlock.deviceVersion">
            <summary> Device version as a floating point number (example Mk22.01 -> 22.01f). </summary>
        </member>
        <member name="F:SenseGloveCs.DataBlock.dataLoaded">
            <summary> Determines if this data block has recieved all of its constants and is ready to Update </summary>
        </member>
        <member name="M:SenseGloveCs.DataBlock.DeepClone``1(``0)">
            <summary> Template to serialize and deserialize a variable of any type, used to deepcopy serializable objects  </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.BuzzMotorPattern">
            <summary> The pattern of the Buzz Motor </summary>
        </member>
        <member name="F:SenseGloveCs.BuzzMotorPattern.Constant">
            <summary> Have the BuzzMotor pulse with the desired Magnitude for the Duration </summary>
        </member>
        <member name="T:SenseGloveCs.BuzzCommand">
            <summary> Contains BuzzMotor Commands and a timer to fire on an elapsed command. </summary>
        </member>
        <member name="F:SenseGloveCs.BuzzCommand.MAX_BUZZ_TIME">
            <summary> The maximum time [in ms] that the buzzMotors may be active for. After this time, they are automatically shut down. </summary>
        </member>
        <member name="F:SenseGloveCs.BuzzCommand.lastCmd">
            <summary> The last sent buzzmotor command. </summary>
        </member>
        <member name="M:SenseGloveCs.BuzzCommand.#ctor">
            <summary> Create an empty buzzMotor command </summary>
        </member>
        <member name="M:SenseGloveCs.BuzzCommand.Finished">
            <summary> Check whether or not the Buzzmotor pattern has finshed. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.BuzzCommand.LastCmd">
            <summary> Check the latest command of this finger. </summary>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Finger">
            <summary>
            Enumerator used to ease shifing / implementation of the kinematic variables.
            </summary>
        </member>
        <member name="F:SenseGloveCs.Finger.Thumb">
            <summary> Responsible for our evolutionary success! </summary>
        </member>
        <member name="F:SenseGloveCs.Finger.Index">
            <summary> Used to point at what you want </summary>
        </member>
        <member name="F:SenseGloveCs.Finger.Middle">
            <summary> On its own, this one is used to indicate frustration. </summary>
        </member>
        <member name="F:SenseGloveCs.Finger.Ring">
            <summary> If you like it then you should have put a ___ on it </summary>
        </member>
        <member name="F:SenseGloveCs.Finger.Little">
            <summary> The Little Finger, but you can call me Petyr. </summary>
        </member>
        <member name="F:SenseGloveCs.Finger.All">
            <summary> Utility value used for iteration to check if all values are present </summary>
        </member>
        <member name="T:SenseGloveCs.UpdateLevel">
            <summary>
            An enumerator used to indicate to which level the Kinematical Model will be updated
            </summary>
        </member>
        <member name="F:SenseGloveCs.UpdateLevel.GloveAngles">
            <summary> (0/3) Update only the input angles; both those in the GloveData (sorted per finger) and those in gloveAngles (sorted as roll-pitch-yaw) </summary>
        </member>
        <member name="F:SenseGloveCs.UpdateLevel.GlovePositions">
            <summary> (1/3) Using the latest GloveAngles, determine the positions of each glove joint. Useful if you want to know just the fingertip positions. </summary>
        </member>
        <member name="F:SenseGloveCs.UpdateLevel.HandAngles">
            <summary> (2/3) Calculate the fingertip positions and the joint angles of the fingers. Required for accurate Gesture Recognition </summary>
        </member>
        <member name="F:SenseGloveCs.UpdateLevel.HandPositions">
            <summary> (3/3) Using the latest HandAngles, calculate the position of each finger joint and -tip. </summary>
        </member>
        <member name="T:SenseGloveCs.Solver">
            <summary> Which solver to use for the Sense Glove. </summary>
        </member>
        <member name="F:SenseGloveCs.Solver.Interpolate4Sensors">
            <summary> Interpolate hand angles over the total flexion and abduction of the glove. </summary>
        </member>
        <member name="F:SenseGloveCs.Solver.Interpolate2Sensors">
            <summary> Interpolate hand angles over the proximal abduction and distal flexion. </summary>
        </member>
        <member name="F:SenseGloveCs.Solver.InverseKinematics">
            <summary> Inverse Kinematics over the thimble position and rotation, able to represent the hand very accurately, but only with enough calibration. </summary>
        </member>
        <member name="F:SenseGloveCs.Solver.DistanceBased">
            <summary> Solves hand angles such that the fingers of the Virtual Hand model are placed at the same distance as the Glove's Exoskeleton. </summary>
        </member>
        <member name="F:SenseGloveCs.Solver.Custom">
            <summary> A custom solver; in this case; only solve all glove variables. </summary>
            <remarks> Should always be last </remarks>
        </member>
        <member name="T:SenseGloveCs.ReMind.BodyPart">
            <summary> Contains all data needed to calculate the rotation of a body part in the Re-Minder's local coordinate system. </summary>\
        </member>
        <member name="F:SenseGloveCs.ReMind.BodyPart.Qlocal">
            <summary> The orientation of the body part within the  </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodyPart.Qhardware">
            <summary> The orientation of this body part's IMU terminal relative to the origin </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodyPart.Qcorrected">
            <summary> The IMU value, corrected with the hardware compensation (used for calibration) </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodyPart.QtoReference">
            <summary> The quaternion used to move the orientation relative to the calibrate position (?) </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodyPart.Qcomp">
            <summary> 
            Contains the total compensation quaternion, comprised of the Hardware and Calibration quaternions. 
            Saves an extra quaternion operation every Update frame.
            </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.BodyPart.#ctor(SenseGloveCs.Kinematics.Quat)">
            <summary> Create a new instance of the BodyPart </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.BodyPart.CalculateCompensation">
            <summary> Recalculate the compensation quaternion </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.BodyPart.SetHardwareOrientation(SenseGloveCs.Kinematics.Quat)">
            <summary> Set the hardware orientation of this body part. </summary>
            <param name="hardwareComp"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.BodyPart.GetHardwareOrientation">
            <summary> Retrieve the hardware orientation of this bodypart's IMU </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMind.BodyPart.Calibrate(SenseGloveCs.Kinematics.Quat)">
            <summary> Set this IMU orientation as the 'base' from which to move. </summary>
            <param name="QlocalReference"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.BodyPart.Update(SenseGloveCs.ReMind.IMUValue)">
            <summary> Update the local orientation of this BodyPart using its corresponding sensorData. </summary>
            <param name="sensorData"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.BodyPart.RelativeTo(SenseGloveCs.Kinematics.Quat)">
            <summary> Calculate this bodypart orientation relative to another body part </summary>
            <param name="otherQlocal"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.BodyPart.RelativeTo(SenseGloveCs.ReMind.BodyPart)">
            <summary> Calculate this bodypart orientation relative to another body part </summary>
            <param name="relativeTo"></param>
        </member>
        <member name="T:SenseGloveCs.ReMind.CalibrationPoses">
            <summary> Contains sets of Calibration angles. </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.CalibrationPoses.GetAngles(SenseGloveCs.ReMind.CalibrationPose)">
            <summary> Retieve and array of (abs) calibration angles </summary>
            <param name="pose"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.ReMind.CalibrationPose">
            <summary> A default calibration pose, used to access a set of angles. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.CalibrationPose.StandUpArmsToSide">
            <summary> Standing up with one's arms to the side. </summary>
        </member>
        <member name="T:SenseGloveCs.ReMind.ReMinderData">
            <summary> Represents a data package of a Re-Minder; a container of all sensor values and the corresponding human model </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMinderData.sensorValues">
            <summary> Contains sensor data for all of the body segments, and data of whether they have been activated or not. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMinderData.body">
            <summary> Contains all orientations in the ReMinder's local coordinate system, based on calibration and corrections. </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.#ctor">
            <summary> Creates a default Re-Minder data block. </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.Copy">
            <summary> Deep copy this ReMinderData block, so that any (accidental) changes to it do not affect its parent.</summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.LoadConstants(System.String)">
            <summary> Parse a constants string into useable data for the Re-Minder. </summary>
            <param name="C"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.ParseMetaData(System.String)">
            <summary> Parse metadata </summary>
            <param name="M"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.ParseSensorStream(System.String[])">
            <summary> Update the SensorValues from an input string. </summary>
            <param name="split"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.UpdateSensorData(SenseGloveCs.ReMind.IMUValue[])">
            <summary> Manually assign new Sensor Values. </summary>
            <param name="newValues"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.SetSensorValue(SenseGloveCs.ReMind.IMUValue)">
            <summary> Update a single Sensor value </summary>
            <param name="value"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.Update">
            <summary> After parsing the latest sensor stream, update the Human Node Model </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.Calibrate(SenseGloveCs.Kinematics.Quat[])">
            <summary> Calibrate the human model using a set of CalibrationQuaternions </summary>
            <param name="calibrationQuaternions"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.GetSensorValue(SenseGloveCs.ReMind.BodySegment)">
            <summary> Get the absolute orientation belonging to the desired bodypart </summary>
            <param name="ofBodyPart"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.GetOrientation(SenseGloveCs.ReMind.BodySegment)">
            <summary> Retireve the orientation value(s) of a specific bodypart. </summary>
            <param name="ofBodyPart"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMind.ReMinderData.GetOrientation(SenseGloveCs.ReMind.BodySegment,SenseGloveCs.ReMind.BodySegment)">
            <summary> Retrieve the relative rotations of a bodypart relative to another bodyPart </summary>
            <param name="ofBodyPart"></param>
            <param name="relativeTo"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.ReMind.BodySegment">
            <summary> All available positions of an IMU of the Re-MindR system. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.LowerBody">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.UpperBody">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.Head">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.LeftUpperArm">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.LeftLowerArm">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.LeftWrist">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.RightUpperArm">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.RightLowerArm">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.RightWrist">
            <summary> </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.BodySegment.NotAvailable">
            <summary> Also used as utility value. </summary>
            <remarks> Place no further enumerators below this point. </remarks>
        </member>
        <member name="T:SenseGloveCs.ReMind.Segments">
            <summary> Utility class to convert a string notation or index to a BodySegment. </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.Segments.Parse(System.String)">
            <summary> Converts a string notation into a BodySegment </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMind.Segments.Parse(System.Int32)">
            <summary> Parse an integer into its proper BodySegment enumerator </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.ReMind.IMUValue">
            <summary> A single dataPoint of the Re-Minder </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.x">
            <summary> The raw (absolute) quaternion values of the IMU </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.y">
            <summary> The raw (absolute) quaternion values of the IMU </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.z">
            <summary> The raw (absolute) quaternion values of the IMU </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.w">
            <summary> The raw (absolute) quaternion values of the IMU </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.position">
            <summary> Which part of the body this IMU is positioned on </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.isActive">
            <summary> Indicates that this IMU is active during the latest Update function. </summary>
        </member>
        <member name="M:SenseGloveCs.ReMind.IMUValue.#ctor(SenseGloveCs.ReMind.BodySegment,System.Boolean)">
            <summary> Create a new instance of an IMUValue at a specified location </summary>
            <param name="active"></param>
            <param name="pos"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.IMUValue.#ctor(SenseGloveCs.ReMind.BodySegment,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary> Create a new IMU values at a specified position. </summary>
            <param name="pos"></param>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Z"></param>
            <param name="W"></param>
            <param name="active"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.IMUValue.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new IMU values at a specified position. </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Z"></param>
            <param name="W"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.IMUValue.#ctor(SenseGloveCs.Kinematics.Quat)">
            <summary> Create a new IMU values at a specified position. </summary>
            <param name="Q"></param>
        </member>
        <member name="M:SenseGloveCs.ReMind.IMUValue.FromString(System.String)">
            <summary> Parse an IMUValue from a string. </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.xInd">
            <summary> Indices used to access IMU data from a raw string. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.yInd">
            <summary> Indices used to access IMU data from a raw string. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.zInd">
            <summary> Indices used to access IMU data from a raw string. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.wInd">
            <summary> Indices used to access IMU data from a raw string. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.IDInd">
            <summary> Indices used to access IMU data from a raw string. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.IMUValue.valueLength">
            <summary> The total amount of values to extract from a string. </summary>
        </member>
        <member name="T:SenseGloveCs.ReMind.ReMindConst">
            <summary> Used to access / adjust the ReMinder constants. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMindConst.ConstOpen">
            <summary> C: </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMindConst.All">
            <summary> Utility variable, used to check if all constants are present. </summary>
        </member>
        <member name="T:SenseGloveCs.ReMind.ReMindMeta">
            <summary> Used to access / adjust the Metadata of the Re-Minder </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMindMeta.MetaOpen">
            <summary> M: </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMindMeta.CalibrationStatus">
            <summary> The calibration status of the BNO055 IMUs </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMindMeta.All">
            <summary> Utility variable, used to check if all metadata is present. </summary>
        </member>
        <member name="T:SenseGloveCs.ReMind.ReMindVars">
            <summary> Used to access or adjust the  </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMindVars.SenseOpen">
            <summary> S: </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMindVars.IMUs">
            <summary> Contains the IMU values </summary>
        </member>
        <member name="F:SenseGloveCs.ReMind.ReMindVars.All">
            <summary> Utility variable, used to check if all sensor values are present. </summary>
        </member>
        <member name="T:SenseGloveCs.SG_ClientData">
            <summary> Data received from a Sense Glove server </summary>
        </member>
        <member name="T:SenseGloveCs.SG_ClientData.DataFormat">
            <summary> Enumerator used for felxible parsing </summary>
        </member>
        <member name="F:SenseGloveCs.SG_ClientData.DataFormat.LeftRight">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.SG_ClientData.DataFormat.HWVersion">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.SG_ClientData.DataFormat.FWVersion">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.SG_ClientData.DataFormat.Connected">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.SG_ClientData.DataFormat.SensorData">
            <summary>  </summary>
        </member>
        <member name="F:SenseGloveCs.SG_ClientData.DataFormat.All">
            <summary>  </summary>
        </member>
        <member name="P:SenseGloveCs.SG_ClientData.IsRight">
            <summary>  </summary>
        </member>
        <member name="P:SenseGloveCs.SG_ClientData.IsConnected">
            <summary>  </summary>
        </member>
        <member name="P:SenseGloveCs.SG_ClientData.HWVersion">
            <summary>  </summary>
        </member>
        <member name="P:SenseGloveCs.SG_ClientData.FWVersion">
            <summary>  </summary>
        </member>
        <member name="P:SenseGloveCs.SG_ClientData.SensorData">
            <summary>  </summary>
        </member>
        <member name="P:SenseGloveCs.SG_ClientData.ConnectionReady">
            <summary> True if this device is ready to recieve data. </summary>
        </member>
        <member name="F:SenseGloveCs.SG_ClientData.dataDelim">
            <summary>  </summary>
        </member>
        <member name="M:SenseGloveCs.SG_ClientData.ToString">
            <summary>  </summary>
        </member>
        <member name="M:SenseGloveCs.SG_ClientData.Deserialize(System.String)">
            <summary>  </summary>
        </member>
        <member name="T:SenseGloveCs.Diagnostics.ExitCodes">
            <summary>
            Error Codes
            </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.None">
            <summary> No error occured. Manual or automatic disconnect. Everything is fine. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.Comm_BufferOverload">
            <summary> The SenseGlove is sending data too fast for the Readthread to keep up. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.Comm_USBDisconnect">
            <summary> The USB cable has been disconnected. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.Comm_UnhandledEx">
            <summary> Exited because an unhandled exception occured in the readthread. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.Comm_TimeOut">
            <summary> TimeOutException occured. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.Comm_PortClosed">
            <summary> The Port is closed, and we were not sending anything. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.Comm_Finalizer">
            <summary> The communicator has been disconnected because the destructor has been called. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.DevScn_AddressNotAvailable">
            <summary> The connection's address is no longer available to the System. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.DevScn_CouldNotPing">
            <summary> Removed because the DeviceScanner could not ping this device. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.DevScn_UnknownDevice">
            <summary> The device has responded, but does not belong to any deviceType we know. </summary>
            <remarks> Indicates that the DLL is out of date or that the Firmware is not properly implemented. </remarks>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.DevScn_NotValidDevice">
            <summary> The connection was terminated because this is not a valid IO Device. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.DevScn_IDAlreadyConnected">
            <summary> We have found a decvice that is already in memory and still connected to a different address. Most likely two devices with the sameID </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.DevScn_Cleanup">
            <summary> The DeviceScanner has cleaned up this Communicator. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.ExitCodes.Test">
            <summary> Test </summary>
        </member>
        <member name="T:SenseGloveCs.Diagnostics.DebugLevel">
            <summary> 
            The level of Debug Messages one can recieve from the Sense Glove. 
            Note: Higher levels also include the lower ones. (ex. Setting messages to Lv3 means you will recieve lv1 and lv2 messages as well)
            </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.Disabled">
            <summary> The Debugger is disabled, show no messages from the DLL. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.Lv1_ErrorsOnly">
            <summary> Show only if something goes wrong with any of the devices or functions. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.Lv2_CalibrationMessages">
            <summary> Show messages of the Calibration sequences. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.Lv3_DeviceInfo">
            <summary> Show messages related to device- or firmware version. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.Lv4_IOMessages">
            <summary> Messages related to Connecting / Disconnecting </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.Lv5_DeviceScanning">
            <summary> Messages related to the Device Scanning </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.Lv6_ShowMessageRecieved">
            <summary> Show all messages that were recieved from the device </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.Lv7_ShowMessageSent">
            <summary> Show the messages that are sent to the devices. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.lv8_UnitTests">
            <summary> Deep level used to (unit) test certain functions. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugLevel.lv9_ReadThreadDebug">
            <summary> Used to (unit) test the readthread of communicator(s). </summary>
        </member>
        <member name="T:SenseGloveCs.Diagnostics.DebugArgs">
            <summary> Debugging args containing the message sent and its level. </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugArgs.message">
            <summary> The message sent by the Debugger </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.DebugArgs.debugLv">
            <summary> The Debug level of the accompanying message </summary>
        </member>
        <member name="M:SenseGloveCs.Diagnostics.DebugArgs.#ctor(System.String,SenseGloveCs.Diagnostics.DebugLevel)">
            <summary> Create a new Instance of DebugArgs. </summary>
            <param name="msg"></param>
            <param name="lv"></param>
        </member>
        <member name="T:SenseGloveCs.Diagnostics.Debugger">
            <summary>
            Utility class to warn the user about certain errors / warnings that occur in the SenseGloveAPI. Enabled By default. Use SenseGloveAPI.Debugger.Disable() to stop it.
            </summary>
            <remarks> Sealed tells the compiler that this class cannot be inherited. </remarks>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.Debugger.debugLv">
            <summary> The current debug level of the SenseGloveCs.Debugger. </summary>
        </member>
        <member name="M:SenseGloveCs.Diagnostics.Debugger.#ctor">
            <summary> Empty Constructor to create the instance. </summary>
        </member>
        <member name="T:SenseGloveCs.Diagnostics.Debugger.MessageRecievedEventHandler">
            <summary> Delegate for the DebugMessageRecieved event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SenseGloveCs.Diagnostics.Debugger.DebugMessageRecieved">
            <summary> Fires when a new message is recieved by the Debugger. </summary>
        </member>
        <member name="M:SenseGloveCs.Diagnostics.Debugger.OnMessageRecieved(System.String,SenseGloveCs.Diagnostics.DebugLevel)">
            <summary> Constructs DebugArs and Fires the MessageRecieved event. </summary>
            <param name="msg"></param>
            <param name="lvl"></param>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.Debugger.defaultDebugLvl">
            <summary> The Default debug level for any application </summary>
        </member>
        <member name="F:SenseGloveCs.Diagnostics.Debugger.instance">
            <summary> Instance of the Debugger to which events can be subscribed. </summary>
        </member>
        <member name="P:SenseGloveCs.Diagnostics.Debugger.Instance">
            <summary> Access the Debugger instance. </summary>
        </member>
        <member name="P:SenseGloveCs.Diagnostics.Debugger.DebugLevel">
            <summary> The debug level of the Debugger </summary>
        </member>
        <member name="M:SenseGloveCs.Diagnostics.Debugger.Log(System.String,SenseGloveCs.Diagnostics.DebugLevel)">
            <summary>
            Attempt to post output to the System.Console class. If that fails, try to write to the System.Diagnostics.Debug class.
            </summary>
            <param name="message">The message to write to the user.</param>
            <param name="level"></param>
        </member>
        <member name="T:SenseGloveCs.Gestures.StandardGesture">
            <summary>
            Enumerators with which to access basic gestures.
            </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.Fist">
            <summary> All fingers and thumb are flexed </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.Pointing">
            <summary> The index finger is extended while the other fingers are flexed. </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.MiddleFinger">
            <summary> The middle finger is extended while the other three fingers are flexed. Does not take into account the thumb. </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.Scissors">
            <summary> Also known as the 'peace'sign. Both the index and middle finger are extended while the other fingers are flexed.  </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.ThumbsUp">
            <summary> The thumb is extended while the other fingers are flexed. </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.Gun">
            <summary> Both the index finger and thumb are extended while the other fingers are flexed. </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.MetalHorns">
            <summary> Both the index- and little finger and thumb are extended while the other fingers are flexed. </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.TechSupport">
            <summary> Your hand is a phone! Both the thumb and little finger are extended while the other fingers are flexed. </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.DrEvil">
            <summary> The  little finger are extended while the other fingers are flexed. </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.StandardGesture.All">
            <summary> Utility value used for enumeration. </summary>
        </member>
        <member name="T:SenseGloveCs.Gestures.Gesture">
            <summary>
            A Gesture made by the SenseGlove.
            </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.Gesture.wasBeingMade">
            <summary> Indicates that this gesture was being made during the last Update(). </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.Gesture.enteredGesture">
            <summary> Indicates that this gesture was entered during the last Update(). </summary>
        </member>
        <member name="F:SenseGloveCs.Gestures.Gesture.exitedGesture">
            <summary> Indicates that this gesture is no longer being made during the last Update(). </summary>
        </member>
        <member name="M:SenseGloveCs.Gestures.Gesture.Update(System.Single[][][],System.Single[][])">
            <summary>
            The entry point for the SenseGlove, which also handles the event logic.
            </summary>
            <param name="handAngles"></param>
            <param name="wristAngles"></param>
        </member>
        <member name="M:SenseGloveCs.Gestures.Gesture.IsMade">
            <summary>
            Check if the gesture is currently being made. Similar to the Input.GetKey() Function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Gestures.Gesture.Entered">
            <summary>
            Check if the gesture is currently being made. Similar to the Input.GetKeyDown() Function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Gestures.Gesture.Exited">
            <summary>
            True if the Gesture was made . Similar to the Input.GetKeyUp() Function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Gestures.Gesture.CheckForGesture(System.Single[][][],System.Single[][])">
            <summary>
            The function, as Programmed by the Developer, which returns true if the gesture is made with the current HandAngles.
            </summary>
            <param name="handAngles">Array with size of 5, with HandAngles[0] being the thumb and HandAngles[5] being the wrist </param>
            <param name="wristAngles"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Communicator">
            <summary>
            Superclass used by IODevices.
            </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.deviceID">
            <summary> The deviceID of this SenseGlove </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.deviceType">
            <summary>
            The Type of IODevice that this Communicator is sending data to.
            </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.lastValues">
            <summary> the last recieved values from the Sense Glove. </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.activationTime">
            <summary>
            The time since this device was activated by the DLL.
            </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.samplesPerSecond">
            <summary> The number of sensor packets that are received by the communicator every second. </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.padWithBraces">
            <summary> Whether or not to enclose all commands in '{' and '}' a.k.a. curly braces. </summary>
            <remarks>Starts at true since the v2.0 ignores {}.</remarks>
        </member>
        <member name="F:SenseGloveCs.Communicator.idByte">
            <summary> 'I' Used to request ID </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.metaDataByte">
            <summary> 'M' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.constantsByte">
            <summary> 'C' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.resetByte">
            <summary> 'R' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.startByte">
            <summary> 'S' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.stopByte">
            <summary> 's' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.pingByte">
            <summary> 'p' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.newSenseByte">
            <summary> '[' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.endSenseByte">
            <summary> ']' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.newCommandByte">
            <summary> '{' </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.endCommandByte">
            <summary> '}'  </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.escapeByte">
            <summary> Ignore the next command byte if this character was sent previously. </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.rowDelimiter">
            <summary> '|' - Used to group a set of values, for example per finger. </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.colDelimiter">
            <summary> ';' - Used to separate individual values </summary>
        </member>
        <member name="F:SenseGloveCs.Communicator.messageDelimiter">
            <summary> ':' - Used to split a set of different contant values into individual groups. </summary>
        </member>
        <member name="M:SenseGloveCs.Communicator.IsValidDevice">
            <summary>
            Check if this communicator is connected to a valid IODevive 
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.Address">
            <summary>
            Check the Address of this communicator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.IsConnected">
            <summary>
            Check if this Communicator is still connected.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.Connect">
            <summary>
            (Re)Connect to this Communicator
            </summary>
        </member>
        <member name="M:SenseGloveCs.Communicator.Disconnect(SenseGloveCs.Diagnostics.ExitCodes)">
            <summary>
            Disconnect this communicator
            </summary>
        </member>
        <member name="M:SenseGloveCs.Communicator.EqualAddress(SenseGloveCs.Communicator)">
            <summary> Check if this Communicator's Address matches that of another one's </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.EqualDevice(SenseGloveCs.Communicator)">
            <summary> Check if two communicators have been connected to the same device. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:SenseGloveCs.Communicator.ActiveTime">
            <summary> Retrieve the time this communicator has been active for. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.Ping">
            <summary>
            Ping the Sense Glove, checking if the communciation is still running.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.RequestConstants">
            <summary>
            Send a request to the IODevice to retreive additional Identification.
            </summary>
        </member>
        <member name="M:SenseGloveCs.Communicator.RequestMetaData">
            <summary>
            Request MetaData from the IODevice, which will be parsed in the Update command when available
            </summary>
        </member>
        <member name="M:SenseGloveCs.Communicator.ManualReset">
            <summary>
            Manually Reset the IODevice, which will close the readthread of the current Object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.StartSensors">
            <summary>
            Start sending bulk sensor data.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.StopSensors">
            <summary>
            Stop sending bulk sensor data
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.RequestID">
            <summary>
            Request and ID string that contains the device's ID and its deviceType.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.Send2Device(System.String)">
            <summary>
            Send a command to the device. Returns true if the command is succesfully sent.
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.Send2Device(System.Char)">
            <summary>
            Send a command to the device. Returns true if the command is succesfully sent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Communicator.Send2Device(System.Byte[])">
            <summary>
            Send a command to the device. Returns true if the command is succesfully sent.
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Communicator.CommandRecievedEventHandler">
            <summary> Delegate function implemented by subscribers to the OnFingerCalibrationFinished event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SenseGloveCs.Communicator.CommandRecieved">
            <summary> Fires when the new finger lengths and joint positions are calculated. </summary>
        </member>
        <member name="M:SenseGloveCs.Communicator.OnCommandRecieved(System.String)">
            <summary>  Used to call the OnFingerCalibrationFinished event in all subscribers. </summary>
        </member>
        <member name="T:SenseGloveCs.CMDEventArgs">
            <summary> Event arguments passed when recieving a command form the SenseGlove. </summary>
        </member>
        <member name="F:SenseGloveCs.CMDEventArgs.command">
            <summary> The command revieved by the Communicator </summary>
        </member>
        <member name="M:SenseGloveCs.CMDEventArgs.#ctor(System.String)">
            <summary> Create a new instance of the CMDeventArgs </summary>
            <param name="cmd"></param>
        </member>
        <member name="T:SenseGloveCs.GloveData">
            <summary> Data Block representing a 'Snaphot' of the SenseGlove at this moment </summary>
            <remarks> This Data Block contains all variables specific to the Sense Glove. </remarks>
        </member>
        <member name="F:SenseGloveCs.GloveData.functionalities">
            <summary> the functionality of the glove, such as Haptic feedback </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.batteryLife">
            <summary> The remaining battery life of the Sense Glove </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.activeTime">
            <summary>
            The time that the SenseGlove has been on.
            </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.numberOfSensors">
            <summary> The amount of rotational sensors present in this glove. </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.gloveValues">
            <summary>  The last received sensor values of the fingers  </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.imuValues">
            <summary>
            The last received IMU values
            </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.imuCalibration">
            <summary> IMU calibration status. [0..3]. Negative values indicate no calibration status is available (yet). </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.samplesPerSec">
            <summary> The Number of Samples per second </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.kinematics">
            <summary> The kinematic model. </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.wrist">
            <summary>
            Conatins a wrist model
            </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.currentCalStep">
            <summary> The total calibration steps of the currently selected calibration.  </summary>
        </member>
        <member name="F:SenseGloveCs.GloveData.totalCalSteps">
            <summary> The total calibration steps of the currently selected calibration. </summary>
        </member>
        <member name="M:SenseGloveCs.GloveData.ParseConstants(System.String,SenseGloveCs.Kinematics.SenseGloveSolver[]@)">
            <summary>
            Load glove constants from a string received from the communicator.
            </summary>
            <param name="c"></param>
            <param name="solvers"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.GloveData.ParseMetaData(System.String)">
            <summary>
            Load metadata from a string received from the Communicator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.GloveData.ParseSensorStream(System.String[])">
            <summary>
            Parse a single set of sensor data received from the communicator.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:SenseGloveCs.GloveData.UpdateSensorData(System.Single[][],System.Single[])">
            <summary> Manually set two sets of input angles, instead of parsing a Sensor Stream. </summary>
            <param name="sensorAngles"></param>
            <param name="imuQuaternion"></param>
        </member>
        <member name="M:SenseGloveCs.GloveData.Copy">
            <summary>
            Deep copy this SenseData block, so that any (accidental) changes to it do not affect its SenseGlove parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.GloveData.ParseGloveLengths(System.String)">
            <summary> Parse glove lengths as recieved from a constants string. </summary>
            <param name="rawLengths"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.GloveData.ParseStartValues(System.String,SenseGloveCs.Kinematics.Vect3D[]@,SenseGloveCs.Kinematics.Quat[]@)">
            <summary> Parse start values, and fill the StartPositions and StartRotations arrays. </summary>
            <param name="rawStartVals"></param>
            <param name="startPositions"></param>
            <param name="startRotations"></param>
        </member>
        <member name="M:SenseGloveCs.GloveData.GetGloveFunctionality(System.Int32)">
            <summary> Based on an integer value, determine which functionalities this IODevice has. </summary>
            <remarks> 1010 0110 0010 0101 etc. where 1 indicates the finctionality is there. </remarks>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.SenseGloveVars">
            <summary>
            The structure of a sensor data string sent by a Sense Glove
            </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGloveVars.All">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="T:SenseGloveCs.SenseGloveMeta">
            <summary>
            The structure of the MetaData string sent by a Sense Glove
            </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGloveMeta.All">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="T:SenseGloveCs.SenseGloveConst">
            <summary>
            The structure of the Constants string sent by a Sense Glove
            </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGloveConst.ConstOpen">
            <summary> The command indicating the opening of the statement: "{cmd;" </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGloveConst.All">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="T:SenseGloveCs.DefaultValues">
            <summary>
            Utility class to create default (kinematic) values
            </summary>
        </member>
        <member name="F:SenseGloveCs.DefaultValues.x">
            <summary> Default indices for the X, Y, Z and W values. </summary>
        </member>
        <member name="F:SenseGloveCs.DefaultValues.y">
            <summary> Default indices for the X, Y, Z and W values. </summary>
        </member>
        <member name="F:SenseGloveCs.DefaultValues.z">
            <summary> Default indices for the X, Y, Z and W values. </summary>
        </member>
        <member name="F:SenseGloveCs.DefaultValues.w">
            <summary> Default indices for the X, Y, Z and W values. </summary>
        </member>
        <member name="M:SenseGloveCs.DefaultValues.GloveRelPos(System.Boolean)">
            <summary>
            The starting position of the glove origin relative to the wrist
            </summary>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DefaultValues.HandOrientations(System.Boolean)">
            <summary>
            Returns a standard (empty) array of Hand Angles
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DefaultValues.HandRelativeRotations">
            <summary>
            Default container for the Euler angles of the Hand.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DefaultValues.HandRelativeAngles">
            <summary>
            Default container for the Euler angles of the Hand.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DefaultValues.GetFinger(SenseGloveCs.Finger,System.Boolean,SenseGloveCs.Kinematics.Vect3D)">
            <summary> Retrieve a predefined JointChain, representing a hand. </summary>
            <param name="finger"></param>
            <param name="isRight"></param>
            <param name="gloveRelPos"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DefaultValues.DefaultHand(System.Boolean,SenseGloveCs.Kinematics.Vect3D)">
            <summary> Returns a default hand model. </summary>
            <param name="isRight"></param>
            <param name="gloveRelPos"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.ReMinder">
            <summary> An IMU-Suit that can be used for varying purposes. </summary>
        </member>
        <member name="F:SenseGloveCs.ReMinder.data">
            <summary> The actual data of the Re-Minder, inaccessible to keep it from being altered. </summary>
        </member>
        <member name="M:SenseGloveCs.ReMinder.#ctor">
            <summary>Create a new Reminder object</summary>
        </member>
        <member name="M:SenseGloveCs.ReMinder.#ctor(SenseGloveCs.Communicator)">
            <summary> Create a new ReMinder, and instantly connect it to the source. </summary>
            <param name="source"></param>
        </member>
        <member name="M:SenseGloveCs.ReMinder.Finalize">
            <summary> Ensure the Destructor is called. </summary>
        </member>
        <member name="M:SenseGloveCs.ReMinder.IsReady">
            <summary> Check whether or not this ReMinder has recieved its constants and is ready to stream sensor data. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMinder.ParseConstants(System.String)">
            <summary> Parse the constants (deviceInfo) from the Re-Minder. </summary>
            <param name="C"></param>
        </member>
        <member name="M:SenseGloveCs.ReMinder.ParseMetaData(System.String)">
            <summary> Parse the MetaData of a Re-Minder, which includes data about the sensors. </summary>
            <param name="M"></param>
        </member>
        <member name="M:SenseGloveCs.ReMinder.DeviceID">
            <summary> Retrieve the device's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMinder.GetData(System.Boolean)">
            <summary> Retrieve a copy of the latest data from the Re-Minder.  </summary>
            <param name="recalculate"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMinder.Update">
            <summary> Update the Re-Minder with the latest sensor values. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.ReMinder.Calibrate(SenseGloveCs.ReMind.CalibrationPose)">
            <summary> Calibrate the sensors; the chosen pose is the new 'zero' point. </summary>
            <param name="pose"></param>
        </member>
        <member name="M:SenseGloveCs.ReMinder.Calibrate(SenseGloveCs.Kinematics.Quat[])">
            <summary> Calibrate the human model using a set of calibration Quaternions. </summary>
            <param name="calibrationQuaternions"></param>
        </member>
        <member name="M:SenseGloveCs.ReMinder.Calibrate(SenseGloveCs.ReMind.BodySegment,SenseGloveCs.Kinematics.Quat)">
            <summary> Calibrate a specific body part using a quaternion. </summary>
            <param name="bodyPart"></param>
            <param name="quaternion"></param>
        </member>
        <member name="T:SenseGloveCs.DeviceScanner">
            <summary> Scans for IODevices, including Sense Gloves. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.possibleDevices">
            <summary> List of Communicators that may or may not be connected to a IODevice. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.detectedDevices">
            <summary> list of all IODevices that have been detected on this system. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.eventsFired">
            <summary> Keeps track of which DeviceDetect events have been fired. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.isScanning">
            <summary> Indicated that the DeviceScanner is currently active. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.updateFlag">
            <summary> Ensures our update function is not called too often. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.retryMissedConnections">
            <summary> If set to true, the DeviceScanner will continue to attempt connections with communicators untill they can connect </summary>
            <remarks> Important to do with wireless communications, as those bastartds show up but don't actually want to connect yet. </remarks>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.scanTimer">
            <summary> Worker thread responsible for checking (new) connections. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.defaultScanDelay">
            <summary> The default time (in ms) in between which the Devicescanner pings for new addresses. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.pingTime">
            <summary> The default time (in ms) that a Communicator has to respond with a valid IDResponse. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.olderAddresses">
            <summary> Tells the communicator classes whether or not they need to correct their addresses for older dotnet version. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceScanner.instance">
            <summary> Instance of the DeviceScanner, which fires events to subscribe to. </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.#ctor">
            <summary> Empty Constructor </summary>
        </member>
        <member name="P:SenseGloveCs.DeviceScanner.Instance">
            <summary> Retrieve the DeviceScanner instance; used to subscribe to events. </summary>
        </member>
        <member name="P:SenseGloveCs.DeviceScanner.ScanInterval">
            <summary> The time (in ms) the DeviceScanner waits before checking connections again. Changing this value resets the timer. </summary>
        </member>
        <member name="P:SenseGloveCs.DeviceScanner.ResponseTime">
            <summary> The time (in ms) that a device has to respond with a proper ID request. </summary>
        </member>
        <member name="P:SenseGloveCs.DeviceScanner.IsScanning">
            <summary> Check if the deviceScanner is currently scanning for devices. </summary>
        </member>
        <member name="P:SenseGloveCs.DeviceScanner.RetryMissedConnections">
            <summary> Determines if the DeviceScanner should keep trying to open new connections until they have succefully connectd once. </summary>
        </member>
        <member name="P:SenseGloveCs.DeviceScanner.DeviceCount">
            <summary> Check how many devices have been detected by the Sense Glove API. </summary>
        </member>
        <member name="P:SenseGloveCs.DeviceScanner.AllDevices">
            <summary> Retrieve a list of detected devices. </summary>
        </member>
        <member name="P:SenseGloveCs.DeviceScanner.SenseGloves">
            <summary> Returns a list of all loaded Sense Gloves. </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.ReportConnections">
            <summary> Creates a report for each active connection, showing its address and status </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.ReportConnection(SenseGloveCs.Communicator)">
            <summary> Generate a report from one of the possibleDevices lines </summary>
            <param name="com"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.ReportDevice(SenseGloveCs.IODevice)">
            <summary> Generate a report from one of the DetectedDevices. </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.DeviceScanner.DeviceDetectedHandler">
            <summary> Event delegate for the Device Detected Handler </summary>
            <param name="source"> Which script called the function. As per the singleton pattern, it will be null. </param>
            <param name="args"> Shows which Device is detected. </param>
        </member>
        <member name="E:SenseGloveCs.DeviceScanner.DeviceDetected">
            <summary> 
            Fires when a new device, compatible with the Sense Glove communication architecture is detected. 
            Events for specific devices are available as well.
            </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.OnDeviceDetected(SenseGloveCs.IODevice)">
            <summary> Fire a DeviceDetected Event. </summary>
            <remarks> Scan for device here? </remarks>
            <param name="newDevice"></param>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.OnSpecificConnectEvent(SenseGloveCs.IODevice)">
            <summary> Called during the DeviceDetected event to fire an additional event for specific IODevices. </summary>
            <param name="device"></param>
        </member>
        <member name="E:SenseGloveCs.DeviceScanner.SenseGloveDetected">
            <summary> Fires when a new Sense Glove has been detected. </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.OnSenseGloveDetected(SenseGloveCs.IODevice)">
            <summary> Calls the SenseGloveDetected event. </summary>
            <param name="newSenseGlove"></param>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.ClearDevices">
            <summary> Removes all connections from memory such that we can try them all once more. </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.ScanTimer_Elapsed(System.Object,System.Timers.ElapsedEventArgs)">
            <summary> Fires when the ScanTimer has elapsed. </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.CheckDevices">
            <summary> Fired every time during the ScanDelay. Run through all of the steps of detecting IODevices. </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.GetCurrentConnections">
            <summary> Retrieve a list of all communicators currently active within the system </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.GetNewConnections(System.Collections.Generic.List{SenseGloveCs.Communicator})">
            <summary> Get a list of Connections that do not exist in the possibleDevices and detectedDevices lists. </summary>
            <param name="currentConnections"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.FilterMissingConnections(System.Collections.Generic.List{SenseGloveCs.Communicator})">
            <summary> Remove connections in possibleDevices that (no longer) exist in the currentConnections </summary>
            <param name="currentConnections"></param>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.PingConnections(System.Collections.Generic.List{SenseGloveCs.Communicator}@)">
            <summary> Attemp to connect to a list of Communicators. If no connection is made, the connection is disposed of and removed. </summary>
            <param name="connectionsToPing"></param>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.CheckResponses">
            <summary> Check the possibleConnections for any responses. If no response is given, disconnect it. </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.ProcessValidDevice(SenseGloveCs.Communicator@)">
            <summary> Knowing that validConnection has given a proper ID response; add it to our list. </summary>
            <param name="validConnection"></param>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.CheckDeviceEvents">
            <summary> Check the instance's detectedDevices. If their data is loaded, fire a DataLoaded event. </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.AddDevice(SenseGloveCs.IODevice)">
            <summary> Add a new device to the detectedDevices list, then fire the event(s)/ </summary>
            <param name="newDevice"></param>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.ContainsAddress(SenseGloveCs.Communicator,System.Collections.Generic.List{SenseGloveCs.Communicator})">
            <summary> Check if this communicator's address is already present in a list </summary>
            <param name="toCheck"></param>
            <param name="communicators"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.ContainsAddress(SenseGloveCs.Communicator,System.Collections.Generic.List{SenseGloveCs.IODevice})">
            <summary> Check if this communicator's address is already present in a list of devies </summary>
            <param name="toCheck"></param>
            <param name="devices"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.DeviceIndex(SenseGloveCs.Communicator,System.Collections.Generic.List{SenseGloveCs.IODevice})">
            <summary> Check if this Communicator is connected to one of the devices. </summary>
            <param name="connection"></param>
            <param name="devices"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.CreateDevice(SenseGloveCs.Communicator)">
            <summary> Create a new IODevice, based on an existing connection. Returns null if the device type is not implemented. </summary>
            <param name="newConnection"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.StartScanning(System.Single)">
            <summary> Begin Scanning for devices. </summary>
            <remarks> As per the C# static variable rules, The DeviceScanner instance is not initialized untill it is accessed the first time. 
            Calling this method will ensure our Singleton is created. </remarks>
            <param name="dotNetVer"> The .Net version of your environment, used for older communications. Unity runs on .Net 2.0. </param>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.StopScanning">
            <summary> Stops using resources to scan, but does not dispose of them. Use the CleanUp Method to remove all resources instead. </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.CleanUp">
            <summary> Explicitly Dispose of the DeviceScanner Resources. </summary>
            <remarks> Used in engines where destructors are not called, like Unity. </remarks>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.Finalize">
            <summary> Finalizer </summary>
        </member>
        <member name="M:SenseGloveCs.DeviceScanner.Dispose">
            <summary> Manualy dispose of the class' resources. </summary>
        </member>
        <member name="T:SenseGloveCs.DeviceType">
            <summary> DeviceTypes supported by this DLL, used to selectively scan for devices, and create the appropriate subclass. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceType.SenseGlove">
            <summary> A glove used to calculate the joint angles of the fingers, thumb and wrist. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceType.ReMinder">
            <summary> An IMU suit to determine the position(s) of a human model. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceType.SimpleSenseGlove">
            <summary> A version of the Sense Glove that uses IMUs instead of flex sensors. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceType.SenseArm">
            <summary> An exoskeleton that can provide force feedback to the gross movement of the arm. </summary>
        </member>
        <member name="F:SenseGloveCs.DeviceType.Unknown">
            <summary> Indicated a device type that is not recognized or supported by the DLL. </summary>
        </member>
        <member name="T:SenseGloveCs.IODevice">
            <summary>
            An Adjuvo Sense device that can be used as input.
            </summary>
        </member>
        <member name="F:SenseGloveCs.IODevice.communicator">
            <summary>
            Used to send and receive data from the microcontroller.
            </summary>
        </member>
        <member name="M:SenseGloveCs.IODevice.Finalize">
            <summary> Ensure a disconnect upon GC </summary>
        </member>
        <member name="M:SenseGloveCs.IODevice.IsConnected">
            <summary>
            Check if this IODevice is (still) connected to its communicator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.IODevice.DeviceID">
            <summary> Retrieve the device's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.IODevice.Connect">
            <summary>
            Connect to the existing communicator of this IODevice.
            </summary>
        </member>
        <member name="M:SenseGloveCs.IODevice.Disconnect">
            <summary>
            Disconnect from the communicator of this IODevice, cleaning up its resources.
            </summary>
        </member>
        <member name="M:SenseGloveCs.IODevice.Disconnect(SenseGloveCs.Diagnostics.ExitCodes)">
            <summary> Disconnect the device's communicator with a specific exitCode. </summary>
            <param name="exitCode"></param>
        </member>
        <member name="M:SenseGloveCs.IODevice.ReConnect(SenseGloveCs.Communicator)">
            <summary> Reconnect the IODevice to a (different) Communicator, but only after we have verified that it is the same device! [DeviceScanner]  </summary>
            <param name="source"></param>
        </member>
        <member name="M:SenseGloveCs.IODevice.SameDeviceType(SenseGloveCs.IODevice)">
            <summary> Theck if this IODevice has the same (subclass of) DeviceType as another IODevice. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.IODevice.GetDeviceType(System.String)">
            <summary> Based on the deviceType field from an ID respose, determine which device type this is. </summary>
            <param name="typeIndicator"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.IODevice.IsReady">
            <summary> Check if this IODevice has recieved its Constants and is ready to parse </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.IODevice.ProcessCommand(System.Object,SenseGloveCs.CMDEventArgs)">
            <summary> When a command or response comes in from the communicator, call the appropriate function(s). </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="M:SenseGloveCs.IODevice.ParseConstants(System.String)">
            <summary> Load constants from a string recieved by the IODevice </summary>
            <param name="C"></param>
        </member>
        <member name="M:SenseGloveCs.IODevice.ParseMetaData(System.String)">
            <summary> Load metadata from a string recieved by the IODevice </summary>
            <param name="M"></param>
        </member>
        <member name="T:SenseGloveCs.GloveFunctions">
            <summary> All available Sense Glove functions. </summary>
            <remarks> Used to access Glove Functionalies. </remarks>
        </member>
        <member name="F:SenseGloveCs.GloveFunctions.BuzzMotors">
            <summary> Vibration Motors to send haptic pulses to individual fingers  </summary>
        </member>
        <member name="F:SenseGloveCs.GloveFunctions.Brakes">
            <summary> Brakes which can inhibit grasping motions to create force feedback. </summary>
        </member>
        <member name="F:SenseGloveCs.GloveFunctions.ThumperModule">
            <summary> A vibration module inside the wrist hub that can play a number of effects using the DRV library. </summary>
        </member>
        <member name="F:SenseGloveCs.GloveFunctions.All">
            <summary> Utility value used for enumeration. It can also be used to check if a Sense Glove has all functionalities. </summary>
        </member>
        <member name="T:SenseGloveCs.ThumperEffect">
            <summary> List of effects that can be player using the Thumper Modules on a Sense Glove </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.TurnOff">
            <summary> Turn off the thumper effects. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Cue_Game_Over">
            <summary> A 5-second long, constant vibration. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Button_Double_100">
            <summary> A double-click at 100% intensity. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Button_Double_60">
            <summary> A double click at 60% intensity. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Impact_Thump_100">
            <summary> Simulates an impact of the hand at 100% intensity. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Impact_Thump_30">
            <summary> Simulates an impact of the hand at 30% intensity. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Impact_Thump_10">
            <summary> Simulates an sharp impact of the hand at 40% intensity. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Object_Grasp_100">
            <summary> A light vibration to cue the user that an object it picked up. 100% intensity. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Object_Grasp_60">
            <summary> A light vibration to cue the user that an object it picked up. 60% intensity. </summary>
        </member>
        <member name="F:SenseGloveCs.ThumperEffect.Object_Grasp_30">
            <summary> A light vibration to cue the user that an object it picked up. 30% intensity. </summary>
        </member>
        <member name="T:SenseGloveCs.SenseGlove">
            <summary>
            A Sense Glove
            </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.gloveData">
            <summary> A Data-block containing the variables of this Sense Glove </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.collector">
            <summary> Collects calibration points. </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.solvers">
            <summary> Individual solvers to the Sense Glove  </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.functionDebug">
            <summary> Debug variable that reports when a Sense Glove does not have a specific function -> only once. </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.buzzCommands">
            <summary> Wrappers to keep track of when a buzzMotorCommand ends. </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.lastBuzzCmds">
            <summary> The last sent buzzCommands, sent with brakeCommands if they are not sent together </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.lastBrakeCmds">
            <summary> the last sent brakeCommand, sent with buzzCommands if they are not sent together </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.buzz_update_time">
            <summary> Teh time [ms] that the buzzMotor commands are updated. </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.buzzCmdThread">
            <summary> Ensures the buzzCommands are updated at least every x seconds. </summary>
        </member>
        <member name="F:SenseGloveCs.SenseGlove.gettingCommands">
            <summary> a semaphore command. </summary>
        </member>
        <member name="T:SenseGloveCs.SenseGlove.FingerCalibrationFinishedEventHandler">
            <summary> Delegate function implemented by subscribers to the OnFingerCalibrationFinished event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SenseGloveCs.SenseGlove.OnFingerCalibrationFinished">
            <summary> Fires when the new finger lengths and joint positions are calculated. </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.FingerCalibrationFinished(SenseGloveCs.CalibrationArgs)">
            <summary>  Used to call the OnFingerCalibrationFinished event in all subscribers. </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.ProcessCommand(System.Object,SenseGloveCs.CMDEventArgs)">
            <summary>
            Extended to include a "calibrate wrist" command.
            </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.#ctor">
            <summary>
            Create a SenseGlove without a Communicator.
            </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.#ctor(SenseGloveCs.Communicator)">
            <summary>
            Create a new SenseGlove from a Communicator
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.Finalize">
            <summary>
            SenseGlove Destructor.
            </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SetupSolvers">
            <summary> Setup the solvers for this Sense Glove, that can be altered later by calibration or constants. </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.Disconnect">
            <summary> Manually disconnect this SenseGlove. </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.ParseConstants(System.String)">
            <summary> Parse constants coming from a communicator </summary>
            <param name="C"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.ParseMetaData(System.String)">
            <summary> Parse Metadata coming from a communicator </summary>
            <param name="M"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SetupBuzzMotors">
            <summary> Set up the buzz motor thread and commands. </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.ProcessBuzzCmds(System.Object,System.Timers.ElapsedEventArgs)">
            <summary> Ensure the proper buzzmotor commands are sent.</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SendBuzzMotorCmd(System.Boolean[],System.Int32[],System.Int32[],SenseGloveCs.BuzzMotorPattern[])">
            <summary> Send Buzzmotor patterns, magnitudes and durations to each finger. </summary>
            <param name="fingers"></param>
            <param name="patterns"></param>
            <param name="magnitudes"></param>
            <param name="durations"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.BuzzMotorCmd(System.Boolean[],System.Int32[],System.Int32[],SenseGloveCs.BuzzMotorPattern[])">
            <summary> Send Buzzmotor command with optional patterns, magnitudes and durations to each finger. </summary>
            <param name="fingers"></param>
            <param name="durations"></param>
            <param name="magnitudes"></param>
            <param name="patterns"></param>
            <remarks> More Dev-friendly version of SendBuzzCmd </remarks>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.BuzzMotorCmd(System.Int32[])">
            <summary> The simplest version of a buzzMotor command, that lets one send constant magnitudes directly. </summary>
            <param name="magnitudes"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.BuzzMotorCmd(System.Boolean[],System.Int32,System.Int32,SenseGloveCs.BuzzMotorPattern)">
            <summary> Send the same buzzmotor command to the chosen fingers. </summary>
            <param name="fingers"></param>
            <param name="duration"></param>
            <param name="magnitude"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.StopBuzzMotors">
            <summary> </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.BrakeCmd(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Send a simple brake-level command to the Communicator.
            </summary>
            <param name="thumbCmd"></param>
            <param name="indexCmd"></param>
            <param name="middleCmd"></param>
            <param name="ringCmd"></param>
            <param name="pinkyCmd"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.BrakeCmd(System.Int32[])">
            <summary>
            Send a simple brake-level command to the Communicator.
            </summary>
            <param name="commands"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.StopBrakes">
            <summary> Stop the SenseGlove from exerting any force feedback. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SendThumperCmd(SenseGloveCs.ThumperEffect)">
            <summary> Send an effect to the Thumper </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SendBrakeBuzz(System.String,System.String)">
            <summary>
            Having recieved a buzz-motor or brake command; send both!
            Automatically assigns the last brake / buzz commands.
            </summary>
            <param name="brakeCmd"></param>
            <param name="buzzCmd"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.StopFeedback">
            <summary> Stop both the buzz motors and the force feedback </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.IsRight">
            <summary>
            Check wether this SenseGlove belongs to a left- or right hand.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.DeviceID">
            <summary> Retrieve the glove's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.IsReady">
            <summary>  </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.HasFunction(SenseGloveCs.GloveFunctions)">
            <summary>
            Check if this senseGlove can activate a specific function. 
            NOTE: It may still be waiting for a response from the MicroController
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.GetFingerLengths">
            <summary>
            Retrieve the FingerLengths of the SenseGlove.
            The array size is 0 if the handModel has not been loaded yet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.GetJointPositions">
            <summary> Retieve the positions of the starting joints (CMC and MCP) </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.GetThimbleComp">
            <summary> Retrieve the thimble compensation [x, y, z], in mm. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.GetData(System.Boolean,SenseGloveCs.Solver)">
            <summary>
            Retrieve a (copy) Data Block from the SenseGlove, which represents a 'snapshot' of its variables.
            </summary>
            <param name="recalculate">One must set recalculate to true at least once per frameUpdate. </param>
            <param name="solveType"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.Update(SenseGloveCs.UpdateLevel,SenseGloveCs.Solver,System.Boolean,System.Boolean,SenseGloveCs.Kinematics.Quat,System.Boolean,System.Boolean)">
            <summary>
            Recalculate specific parts of the SenseGlove, then return its data.
            </summary>
            <param name="upToWhere">  </param>
            <param name="limitFingers">Determine whether to limit the fingers within natural parameters.</param>
            <param name="updateWrist">  </param>
            <param name="qLowerArm">  </param>
            <param name="limitWrist">Determine whether to limit the fingers within natural parameters.</param>
            <param name="checkGestures">  </param>
            <param name="solverType"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.UpdateWrist(SenseGloveCs.Kinematics.Quat,SenseGloveCs.Kinematics.Quat,System.Boolean)">
            <summary> Manually update the wrist model, but not the hand model </summary>
            <param name="imuValues"></param>
            <param name="qLowerArm"></param>
            <param name="limitWrist"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.Update(SenseGloveCs.SG_ClientData,SenseGloveCs.Solver)">
            <summary> Update this Sense Glove using client-data. </summary>
            <param name="clData"></param>
            <param name="solver"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.UpdateCalibrationStats">
            <summary> Update Calibration values in GloveData to match that of the collector (which is not passed ot the user!) </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SetHandLengths(System.Single[][])">
            <summary>
            Set the fingerLengths [x values] of this glove's handModel, for manual Calibration. These lengths will always be > 0
            </summary>
            <param name="phalangeLengths"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SetJointPositions(SenseGloveCs.Kinematics.Vect3D[])">
            <summary> Set the starting joint positions of the thumb and fingers; the CMC and MCP joints. </summary>
            <param name="positions"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SetThimbleComp(SenseGloveCs.Kinematics.Vect3D[])">
            <summary> Set the thimble compensation [x, y, z], in mm. </summary>
            <param name="newComps"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.RestoreHand">
            <summary> > Reset the hand values (joint positions, finger lengths) back to their default values.  </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.ResetSolvers">
            <summary> Resets solver parameters back tto initial values.</summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.CalibrateWrist(SenseGloveCs.Kinematics.Quat,SenseGloveCs.Kinematics.Quat)">
            <summary>
            Calibrate the wrist orientation by setting the ForeArm quaternion as its 0 reference.
            </summary>
            <param name="qWrist"></param>
            <param name="qForeArm"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.ResetCalibration">
            <summary> Reset the Calibration, using the same parameters. </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.StopCalibration">
            <summary> Stop calibration entirely. </summary>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.CalibrationStarted">
            <summary> Check if a Calibration method has already been started. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.AddCalibrationPoint(SenseGloveCs.GloveData)">
            <summary> Adds a point to the collector (either manually or automatically), and checks if the collection is complete </summary>
            <param name="copy"></param>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.StartCalibration(SenseGloveCs.Kinematics.CalibrationAlgorithm,SenseGloveCs.Kinematics.CalibrationCollector)">
            <summary> Start a new Calibration with the chosen Algorithm and collection method. If one is already underway, stop it. </summary>
            <param name="algortihm"></param>
            <param name="collectionMethod"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.StartCalibration(SenseGloveCs.Kinematics.CalibrationAlgorithm,SenseGloveCs.Kinematics.CollectionMethod)">
            <summary> Starts a custom algorithm with a predefined collection method. </summary>
            <param name="algorithm"></param>
            <param name="collectionMethod"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.StartCalibration(SenseGloveCs.Kinematics.CalibrateVariable,SenseGloveCs.Kinematics.CollectionMethod)">
            <summary> Start a new Calibration,  </summary>
            <param name="whatToCalibrate"></param>
            <param name="collectionMethod"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.NextCalibrationStep">
            <summary> Continue to the next Calibration step (Used for manual calibration) </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.StartSemiAutoCalibration(SenseGloveCs.Kinematics.CalibrateVariable,System.Single,System.Single,System.Single)">
            <summary> Start a semi-automatic calibration sequence, to calculate the chosen variable(s). </summary>
            <param name="whatToCalibrate"></param>
            <param name="distinctDistance"></param>
            <param name="steadyTime"></param>
            <param name="steadyDistance"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.GetInterpolationValues">
            <summary> Get a serialized version of our IMU interpolation values(?) </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SenseGlove.SetInterpolationValues(System.String)">
            <summary> Set a serialized version of our IMU Interpolation values(s) </summary>
            <param name="newValues"></param>
        </member>
        <member name="T:SenseGloveCs.SerialCommunicator">
            <summary>
            Arduino / Teensy communication. Also works with the XBee Explorer Module
            </summary>
        </member>
        <member name="F:SenseGloveCs.SerialCommunicator.baudRate">
            <summary> The Baud-Rate of the Serial Port </summary>
        </member>
        <member name="F:SenseGloveCs.SerialCommunicator.dataBts">
            <summary> The Databits of the Serial Port </summary>
        </member>
        <member name="F:SenseGloveCs.SerialCommunicator.par">
            <summary> The Partity Bit of the Serial Port </summary>
        </member>
        <member name="F:SenseGloveCs.SerialCommunicator.stopBts">
            <summary> The number of StopBits of the Serial </summary>
        </member>
        <member name="F:SenseGloveCs.SerialCommunicator.rts">
            <summary> Must be set to true to communicate with Arduino-Like PCBs. </summary>
        </member>
        <member name="F:SenseGloveCs.SerialCommunicator.serialPort">
            <summary> Wrapper for Serial communication so that older versions of .NET can also use it. </summary>
        </member>
        <member name="F:SenseGloveCs.SerialCommunicator.samplesThisSecond">
            <summary> The amount of sensor samples recieved since the last time we've checked. </summary>
            <remarks> This integer is update up to 100x per second, and is copied to the samplesPerSecond variable to avoid locking. </remarks>
        </member>
        <member name="F:SenseGloveCs.SerialCommunicator.sampleTimer">
            <summary> A timer that checks for the amount of samples per second. </summary>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.#ctor(System.String)">
            <summary> Create a new Serial Communication line over the chosen COM Port. </summary>
            <param name="COMport"></param>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.Finalize">
            <summary> Ensure that we disconnect upon release. </summary>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.Address">
            <summary> Retrieve the Address of the Serial Port that this communicator is connected to. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.IsConnected">
            <summary> Check if this Serial Communicator is (still) connected. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.Connect">
            <summary> Connect to the Serial Port resource. </summary>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.Disconnect(SenseGloveCs.Diagnostics.ExitCodes)">
            <summary> Disconnect this SerialPort with the chosen ExitCode. </summary>
            <param name="exitCode"></param>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.SerialPort_Disconnected(System.Object,SenseGloveCs.IO.DisconnectArgs)">
            <summary> Fires when our SerialWrapper closes for any reason. Properly dispose of my resources as well. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.SampleTimer_Elapsed(System.Object,System.Timers.ElapsedEventArgs)">
            <summary> Fires every second to check on the SamplesPerSecond variable. </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.SerialPort_DataRecieved(System.Object,SenseGloveCs.CMDEventArgs)">
            <summary> Fires when the SeriapWrapper recieved new SensorData{ [ ... ] </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.SerialPort_CommandRecieved(System.Object,SenseGloveCs.CMDEventArgs)">
            <summary> Fires whenever the SerialWrapper recieves a Command: { ... } </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.Send2Device(System.String)">
            <summary> Send a string command to the Serial Port </summary>
            <param name="command"></param>
            <returns> Returns true if the command has been succesully sent. </returns>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.Send2Device(System.Char)">
            <summary> Send a single character command to the Serial Port </summary>
            <param name="c"></param>
            <returns>  Returns true if the command has been succesully sent. </returns>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.Send2Device(System.Byte[])">
            <summary> Send a byte array command to the Serial Port  </summary>
            <param name="bytes"></param>
            <returns> Returns true if the command has been succesully sent. </returns>
        </member>
        <member name="M:SenseGloveCs.SerialCommunicator.GetPorts(System.Boolean)">
            <summary> Retrieve a list of serial ports that are connected to this system. </summary>
            <param name="withCorrection">Whether or not to add corrections for older .NET versions. </param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Values">
            <summary>
            Utility class to handle value conversion and limitation
            </summary>
        </member>
        <member name="F:SenseGloveCs.Values.radToDeg">
            <summary> Conversion factor from radians to Degrees </summary>
        </member>
        <member name="F:SenseGloveCs.Values.degToRad">
            <summary> Conversion factor from degrees to radians </summary>
        </member>
        <member name="F:SenseGloveCs.Values.Pi_2">
            <summary> A Math.Pi / 2 float representation. </summary>
        </member>
        <member name="F:SenseGloveCs.Values._2Pi">
            <summary> Math.Pi * 2 float representation. </summary>
        </member>
        <member name="M:SenseGloveCs.Values.ToPolynomal(System.Single,System.Single,System.Single,System.Single)">
            <summary> Convert a linear interpolation to a polynomal notation </summary>
            <param name="x0"></param>
            <param name="x1"></param>
            <param name="y0"></param>
            <param name="y1"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.toFloat(System.String)">
            <summary>
            Convert a string variable into a float, regardless of the culture of the system.
            </summary>
            <param name="s">The string to parse</param>
            <returns>The converted string. If this is impossible, this method will return float.NaN. </returns>
        </member>
        <member name="M:SenseGloveCs.Values.toInt(System.String)">
            <summary>
            Convert a string variable into an int, regardless of the culture of the system.
            </summary>
            <param name="s">The string to parse</param>
            <returns>The converted string. If this is impossible, this method will return -1 </returns>
        </member>
        <member name="M:SenseGloveCs.Values.toLong(System.String)">
            <summary>
            Convert a string variable into a long, regardless of the culture of the system.
            </summary>
            <param name="s">The string to parse</param>
            <returns>The converted string. If this is impossible, this method will return -1 </returns>
        </member>
        <member name="M:SenseGloveCs.Values.Wrap(System.Single,System.Single,System.Single)">
            <summary>
            Limit a value within the domain [minValue, maxValue].
            </summary>
            <param name="value"> The value to limit. </param>
            <param name="minValue"> The lower of the domain. </param>
            /// <param name="maxValue"> The upper limit of the domain. </param>
            <returns>value constrained between minValue and maxValue. </returns>
        </member>
        <member name="M:SenseGloveCs.Values.Degrees(System.Single)">
            <summary>
            Convert an angle in radians to one in degrees.
            </summary>
            <param name="rad"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.Degrees(System.Single[])">
            <summary>
            Convert an array of radian values into degrees.
            </summary>
            <param name="rad"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.Degrees(SenseGloveCs.Kinematics.Vect3D)">
            <summary>
            Convert valies in degrees into radians.
            </summary>
            <param name="rad"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.Radians(System.Single)">
            <summary>
            Convert a values in degrees to one in radians
            </summary>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.Radians(System.Single[])">
            <summary>
            Convert an array of degree values into radians.
            </summary>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.Radians(SenseGloveCs.Kinematics.Vect3D)">
            <summary>
            Convert angles in degrees stored in a Vector3D to radians.
            </summary>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.Radians(System.Int32[])">
            <summary>
            Convert an array of degree values into radians.
            </summary>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.Interpolate(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Approximates the value of y corresponding to x, using linear interpolation
            </summary>
            <param name="x">The value for which to determine y</param>
            <param name="x0">x value of point 0</param>
            <param name="x1">x value of point 1</param>
            <param name="y0">y value of point x0</param>
            <param name="y1">y value of point x1</param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.NormalizeAngle(System.Single)">
            <summary> Scale an angle [in Rad] back to the -Pi ... Pi range, which is better to aplly limits to </summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.NormalizeAngle(System.Single,System.Single,System.Single)">
            <summary>
            Normalize an angle in between two values. If it exceeds either value, it is increased, decreased by 2Pi.
            Used mainly for sensor mapping.
            </summary>
            <param name="angle"></param>
            <param name="minAngle"></param>
            <param name="maxAngle"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.NormalizeAngle(SenseGloveCs.Kinematics.Vect3D)">
            <summary> Normalize a 3D vector. </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Values.NormalizeAngle(System.Single[])">
            <summary> Scale a set of angles [in Rad] back to the -Pi ... Pi range, which is better to aplly limits to </summary>
            <param name="angles"></param>
            <returns></returns>
        </member>
        <member name="T:SenseGloveCs.Wrist">
            <summary>
            Contains the Kinematic Model of the Wrist
            </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.wasLimited">
            <summary> Whether or not the wrist orientation was limited during this calculation. </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.QwristAbs">
            <summary> The absolute orientation of the wrist, corrected with the IMU- and glove orientation  </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.EwristAbs">
            <summary>  The absolute orientation of the wrist, corrected with the IMU- and glove orientation  </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.QforeArm">
            <summary>  The absolute orientation of the lower arm, used to calculate the relative wrist orientation. </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.EforeArm">
            <summary> The absolute orientation of the lower arm, used to calculate the relative wrist orientation. </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.QcalibratedAbs">
            <summary>  The absolute orientation of the wrist, moving relative to the calibration point. </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.Qrelative">
            <summary> The rotation of the wrist, relative to the lower arm. </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.Erelative">
            <summary> The rotation of the wrist, relative to the lower arm. </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.QgloveOrientation">
            <summary> The orientation of the glove on the hand, relative to the wrist </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.QhardwareOrientation">
            <summary>  The orientation of the IMU within the Sense Glove Hardware, used to correct manufacturing faults. </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.Qcompensate">
            <summary> The compensation quaternion to get from the IMU to the absolute wrist orientation. Stored separately to save calculation power during Update(). </summary>
        </member>
        <member name="F:SenseGloveCs.Wrist.QtoReference">
            <summary> The compensation quaternion between the absolute wrist orientation and the forearm. </summary>
        </member>
        <member name="M:SenseGloveCs.Wrist.#ctor">
            <summary>
            Create a new instance of a Wrist Model
            </summary>
        </member>
        <member name="M:SenseGloveCs.Wrist.Update(SenseGloveCs.Kinematics.Quat,System.Boolean)">
            <summary>
            Update the Wrist model.
            </summary>
            <param name="newIMUValues"></param>
            <param name="limitWrist">Determine whether to limit the wrist within natural parameters.</param>
        </member>
        <member name="M:SenseGloveCs.Wrist.Update(SenseGloveCs.Kinematics.Quat,SenseGloveCs.Kinematics.Quat,System.Boolean)">
            <summary>
            Update the Wrist Model, with a new lower arm orientation.
            </summary>
            <param name="newIMUValues"></param>
            <param name="newLowerArm"></param>
            <param name="limitWrist">Determine whether to limit the wrist within natural parameters.</param>
        </member>
        <member name="M:SenseGloveCs.Wrist.SetGloveOrientation(SenseGloveCs.Kinematics.Quat)">
            <summary>
            Set the orientation of the glove on the hand.
            </summary>
            <param name="QGlove"></param>
        </member>
        <member name="M:SenseGloveCs.Wrist.SetHardwareOrientation(SenseGloveCs.Kinematics.Quat)">
            <summary>
            Set the orientation of the IMU within the glove.
            </summary>
            <param name="QHardware"></param>
        </member>
        <member name="M:SenseGloveCs.Wrist.CalculateComp">
            <summary> 
            (Re)calculate the total compensation quaternion to get from the IMU to the absolute wrist orientation. 
            </summary>
        </member>
        <member name="M:SenseGloveCs.Wrist.Calibrate(SenseGloveCs.Kinematics.Quat,SenseGloveCs.Kinematics.Quat)">
            <summary>
            Set the new reference orientation to get from the absolute wrist orientation to the lower arm.
            </summary>
            <param name="wrist"></param>
            <param name="lowerArm"> An optional quaternion which represents the lower arm </param>
        </member>
        <member name="M:SenseGloveCs.Wrist.ParseHardwareCorrection(System.String)">
            <summary> Parse this glove's IMU correction from a raw string. </summary>
            <param name="correctionValues">Given in DEGREES</param>
            <returns></returns>
        </member>
        <member name="M:SenseGloveCs.Wrist.Copy">
            <summary>
            Returns a achallow copy of this wristmodel
            </summary>
            <returns></returns>
        </member>
        <member name="T:SimpleGloveConst">
            <summary> Constants message of a Simple Sense Glove. </summary>
        </member>
        <member name="T:SimpleGloveVars">
            <summary> Variables of the Simple SenseGlove's sensor stream. </summary>
        </member>
    </members>
</doc>
