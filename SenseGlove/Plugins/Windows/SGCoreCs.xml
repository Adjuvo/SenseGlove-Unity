<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SGCoreCs</name>
    </assembly>
    <members>
        <member name="T:SGCore.Kinematics.Anatomy">
            <summary> "Database" of anatomical values, such as joint limits. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.LIMIT_MIN">
            <summary> Index of the minimum value in the array(s) </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.LIMIT_MAX">
            <summary> Index of the maximum value in the array(s) </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.thumbLimits">
            <summary> Hard Coded thumb limits, in radians </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.fingerLimits">
            <summary> Hard Coded finger limits, in radians </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iPronation">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iSupination">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iFlexion">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iExtension">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iAbduction">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iAdduction">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.ClampJointAngle(System.Single,SGCore.Finger,System.Boolean,System.Int32,System.Int32)">
            <summary> Limit a value between specific joint angles. </summary>
            <param name="value"></param>
            <param name="finger"></param>
            <param name="rightHand"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.ClampJointAngle(System.Single,System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary> Limit a value between specific joint angles. </summary>
            <param name="value"></param>
            <param name="finger"></param>
            <param name="rightHand"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetFingerJointLimit(System.Boolean,System.Int32,System.Int32,System.Boolean)">
            <summary> Retrieve one of the limits of a finger joint's movement. </summary>
            <param name="right"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetThumbJointLimit(System.Boolean,System.Int32,System.Int32,System.Boolean)">
            <summary> Retrieve one of the limits of a thumb joint's movement. </summary>
            <param name="right"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.thumbFlexions01">
            <summary> Used for Normalization. Sorted per joint, indices by 0 (normalized =0) and 1 (normalized =1). </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.fingerFlexions01">
            <summary> Used for normalization. Sorted per joint, indices by 0 (normalized =0) and 1 (normalized =1). </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.abductions01_R">
            <summary> used for normalization. Sorted per joint, indices by 0 (normalized =0) and 1 (normalized =1). </summary>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.RecalculateTotals">
            <summary> Recalculates total finger flexions for normalization purposes(?) </summary>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetFlexNormalizers_Finger(System.Single@,System.Single@)">
            <summary> Returns flexion normalizers for the fingers </summary>
            <param name="flex0"></param>
            <param name="flex1"></param>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetFlexNormalizers_Thumb(System.Single@,System.Single@)">
            <summary> Returns flexion normalization for the thumb </summary>
            <param name="flex0"></param>
            <param name="flex1"></param>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetFlexNormalizers(SGCore.Finger,System.Single@,System.Single@)">
            <summary> Generic Entry point.</summary>
            <param name="finger"></param>
            <param name="flex0"></param>
            <param name="flex1"></param>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.NormalizeFingerFlex(System.Single)">
            <summary> Convert a total finger flexion in radians into a 0..1 representation. </summary>
            <param name="totalFlex_Rad"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.NormalizeThumbFlex(System.Single)">
            <summary> Convert a total finger flexion in radians into a 0..1 representation. </summary>
            <param name="totalFlex_Rad"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.NormalizeFlexion(SGCore.Finger,System.Single)">
            <summary> A generic entry point for fingers. </summary>
            <param name="finger"></param>
            <param name="totalFlex_Rad"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.NormalizeAbduction(SGCore.Finger,System.Single,System.Boolean)">
            <summary> Normalize finger abuction of a single finger </summary>
            <param name="finger"></param>
            <param name="totalAbd_Rad"></param>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.FingerFlexion_FromNormalized(System.Single,System.Int32)">
            <summary> Based on a normalized flexion, return a proper flexion angle for a specific finger joint. </summary>
            <param name="normalizedFlexion"> Accepteable values are 0, 1, 2. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.ThumbFlexion_FromNormalized(System.Single,System.Int32)">
            <summary> Based on a normalized flexion, return a proper flexion angle for a specific thumb joint. </summary>
            <param name="normalizedFlexion"></param>
            <param name="joint"> Accepteable values are 0, 1, 2. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.Abduction_FromNormalized(SGCore.Finger,System.Single,System.Boolean)">
            <summary> Convert a normalized abduction back into a radian angle for a specific finger. </summary>
            <param name="finger"></param>
            <param name="normalizedAbduction"></param>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.Flexions_FromNormalized(SGCore.Finger,System.Single)">
            <summary> Calculates the three flexion angles from a normalized angle (value between 0 .. 1. </summary>
            <param name="finger"></param>
            <param name="normalizedFlexion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.FingerAngles_FromNormalized(SGCore.Finger,System.Single,System.Single,System.Boolean)">
            <summary> Returns joint angles for a finger, with a normalized flexion and abduction. </summary>
            <param name="finger"></param>
            <param name="normalizedFlexion"></param>
            <param name="normalizedAbd"></param>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_FromNormalized(System.Boolean,System.Single[],System.Single,System.Single)">
            <summary> Generates a set of HandAngles from normalized finger flexions, thumb abduction and a global finger spread. </summary>
            <param name="isRight"></param>
            <param name="flexions01"></param>
            <param name="thumbAbd01"></param>
            <param name="fingerSpread01"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_Default(System.Boolean)">
            <summary> Get Hand Angles that would make a Default Pose; fingers stretched and thumb abducted by 30 degrees. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_Flat(System.Boolean)">
            <summary> Get Hand Angles that would make a flat hand </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_ThumbsUp(System.Boolean)">
            <summary> Get Hand Angles that would make a thumbs up </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_Fist(System.Boolean)">
            <summary> Get Hand Angles that would make a fist </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetThumbJointName(System.Int32)">
            <summary> Get the name of a thumb joint by the index. </summary>
            <param name="joint"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Kinematics.Anatomy.GetFingerJointName(System.Int32)" -->
        <member name="M:SGCore.Kinematics.Anatomy.GetJointName(SGCore.Finger,System.Int32,System.String)">
            <summary> Get the name of a specific joint_finger combination. </summary>
            <param name="finger"></param>
            <param name="joint"></param>
            <param name="delim">Optional joint delimiter.</param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.BasicHandModel">
            <summary> Represents data of a user's hand required for forward kinematics. </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.FingerLengths">
            <summary> The length of individual finger phalangers in mm, soted per finger. Generally 5x3 </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.StartJointPositions">
            <summary> Starting joint positions relative to the device Origin </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.StartJointRotations">
            <summary> Starting joint rotations relative to the device Origin </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.TotalLengths">
            <summary> Calculated Total finger lengths </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.FingerRatios">
            <summary> Calculated Finger ratios [0..1] </summary>
        </member>
        <member name="F:SGCore.Kinematics.BasicHandModel.baseFingerLengths">
            <summary> Default finger lengths (based on right hand). </summary>
            <remarks> Any missing fingers are replaced with their respective value. </remarks>
        </member>
        <member name="F:SGCore.Kinematics.BasicHandModel.baseJointPositions">
            <summary> Default joint positions (based on right hand). </summary>
            <remarks> Any missing positions are replaced with their respective value. </remarks>
        </member>
        <member name="F:SGCore.Kinematics.BasicHandModel.baseJointRotations">
            <summary> Default joint rotations (based on right hand). </summary>
            <remarks> Any missing rotation are replaced with their respective value. </remarks>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.#ctor(System.Boolean,System.Single[][],SGCore.Kinematics.Vect3D[])">
            <summary> Create a new basicHandModel with no starting rotations. </summary>
            <param name="right">If this is a right hand (used in validation)</param>
            <param name="lengths"></param>
            <param name="startPositions"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.#ctor(System.Boolean,System.Single[][],SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Quat[])">
            <summary> Create a new basicHandModel </summary>
            <param name="right">If this is a right hand (used in validation)</param>
            <param name="lengths"></param>
            <param name="startPositions"></param>
            <param name="startRotations"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Default(System.Boolean)">
            <summary> Retrieve a default left or right hand model. </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Validate">
            <summary> Test if the input has enough values. if not, add the appropriate values to compensate. </summary>
            <param name="right"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.GetFingerLengths(SGCore.Finger)">
            <summary> Retrieve the finger lengths of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.SetFingerLengths(System.Single[],SGCore.Finger)">
            <summary> Set the finger lengths of a specific finger. </summary>
            <param name="newLengths"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.GetJointPosition(SGCore.Finger)">
            <summary> Retrieve the start position of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.SetJointPosition(SGCore.Kinematics.Vect3D,SGCore.Finger)">
            <summary> Set the start position of a specific finger </summary>
            <param name="newPosition"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.GetJointRotation(SGCore.Finger)">
            <summary> Retrieve the start rotation of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.SetJointRotation(SGCore.Kinematics.Quat,SGCore.Finger)">
            <summary> Set the start rotation of a specific finger </summary>
            <param name="newRotation"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Get3DLengths(SGCore.Finger)">
            <summary> Retrieve the lengths of a specific finger, as Vect3D representation (L, 0, 0). </summary>
            <remarks> Used for forwards kinematics. </remarks>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.ToString">
            <summary> ToString notation using only  </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Equals(SGCore.Kinematics.BasicHandModel)">
            <summary> Check if one HandModel equals another in geometry. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Serialize">
            <summary> Convert this BasicHandModel into a string representation </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Deserialize(System.String)">
            <summary> Convert a string representation of a BasicHandModel back to a useable class. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.ThumbMovement">
            <summary> Anatomical movements of the thumb joints. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_CMC_Twist">
            <summary> Pronation/Supination of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_CMC_Flex">
            <summary> Flexion of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_CMC_Abd">
            <summary> Abduction of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_MCP_Flex">
            <summary> Flexion of the second thumb joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_IP_Flex">
            <summary> Flexion of the third thumb joint. </summary>
        </member>
        <member name="T:SGCore.Kinematics.FingerMovement">
            <summary> Anatomical movements of the finger joints. </summary>
        </member>
        <member name="F:SGCore.Kinematics.FingerMovement.F_MCP_Flex">
            <summary> Flexion of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.FingerMovement.F_MCP_Abd">
            <summary> Abduction of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.FingerMovement.F_PIP_Flex">
            <summary> Flexion of the second finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.FingerMovement.F_DIP_Flex">
            <summary> Flexion of the third finger joint. </summary>
        </member>
        <member name="T:SGCore.Kinematics.HandInterpolator">
            <summary> Contains interpolation sets of all joint movements that can be caluclated into a handPose. </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Thumb_CMC_Abduction">
            <summary> Controls interpolation of thumb CMC Abduction (HandAngles[0][0].z) </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Thumb_CMC_Twist">
            <summary> Controls interpolation of thumb CMC Twist (HandAngles[0][0].x) </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Thumb_CMC_Flexion">
            <summary> Controls interpolation of thumb CMC Flexion (HandAngles[0][0].y) </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Thumb_MCP_Flexion">
            <summary> Controls interpolation of thumb MCP Flexion (y) </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Thumb_IP_Flexion">
            <summary> Controls interpolation of thumb IP Flexion (y) </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Finger_MCP_Abduction">
            <summary> Controls interpolation of finger MCP Abduction (HandAngles[f][0].z) </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Finger_MCP_Flexion">
            <summary> Controls interpolation of finger MCP Flexion (HandAngles[f][0].y) </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Finger_PIP_Flexion">
            <summary> Controls interpolation of finger PIP Flexion (HandAngles[f][1].y) </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.Finger_DIP_Flexion">
            <summary> Controls interpolation of finger DIP Flexion (HandAngles[f][2].y) </summary>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.#ctor(System.Boolean)">
            <summary> Create a new instance of a Hand Interpolator, for either a right hand (true) or a left hand (false). </summary>
            <param name="rightHand"></param>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.CalculateAngle(SGCore.Kinematics.FingerMovement,System.Single,System.Boolean)">
            <summary> Calculate a finger movement's rotation, using an input value. </summary>
            <param name="movement"></param>
            <param name="value"></param>
            /// <param name="applyLimits"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.CalculateAngle(SGCore.Kinematics.ThumbMovement,System.Single,System.Boolean)">
            <summary> Calculate a thumb movement's rotation, using an input value. </summary>
            <param name="movement"></param>
            <param name="value"></param>
            <param name="applyLimits"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.Equals(SGCore.Kinematics.HandInterpolator)">
            <summary> Check if this handInterpolator matches another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.InterpolateHandAngles(System.Single[][],System.Single[],System.Single)">
            <summary> flexions should be 5x3, abduction length = 5 </summary>
            <param name="flexions"></param>
            <param name="abductions"></param>
            <param name="cmcTwist"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.Serialize">
            <summary> Serialize this HandInterpolator into a string representation. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.Deserialize(System.String,System.Boolean)">
            <summary> Convert a serialized HandInterpolator back into a class representation. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.InterpolationSet">
            <summary> Set of variables to map a value from one range to the next. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.x0">
            <summary> First value of input range.</summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.x1">
            <summary> Second value of input range. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.y0">
            <summary> First value of output range. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.y1">
            <summary> Second value of output range. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.min">
            <summary> Minumum range of the output value. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.max">
            <summary> Maximum range of the output value. </summary>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.#ctor">
            <summary> Creates a basic interpolation set, without limits. </summary>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new interpolation set without limits. </summary>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new interpolation set with limits. </summary>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.#ctor(SGCore.Kinematics.InterpolationSet)">
            <summary> Create a new InterpolationSet with the same values as another. </summary>
            <param name="toCopy"></param>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.Get(System.Single,System.Boolean,System.Boolean)">
            <summary> Calculate an output value in range [x0...x1] to [y0..y1] </summary>
            <param name="value"> The input value to map to range [y0...y1] </param>
            <param name="limit"> Set to true to limit the value between [min...max] </param>
            <param name="normalizeAngle"> If this value is true, the output is limited between [-Pi, Pi]. </param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.JointKinematics">
            <summary> Class to calculate Sense Glove kinematics. </summary>
        </member>
        <member name="M:SGCore.Kinematics.JointKinematics.ForwardKinematics(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[]@,SGCore.Kinematics.Quat[]@)">
            <summary> 
            Perform foward Kinematics on a set of joints, defined by a start position- and rotation, 
            joint angles and the lenghts in between. Outputs the calculated positions and rotations.
            </summary>
            <param name="startPosition"></param>
            <param name="startRotation"></param>
            <param name="jointLengths"></param>
            <param name="jointAngles"></param>
            <param name="newPositions"></param>
            <param name="newRotations"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.JointKinematics.ForwardKinematics(SGCore.Kinematics.BasicHandModel,SGCore.Finger,SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[]@,SGCore.Kinematics.Quat[]@)">
            <summary> Calculate positions and rotations of a finger based on input angles and profile. </summary>
            <param name="profile"></param>
            <param name="finger"></param>
            <param name="jointAngles"></param>
            <param name="newPositions"></param>
            <param name="newRotations"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.JointKinematics.GetBestFinger(SGCore.Kinematics.Vect3D[],SGCore.Finger@,SGCore.Kinematics.Vect3D@)">
            <summary> Get the closest finger to the thumb? </summary>
            <param name="tipPositions"></param>
            <param name="bestFinger"></param>
            <param name="offset"></param>
        </member>
        <member name="T:SGCore.Kinematics.Quat">
            <summary> A rotation in 3D space that can be applied to a 3D vector or converted into Euler Angles. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.x">
            <summary> Quaternion element. Not directly related to a rotation or position. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.y">
            <summary> Quaternion element. Not directly related to a rotation or position. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.z">
            <summary> Quaternion element. Not directly related to a rotation or position. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.w">
            <summary> Quaternion element. Not directly related to a rotation or position. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.identity">
            <summary> Represents 'no rotation' in quaternion space. </summary>
        </member>
        <member name="M:SGCore.Kinematics.Quat.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new Quaternion rotation. </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="w"></param>
        </member>
        <member name="M:SGCore.Kinematics.Quat.#ctor(SGCore.Kinematics.Quat)">
            <summary> Copy this Quat's values into another </summary>
            <param name="quatToCopy"></param>
        </member>
        <member name="M:SGCore.Kinematics.Quat.FromEuler(System.Single,System.Single,System.Single)">
            <summary> Create a new Quaternion from an euler angle representation. </summary>
            <param name="xAngle"></param>
            <param name="yAngle"></param>
            <param name="zAngle"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.FromEuler(SGCore.Kinematics.Vect3D)">
            <summary> Create a new Quaternion from an euler angle representation. </summary>
            <param name="euler"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.FromAngleAxis(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new Quaternion Rotation from an angle-axis representation. </summary>
            <param name="angle"></param>
            <param name="axisX"></param>
            <param name="axisY"></param>
            <param name="axisZ"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.FromAngleAxis(System.Single,SGCore.Kinematics.Vect3D)">
            <summary> Create a new Quaternion Rotation from an angle-axis representation. </summary>
            <param name="angle"></param>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.ToString">
            <summary> Create a string representation of the Quaternion rotation. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.ToDeclaration">
            <summary> Creates a string to create this Quat in code. Useful for replicating test cases. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.ToEuler">
            <summary> Retrieve this Quaternion's euler angle notation. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Rotate(SGCore.Kinematics.Vect3D)">
            <summary> Rotate myVect by this quaternion rotation. </summary>
            <param name="v">The vector to rotate by</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Equals(SGCore.Kinematics.Quat,System.Single)">
            <summary> Check if two quaternions have equal values. </summary>
            <param name="that"></param>
            <param name="acceptableOffset"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.GetHashCode">
            <summary> Returns the hash code for this instance. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.IsIdentity">
            <summary> Check if this Quaternion is the identity quaternion (meaning it does not rotate anything.) </summary>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Magnitude">
            <summary> Returns the magnitude of this Quaternion. Used in normalization. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Normalized">
            <summary> Returns a unit length version of this quaternion. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.LookRotation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary>Calculate the Quat that, when applied to the "forward" axis and "up axis", results in the input vectors." In Unity notation, "forward" is Z, and "up" is Y. </summary>
            <param name="forward"></param>
            <param name="up"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.LookRotation_XYZ(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary>  Calculate the Quaternion that, when applied to (1, 0, 0), (0, 1, 0) and (0, 0, 1) will result in teh vectors X, Y, Z. </summary>
            <param name="X">In Orignal function - Side, calculated from Cross Up(input)-FWD, Unity (2D) Left/Right</param>
            <param name="Y">In Orignal function - UP, re-calculated from Cross SIDE-FWD, Unity (2D) Up/Down</param>
            <param name="Z">In Orignal function - Forward, Unity Z (towards screen)</param>
            <remarks> Based on the implementation at https://gist.github.com/aeroson/043001ca12fe29ee911e or https://answers.unity.com/questions/467614/what-is-the-source-code-of-quaternionlookrotation.html, 
            refactored somewhat to make it more readable, and added comments that reflect my own hand solved variables based on the sources from Quat.Rotate. </remarks>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Invert(SGCore.Kinematics.Quat)">
            <summary> Returns the inverse if q (a.k.a. a rotation in the other direction) </summary>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Normalize(SGCore.Kinematics.Quat)">
            <summary> Normalizes a quaternion to have a lenght of 1. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.op_Multiply(SGCore.Kinematics.Quat,SGCore.Kinematics.Quat)">
            <summary> Multiply one quaternion with another one. By order of operations, the q2 is rotated before q1. </summary>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.op_Multiply(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat)">
            <summary> Multiply this quaternion with a Vect3, a.k.a. rotate it. </summary>
            <param name="that"></param>
            <param name="q1"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.AbsErrorSum(SGCore.Kinematics.Quat,SGCore.Kinematics.Quat)">
            <summary> Returns the sum of the abs errors between each quaternion element. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.CalculateDifferences(SGCore.Kinematics.Quat[],SGCore.Kinematics.Quat[])">
            <summary> "subtract" q2  from q1 </summary>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.ToEuler(SGCore.Kinematics.Quat[])">
            <summary> Convert an array of Quat s to an array of Vect3D s. </summary>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Serialize(System.Char)">
            <summary> Serialize this quaternion with a delimiter. </summary>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Deserialize(System.String,SGCore.Kinematics.Quat@,System.Char)">
            <summary> Parse a Quaternion from a string. </summary>
            <param name="str"></param>
            <param name="result"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.Values">
            <summary> Utility class to convert values into various formats. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Values.Rad2Deg">
            <summary> Converts radians into degrees </summary>
        </member>
        <member name="F:SGCore.Kinematics.Values.Deg2Rad">
            <summary> Converts degrees into radians </summary>
        </member>
        <member name="F:SGCore.Kinematics.Values._2PI">
            <summary> 2*PI is used frequently in angle normalization </summary>
        </member>
        <member name="F:SGCore.Kinematics.Values.defaultFloatOffset">
            <summary> Offset between floating points. </summary>
        </member>
        <member name="M:SGCore.Kinematics.Values.Radians(SGCore.Kinematics.Vect3D)">
            <summary> Convert a vector of degrees angles into radians. </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Degrees(SGCore.Kinematics.Vect3D)">
            <summary> Convert a vector of radian angles into degrees. </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Degrees(SGCore.Kinematics.Vect3D[])">
            <summary> Convert and array of values from radians into degrees. </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Degrees(SGCore.Kinematics.Vect3D[][])">
            <summary> Convert and array of values from radians into degrees. </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.NormalizeAngle(System.Single)">
            <summary> Ensure that a single angle is within the [-Pi...Pi] range. </summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.NormalizeAngle(System.Single,System.Single,System.Single)">
            <summary> Normalize and angle between a variable range. </summary>
            <param name="angle"></param>
            <param name="minAngle"></param>
            <param name="maxAngle"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.NormalizeAngles(SGCore.Kinematics.Vect3D)">
            <summary> Normalize a set of angles in radians. </summary>
            <param name="angles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Clamp(System.Single,System.Single,System.Single)">
            <summary> Ensure that a value remains within the [min...max] range. </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary> Ensure that an integer value remains within the [min...max] range. </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Map(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Map a value from one range [from1...from2] to another range [to1 .. to2] </summary>
            <param name="value"></param>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Map(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary> Clamp the values beween the input and output values. </summary>
            <param name="value"></param>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
            <param name="clampOutput"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Map(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Map a value from one range [from1...from2] to another range [to1 .. to2],
            while ensuring it stays within the [min...max] range. </summary>
            <param name="value"></param>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateVectors(System.Single,System.Single,System.Single,SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][],System.Boolean)">
            <summary> Interpolate a 2D array of Vectors </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateVectors(System.Single,System.Single,System.Single,SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[],System.Boolean)">
            <summary> Interpolate an array of Vectors </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateVector(System.Single,System.Single,System.Single,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D,System.Boolean)">
            <summary> Interpolate a single Vector </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateQuaternion(System.Single,System.Single,System.Single,SGCore.Kinematics.Quat,SGCore.Kinematics.Quat,System.Boolean)">
            <summary> Interpolate a Quaternion Rotaion </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="q0"></param>
            <param name="q1"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateHandAngles_WithJointAngles(System.Single,System.Single,System.Single,SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][],System.Boolean,System.Boolean)">
            <summary> Allows up to pass clamping, but still takes into account the joint angle limits. </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="rightHand"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.FillZero(System.Int32)">
            <summary> Returns an array of Vect3D's, all at 0, 0, 0. Used for quick generation and to avoid NullRefs </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.FillZero(System.Int32,System.Int32)">
            <summary> Returns a 2D of Vect3D's [Length, Width] all at 0, 0, 0. Used for quick generation and to avoid NullRefs </summary>
            <param name="length"></param>
            <param name="width"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.AbsErrorSum(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[])">
            <summary> Returns the sum of the absoulte difference between all elements of two vector arrays. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.AbsErrorSum(SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][])">
            <summary>  Returns the sum of the absoulte difference between all elements of two vector arrays. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.ArrayCopy``1(``0[])">
            <summary> Deep copy an array of items, provided they are a primitive type (not a class). </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Evalue_SmoothHill(System.Single)">
            <summary> Evaluate x on a curve with points [0.0, 0.0], [0.5, 1.0], [1.0, 0.0] with a smooth transition. Is 0 elsewhere. </summary>
            <param name="x"></param>
        </member>
        <member name="T:SGCore.Kinematics.Vect3D">
            <summary> Represents a vector with x,y,z coordinates. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Vect3D.x">
            <summary> X coordinate. Pronation/Supination for rotations. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Vect3D.y">
            <summary> Y coordinate. Flexion/Extension for rotations. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Vect3D.z">
            <summary> Z coordinate. Abduction/Adduction for rotations. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Vect3D.zero">
            <summary> Represents a vector with coordinates (0, 0, 0). </summary>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.#ctor(System.Single,System.Single,System.Single)">
            <summary> Create a new Vect3D </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Z"></param>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.#ctor(SGCore.Kinematics.Vect3D)">
            <summary> Copy a vector's values into a new instace </summary>
            <param name="vectorToCopy"></param>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Magnitude">
            <summary> Calculate the magnitude or 'length' of this Vector </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Normalized">
            <summary> Returns this vector normalized to have a Magnitude on 1. </summary>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Scale(System.Single)">
            <summary> Scale all elements of this vector by a certain factor. </summary>
            <param name="s"></param>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.DistTo(SGCore.Kinematics.Vect3D)">
            <summary> Calculate the distance between this Vector and another one. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Equals(SGCore.Kinematics.Vect3D,System.Single)">
            <summary> Check if this Vector is roughly equal to another. </summary>
            <param name="that"></param>
            <param name="acceptableOffset"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.ToString">
            <summary> Create a string representation of this Vector. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.DotProduct(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Calculate the dot product between two vectors. If they're at 90 degree angles, the DP is 0. </summary>
            <param name="a"></param>
            <param name="b"></param>  
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.CrossProduct(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Caluculate the Croos product between two vectors. THe result is an orthagonal vector. </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.AngleBetween(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary>   </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.op_Addition(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Add two vectors together. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.op_Subtraction(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Subtract two vectors from each other. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.op_Multiply(System.Single,SGCore.Kinematics.Vect3D)">
            <summary> Scale the vector v by factor S. </summary>
            <param name="S"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.op_Multiply(SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D)">
            <summary> Rotates a vector by a quaternion rotation. </summary>
            <param name="q"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.AbsErrorSum(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Calculates the difference between two vectors, and sums their (abs) differences. Useful if you want to know your error </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Add(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[])">
            <summary> Add v2 to v2 (v = v1 + v2) </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Subtract(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[])">
            <summary> Subtract v2 from v1. (v = v1 - v2) </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Subtract(SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][])">
            <summary> Subtract all corresponding vector elements from one another. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Scale(SGCore.Kinematics.Vect3D[],System.Single)">
            <summary> Scale an array of Vectors by a global magnitude. </summary>
            <param name="v"></param>
            <param name="globalScale"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Deserialize(System.String,SGCore.Kinematics.Vect3D@,System.Char)">
            <summary> Create a Vect3D from a string representation. </summary>
            <param name="str"></param>
            <param name="result"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Serialize(System.Char)">
            <summary> Serialize this vector to store it on disk. </summary>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.BetaDevice">
            <summary> A Sense Glove device that is not yet added to the API. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.cString">
            <summary> The constants string retrieved when the device is first connected. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.deviceID">
            <summary> The deviceID of this Beta Device. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.hwVersion">
            <summary> The hardware (sub) version of this Beta Device. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.fwVersionMain">
            <summary> The firmware version of the Beta Device. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.fwVersionSub">
            <summary> The firmware version of the Beta Device. </summary>
        </member>
        <member name="M:SGCore.BetaDevice.#ctor(System.String,System.String,System.String,System.String)">
            <summary> Creates a new instance of a Beta Device. </summary>
        </member>
        <member name="M:SGCore.BetaDevice.GetDeviceID">
            <summary> Retrieve this device's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetDeviceType">
            <summary> Retrieve the DeviceType of this SGDevice. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetHardwareVersion">
            <summary> Retrieve this device's hardware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetFirmwareVersion">
            <summary> Retireve this device's firmware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetSubFirmwareVersion">
            <summary>  Retireve this device's sub/minor firmware version </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetConstantsString">
            <summary> Retrieve the Constants string for additional processing. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetSensorData">
            <summary> Retrieve a raw sensor string from this Beta Device. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetLastCmd">
            <summary> Retireve a the last command retrieved from this Beta Device. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.SendCmd(System.String)">
            <summary> Send a raw string command to this device. </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.SendHaptics(System.String,System.Int32)">
            <summary> Send a command over the Haptics Track to the Beta device. </summary>
            <param name="haptics"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetHapticChannelInfo">
            <summary> Retrieve data class containign information about this device's haptic channels. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.ToString">
            <summary> Retrieve a string representation of this BetaDevice. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetBetaDevices">
            <summary> Returns a link to all connected Beta Devices. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetBetaDevice(SGCore.BetaDevice@)">
            <summary> Returns a reference to the very first Beta Device that is connected to the system. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetBetaDevice_ById(System.String,SGCore.BetaDevice@)">
            <summary> Returns true if a reference to a Beta Device that has the same DeviceID as the deviceID parameter could be found. </summary>
            <param name="deviceID"></param>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetBetaDevice_ByHwType(System.String,SGCore.BetaDevice@)">
            <summary> Returns true if a reference to a Beta Device that has the same hardware version as the hardwareVer parameter could be found. </summary>
            <param name="hardwareVer"></param>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.Parse(System.String)">
            <summary> Parse a Beta Device from a cString. </summary>
            <param name="cString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.ConnectionStatus">
            <summary> Indictaes the status of a connection within the SGConnect library. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.Address">
            <summary> The Connection's COM or MAC address. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.ConnectionType">
            <summary> The type of connection this address is using. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.IsConnected">
            <summary> Whether or not this connection is active. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.LastConnectionCode">
            <summary> The latest Connection code. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.LastExitCode">
            <summary> The last exit code </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.LastTestState">
            <summary> The latest testing stage, in case this isn't a SenseGlove Device </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.DeviceType">
            <summary> The DeviceType connected to this port. </summary>
        </member>
        <member name="F:SGCore.Util.ConnectionStatus.connDelimm">
            <summary> Used in parsing. </summary>
        </member>
        <member name="M:SGCore.Util.ConnectionStatus.#ctor(System.String,System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Create a new ConnectionStstus </summary>
            <param name="address"></param>
            <param name="connType"></param>
            <param name="connected"></param>
            <param name="connCode"></param>
            <param name="exitCode"></param>
            <param name="testStage"></param>
            <param name="devType"></param>
        </member>
        <member name="M:SGCore.Util.ConnectionStatus.ToString">
            <summary> A reportable string. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.ConnectionStatus.Parse(System.String)">
            <summary> Parse a ConnectionStatus into a proper data class. </summary>
            <param name="single"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.FileIO">
            <summary> Ensures that .txt files are properly handled by Unity. </summary>
        </member>
        <member name="M:SGCore.Util.FileIO.SaveTxtFile(System.String,System.String,System.String[],System.Boolean)">
            <summary> Attempt to save a string[] to a filename within a desired directory. Returns true if succesful. </summary>
            <remarks> Directory is added as a separate variable so we can more easily check for its existence. </remarks>
            <param name="dir"></param>
            <param name="fileName"></param>
            <param name="lines"></param>
            <param name="append"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.ReadTxtFile(System.String,System.String[]@)">
            <summary> Attempt to read all lines from a file and place them in the string[]. Returns true if succesful. If unable to open the file, the string[] will be empty.</summary>
            <param name="path"></param>
            <param name="lines"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.CreateDirectory(System.String)">
            <summary> Creates a new directory. Returns  false if it already existed. </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.GetMyDocumentsPath">
            <summary> Get the Path ot MyDocuments for Profiles </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.GetSenseGloveFileDirectory">
            <summary> Get the path for commonly accessed files, such as profiles </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.GetSenseGloveCacheDirectory">
            <summary> Get the path for special SenseGlove Log locations and .ini files... </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.OnDiskCalibration">
            <summary> Manages calibration data stored on disk. One for left, another for right. We'll assume your user will use no more than 2 gloves at a time. </summary>
        </member>
        <member name="P:SGCore.Util.OnDiskCalibration.Device">
            <summary> The DeviceType for which it was made. </summary>
        </member>
        <member name="P:SGCore.Util.OnDiskCalibration.LibVersion">
            <summary> Version of SGCore this was build with (also which language? That should not matter, actually). </summary>
        </member>
        <member name="P:SGCore.Util.OnDiskCalibration.SerializedProfile">
            <summary> Raw Dtaa  </summary>
        </member>
        <member name="M:SGCore.Util.OnDiskCalibration.StoreProfile(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Store a single (serialized) profile, both digitally and on disk. </summary>
            <param name="rightHand"></param>
            <param name="type"></param>
            <param name="serialized"></param>
        </member>
        <member name="M:SGCore.Util.OnDiskCalibration.TryLoadingProfiles">
            <summary> Attemping to load the profile data from disk. </summary>
        </member>
        <member name="M:SGCore.Util.OnDiskCalibration.ResetProfiles">
            <summary> Resets the profile(s) and clears them from memory. Mostly called by SenseCom when it shuts down. </summary>
        </member>
        <member name="T:SGCore.Util.SensorNormalization">
            <summary> A script to normalize any set of floating point values by looking at their minimum and maximum values. Used for automagical calibration. </summary>
        </member>
        <member name="P:SGCore.Util.SensorNormalization.Length">
            <summary> The amount of items in this collector Useful for FOR loops. </summary>
        </member>
        <member name="P:SGCore.Util.SensorNormalization.MoveCount">
            <summary> The amount of values that have moved the appropriate amount. </summary>
        </member>
        <member name="P:SGCore.Util.SensorNormalization.CollectNormalization">
            <summary> If true, the normalization collection is active. If false, we're no longer collecting min / max values. </summary>
        </member>
        <member name="P:SGCore.Util.SensorNormalization.AllSensorsMoving">
            <summary> Returns true if all sensors are allowed to move. </summary>
        </member>
        <member name="F:SGCore.Util.SensorNormalization.moveRanges">
            <summary> The Movement Ranges for each value, given at the start, accessed through functions. </summary>
        </member>
        <member name="F:SGCore.Util.SensorNormalization.minValues">
            <summary> The minimum values measured during the sensor's lifetime. </summary>
        </member>
        <member name="F:SGCore.Util.SensorNormalization.maxValues">
            <summary> Maximum values measure during the sensor's lifetime. </summary>
        </member>
        <member name="F:SGCore.Util.SensorNormalization.canMove">
            <summary> If true, the values on this index can be normalized. Used for events / incrementing. </summary>
        </member>
        <member name="F:SGCore.Util.SensorNormalization.mapFactors">
            <summary> Factor to simplify output calculation to (val - minValue) * mapFactors[index[; </summary>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.#ctor(System.Single[])">
            <summary> MovementRanges.Length is used to determine the size. </summary>
            <param name="movementRanges"></param>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.ResetNormalization">
            <summary> Reset the normalization of values. </summary>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.UpdateNormalization(System.Single,System.Int32)">
            <summary>  </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.NormalizeValue(System.Single,System.Int32)">
            <summary> Normalize a value on a specific index, and update Normalization while you're at it. </summary>
            <param name="value"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.GetMinValue(System.Int32)">
            <summary> Returns the minimum value measured at the sensor at Index </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.GetMaxValue(System.Int32)">
            <summary> Returns the maximum value measured at the sensor at Index </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.NormalizeValues(System.Single[])">
            <summary> Update and Normalize a set of values, provided this is the same length. </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.MovedEnough(System.Int32)">
            <summary> Returns true if a sensor on this index has moved enough. </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SensorNormalization.DeNormalize(System.Single,System.Int32,System.Single)">
            <summary> Turn a value from 0 .. 1 back into [minValue ... maxValue] range for the Nova Glove. </summary>
            <param name="value01"></param>
            <param name="index"></param>
            <param name="fallbackValue"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.ListFormat">
            <summary> Indices to access DeviceList data in Shared Memory </summary>
        </member>
        <member name="T:SGCore.Util.SensorFormat">
            <summary> Indices to access Sensor Data in Shared Memory </summary>
        </member>
        <member name="T:SGCore.Util.Communications">
            <summary> "Database" containing communications bytes and conversions. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.cmdOpen">
            <summary> Byte indicating the start of a new command. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.cmdClose">
            <summary> Byte indicating the end of a command. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.senseOpen">
            <summary> Byte indicating the start of a new sensor data package. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.senseClose">
            <summary> Byte indicating the end of a sensor data package. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.listDelimiter">
            <summary> Denotes a block section of a DeviceList section. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.sectionDelimiter">
            <summary> ':' - Used to split a set of different contant values into individual groups. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.colDelimiter">
            <summary> ';' - Used to separate individual values </summary>
        </member>
        <member name="F:SGCore.Util.Communications.rowDelimiter">
            <summary> '|' - Used to group a set of values, for example per finger. </summary>
        </member>
        <member name="M:SGCore.Util.Communications.ToSGByte(System.Int32)">
            <summary> Convert a value between 0..100 to a Sense Glove char/byte </summary>
            <param name="lvl"></param>
            <remarks> Placed here so that external parties do not get direct access to this. </remarks>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Communications.ToSGByte(System.Single)">
            <summary> Encodes a floating-point value into a command with a resolution of 100 steps. </summary>
            <param name="value01"></param>
            <remarks> Placed here so that external parties do not get direct access to this. </remarks>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Communications.ToSGBytes(System.Single[],System.Int32,System.Single)">
            <summary> Encode a series of floating-point values into a SenseGlove string </summary>
            <param name="values01"> An array of values that is to be encoded into multiple characters </param>
            <param name="messageLength"> The length of the message. </param>
            <param name="fallbackValue"> If values01 is not long enough to reach messageLength, pad valued with this </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Communications.EncodeLinear(System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary> Encode a single value into a character into a range of bytes. Will alsways clamp! </summary>
            <param name="value"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <param name="minByte"></param>
            <param name="maxByte"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Communications.DecodeLinear(System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary> Convert a decoded byte back into its original floating value. Useful for decoding. </summary>
            <param name="byteFromChar"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <param name="minByte"></param>
            <param name="maxByte"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Serializer.FilterSpaces(System.String)">
            summary[ Filters spaces from a a string. /summary[
        </member>
        <member name="M:SGCore.Util.Serializer.SplitBlocks(System.String,System.Boolean)">
            summary[ Split a serialized string by its top level blocks /summary[
        </member>
        <member name="T:SGCore.Util.ServerData.Packet">
            <summary> Internal enumerator to parse packets </summary>
        </member>
        <member name="F:SGCore.Util.ServerData.dataDelim">
            <summary> Delimiter to parse data </summary>
        </member>
        <member name="M:SGCore.Util.ServerData.Update(System.String)">
            <summary> Updates data only </summary>
            <param name="fullGloveString"></param>
        </member>
        <member name="T:SGCore.Util.SGConnect_Android">
            <summary> Interface for the Android Library </summary>
            Since there is no Native Bluetooth SDK for Android, we have to use .aar files for now.
            There is no way to import such methods in C#, nor easily in C++. So instead, our Unity back-end handles Sending/Receiving to the API, and data ends up in this class.
        </member>
        <member name="T:SGCore.Util.SGConnect_Android.AndrSGDevice">
            <summary> Represents a block of memory for one SGDevice </summary>
        </member>
        <member name="F:SGCore.Util.SGConnect_Android.devices">
            <summary> The devices currently in memory </summary>
        </member>
        <member name="F:SGCore.Util.SGConnect_Android.scanningActive">
            <summary> Whether or not the devices have been initialized </summary>
        </member>
        <member name="F:SGCore.Util.SGConnect_Android.instance">
            <summary> Singleton instance of the android interface so we can access it statically.. </summary>
        </member>
        <member name="T:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs">
            <summary> Contains event data when one wishes to send data over Android </summary>
        </member>
        <member name="P:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs.DeviceIndex">
            <summary> Which of our devices to send haptics to. </summary>
        </member>
        <member name="P:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs.ChannelIndex">
            <summary> The Channel to send it to  </summary>
        </member>
        <member name="P:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs.HapticCommand">
            <summary> The actual haptics string to send over. </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs.#ctor(System.Int32,System.Int32,System.String)">
            <summary> Create a new instance of AndroidHapticEventArgs </summary>
            <param name="devIndex"></param>
            <param name="channel"></param>
            <param name="cmd"></param>
        </member>
        <member name="T:SGCore.Util.SGConnect_Android.AndroidHapticEventHandler">
            <summary> Delegate for the AndroidHapticEvent event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SGCore.Util.SGConnect_Android.AndroidHapticEvent">
            <summary> Fires when a new haptic command must be sent to the Android library. </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.#ctor">
            <summary> Default constructor for Instance </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.Cs_ActiveDevices">
            <summary> Check the number of devices detected by the system </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.Cs_ConnectionsRunning">
            <summary> Returns true if a device is currently posting data to this Interface. </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Util.SGConnect_Android.Cs_GetDeviceString(System.Int32,System.String@)" -->
        <member name="M:SGCore.Util.SGConnect_Android.Cs_GetSensorString(System.Int32,System.String@)">
            <summary> Retrieve lastes sensor data of a device </summary>
            <param name="deviceIndex"></param>
            <param name="sensorString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.Cs_SendHaptics(System.Int32,System.Int32,System.String)">
            <summary> Called from C# Code. Raises and event so that the Android Bridge can send it. </summary>
            <param name="deviceIndex"></param>
            <param name="channel"></param>
            <param name="hapticsToSend"></param>
            <returns>False if there is no event subscribers and nothing will therefre be sent...</returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.CS_GetConnectionStates(System.String@)">
            <summary> Retrieve states of each connection on this system.  </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_PostDeviceString(System.Int32,System.String)">
            <summary> Android-Only: Post a deviceString </summary>
            <param name="deviceIndex"></param>
            <param name="deviceString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_PostSensorData(System.Int32,System.String)">
            <summary> Android-Only: Post latest sensor data </summary>
            <param name="deviceIndex"></param>
            <param name="sensorData"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_Init">
            <summary> (Android Only) Let the software know we're active </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_Dispose">
            <summary> (Android Only) Once done with the devices, clear them from memory </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_PostDeviceStates(System.String)">
            <summary> Android-Only: Post a Device State String if needed.  </summary>
        </member>
        <member name="T:SGCore.Util.StrStuff">
            <summary> Utility class to convert strings into useable values. </summary>
        </member>
        <member name="M:SGCore.Util.StrStuff.ToInt(System.String,System.Int32)">
            <summary> Convert a string into an integer value </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.StrStuff.ToFloat(System.String,System.Single)">
            <summary> Convert a string into a decimal value. </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.StrStuff.DegString(System.Single)">
            <summary> Convert a radian notation into a readable degrees string.  </summary>
            <param name="rad"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.StrStuff.QuickSplit(System.String,System.Char,System.Int32)">
            <summary> 
            Retrieve a single section from a delimited string at a specific index.
            It is much faster at lower indices.
            Use when only one section of a string is interesting to you.
            </summary>
            <param name="input"></param>
            <param name="delim"></param>
            <param name="getIndex"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.UDPSocket">
            <summary> Contains common functions for UPD Sockets </summary>
        </member>
        <member name="F:SGCore.Util.UDPSocket.client">
            <summary> Actual UDPClient to do work </summary>
        </member>
        <member name="F:SGCore.Util.UDPSocket.remoteEndPoint">
            <summary> used to access data. </summary>
        </member>
        <member name="P:SGCore.Util.UDPSocket.Port">
            <summary> Port that was created for this Socket </summary>
        </member>
        <member name="P:SGCore.Util.UDPSocket.IP">
            <summary> IP (default localHost) </summary>
        </member>
        <member name="P:SGCore.Util.UDPSocket.Connected">
            <summary> Whether or not this socket is conencted </summary>
        </member>
        <member name="P:SGCore.Util.UDPSocket.Address">
            <summary> The IP address of this socket. </summary>
        </member>
        <member name="M:SGCore.Util.UDPSocket.#ctor">
            <summary> Basic Constructor </summary>
        </member>
        <member name="M:SGCore.Util.UDPSocket.Finalize">
            <summary> Ensure Dispose is called </summary>
        </member>
        <member name="M:SGCore.Util.UDPSocket.Connect(System.Int32,System.String)">
            <summary> Connect to a specific IP Port. </summary>
            <param name="_port"></param>
            <param name="_IP"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.UDPSocket.Dispose">
            <summary> Dispose Unmanaged Resources </summary>
        </member>
        <member name="T:SGCore.Util.UDPReceiver">
            <summary> A UDPReceiver which reads data in a readthread (since it's blocking) </summary>
        </member>
        <member name="F:SGCore.Util.UDPReceiver.receiveThread">
            <summary> Thread to receive data </summary>
        </member>
        <member name="F:SGCore.Util.UDPReceiver.getData">
            <summary> Keeps the thread alive </summary>
        </member>
        <member name="F:SGCore.Util.UDPReceiver.lastReceivedUDPPacket">
            <summary> Last data received by UDP </summary>
        </member>
        <member name="F:SGCore.Util.UDPReceiver.sf_Packet">
            <summary> Semaphore to protect simultaneous access </summary>
        </member>
        <member name="P:SGCore.Util.UDPReceiver.pingTime_ms">
            <summary> Time in between data received </summary>
        </member>
        <member name="P:SGCore.Util.UDPReceiver.LastData">
            <summary> Accessor for the last data received from UDP Socket </summary>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.#ctor">
            <summary> Basic Constructor </summary>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.Finalize">
            <summary> Ensure stuff gets disposed </summary>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.Connect(System.Int32,System.String)">
            <summary> Connect to a specific IP address and start up the Readthread. </summary>
            <param name="_port"></param>
            <param name="_IP"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.Dispose">
            <summary> Dispose of unmanaged resources. </summary>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.ReceiveData">
            <summary> Is run by the Thread. </summary>
        </member>
        <member name="T:SGCore.Util.UDPSender">
            <summary> Sends Strings over UDP. </summary>
        </member>
        <member name="M:SGCore.Util.UDPSender.#ctor">
            <summary> Basic constructor </summary>
        </member>
        <member name="M:SGCore.Util.UDPSender.Finalize">
            <summary> Ensure stuff gets disposed </summary>
        </member>
        <member name="M:SGCore.Util.UDPSender.Connect(System.Int32,System.String)">
            <summary> Connects to a specific IP address </summary>
            <param name="_port"></param>
            <param name="_IP"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.UDPSender.SendString(System.String)">
            <summary> Send a string over the socket. </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.CV.CV_Tracking_Depth">
            <summary> How much of the CV tracking is being used. Used by other APIs. </summary>
        </member>
        <member name="F:SGCore.CV.CV_Tracking_Depth.Disabled">
            <summary> No computer-vision is enabled. </summary>
        </member>
        <member name="F:SGCore.CV.CV_Tracking_Depth.WristOnly">
            <summary> Use CV only for the wrist position / rotation </summary>
        </member>
        <member name="F:SGCore.CV.CV_Tracking_Depth.WristAndHandPose">
            <summary> Use CV for both the wirst location and Hand Position  </summary>
        </member>
        <member name="T:SGCore.CV.CV_HandPoints">
            <summary> Used to access specific positions from the CV output, which is an array of Vect3D positions. </summary>
            <remarks> Declared in CVHandOutput.cs because these enums are used to index the jointPositions array in that class. </remarks>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_WRIST">
            <summary> The position of the wrist as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_THUMB_CMC">
            <summary> The position of the Thumb CMC Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_THUMB_MCP">
            <summary> The position of the Thumb MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_THUMB_IP">
            <summary> The position of the Thumb IP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_THUMB_TIP">
            <summary> The position of the Thumb tip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_INDEX_MCP">
            <summary> The position of the Index MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_INDEX_PIP">
            <summary> The position of the Index PIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_INDEX_DIP">
            <summary> The position of the Index DIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_INDEX_TIP">
            <summary> The position of the Index fingertip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_MIDDLE_MCP">
            <summary> The position of the Middle MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_MIDDLE_PIP">
            <summary> The position of the Middle PIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_MIDDLE_DIP">
            <summary> The position of the Middle DIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_MIDDLE_TIP">
            <summary> The position of the Middle fingertip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_RING_MCP">
            <summary> The position of the Ring MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_RING_PIP">
            <summary> The position of the Ring PIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_RING_DIP">
            <summary> The position of the Ring DIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_RING_TIP">
            <summary> The position of the Ring fingertip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_PINKY_MCP">
            <summary> The position of the Pinky MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_PINKY_PIP">
            <summary> The position of the Pinky PIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_PINKY_DIP">
            <summary> The position of the Pinky DIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_PINKY_TIP">
            <summary> The position of the Pinky fingertip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_All">
            <summary> Utility enumerator to check if an array contains enough values. </summary>
        </member>
        <member name="T:SGCore.CV.CV_HandTrackingData">
            <summary> Contains output from one of our CV Model, specifically that for a hand / glove. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandTrackingData.timeStamp">
            <summary> Simulation time When this Data was received. Used for data smoothing. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandTrackingData.jointPositions">
            <summary> 21 positions, representing the wrist and finger positions in 3D (world)space. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandTrackingData.rightHand">
            <summary> If the data is created for a left-or right hand. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandTrackingData.certaintyFactor">
            <summary> How certain is it that this is an actual hand that we're tracking.  </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandTrackingData.fingerCertainties">
            <summary> How certain we are about each finger.  </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandTrackingData.forDevice">
            <summary> Which Device this data has been generated for </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandTrackingData.forHwVersion">
            <summary> (sub)hardware version that this data has been generated for. </summary>
        </member>
        <member name="P:SGCore.CV.CV_HandTrackingData.IsValid">
            <summary> Returns true if enough Data is available. </summary>
        </member>
        <member name="P:SGCore.CV.CV_HandTrackingData.IsRight">
            <summary> Returns true if the CV Model estimated this to be a right hand.  </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandTrackingData.#ctor(SGCore.Kinematics.Vect3D[],System.Single,System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Create a new CV_HandTrackingData instance, with an autmatically generated TimeStamp.</summary>
            <param name="CVHandPoints"></param>
            <param name="certainty"></param>
            <param name="forDeviceType"></param>
            <param name="subHwVersion"></param>
            <param name="rightHandedNess"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandTrackingData.#ctor(SGCore.Kinematics.Vect3D[],System.Single,System.Boolean,SGCore.DeviceType,System.String,System.Single)">
            <summary> Create a new CV_HandTrackingData instance with a custom timestamp. </summary>
            <param name="CVHandPoints"></param>
            /// <param name="certainty"></param>
            <param name="forDeviceType"></param>
            <param name="subHwVersion"></param>
            <param name="rightHandedNess"></param>
            <param name="time"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandTrackingData.GetPosition(SGCore.CV.CV_HandPoints)">
            <summary> Safely retrieve the location of a specific joint. </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandTrackingData.MatchesDevice(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Returns true if this pose was made for a specific hand, device, and sub-hw version. </summary>
            <param name="isRight"></param>
            <param name="type"></param>
            <param name="hwVer"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandTrackingData.MatchesDevice(SGCore.CV.CV_HandTrackingData)">
            <summary> Returns true if this pose was made for the same device as another pose. </summary>
            <param name="otherPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandTrackingData.ToString">
            <summary> Get a simple notation of this CV_HandTrackingData. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandTrackingData.PrintKeyPoints(System.String)">
            <summary> Prints all of the joint positions within this CV_HandTrackingData. </summary>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.CV.CV_Kinematics">
            <summary> Kinematic Algorithms for Computer Vision. Much like JointKinematics, this static class contains the fance mathematics. </summary>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateTrackingData(SGCore.CV.CV_HandTrackingData,SGCore.CV.CV_ProcessedHandData@,System.Boolean)">
            <summary> Converts CV output (21 joint positions + handed-ness) into a handDataPoint. Returns true if the calculation is succesful. </summary>
            <param name="pose"></param>
            <param name="dataPoint"></param>
            <param name="naturalLimits">If true, joint angles are clamped within their natural limits. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateHandPoseData(SGCore.CV.CV_HandTrackingData,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@,SGCore.Kinematics.Vect3D[][]@,System.Boolean)">
            <summary> Calculates the  wrist location and hand angles and based on the 21 keypoints + handedness in our CV Output. </summary>
            <param name="pose"></param>
            <param name="wristWorldPos"></param>
            <param name="wristWorldRot"></param>
            <param name="handAngles"></param>
            <param name="naturalLimits"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateWristLocation(SGCore.CV.CV_HandTrackingData,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Calculate the wrist position and -rotation from a set of keypoints that describe the finger. </summary>
            <param name="pose"></param>
            <param name="wristWorldPos"></param>
            <param name="wristWorldRot"></param>
        </member>
        <member name="F:SGCore.CV.CV_Kinematics.cmcLimitLeft">
            <summary> It's a right hand if our we process it as a right hand and the CMC joint is 'below' the wrist by this much. </summary>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CheckForRightHand(SGCore.Kinematics.Vect3D[],System.Boolean@)">
            <summary> In case  Martijn's Data doesn't say, to a manual check for the left/right handedness. 90% accurate so far. </summary>
            <param name="cvPositions"></param>
            <param name="rightHanded"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.EstimateAbd(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Calculates the most likely Abduction (z) angle. All of these positons must be relative to the first joint (CMC or MCP), in the thumb/finger coordinate system. </summary>
            <param name="medialJoint"></param>
            <param name="distalJoint"></param>
            <param name="fingerTip"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateLastFlexion(System.Single,System.Single,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Calculates the flexion of the last joint, based on  </summary>
            <param name="j0Flex"></param>
            <param name="j1Flex"></param>
            <param name="tipRelToj0"></param>
            <param name="j2RelToj0"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateHandAngles(SGCore.CV.CV_HandTrackingData,SGCore.Kinematics.Quat,System.Boolean)">
            <summary> The actual hand angle calculations. First we define a "working plane"; joint start rotation + abduction. j0 flexion is calculated using aTan2, j1 flexion using vector.anglebetween.
            finally, j2 flexion is calculated using aTan2 again, using j0's reference frame. </summary>
            <param name="pose"></param>
            <param name="wristWorldRot"></param>
            <param name="naturalLimits"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:SGCore.CV.CV_HandLayer" -->
        <member name="F:SGCore.CV.CV_HandLayer.requestedDeviceCount">
            <summary> The amount of devices that should be visible to the CV camera. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandLayer.forDevice">
            <summary> Which deviceType are detected and are being used to run the model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandLayer.forHwVer">
            <summary> Optional sub-hardware-type that is being used to run the moddel </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandLayer.simStart">
            <summary> Initialized upon the dll being loaded. The automatic simulation time will be based on this class </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandLayer.smoothedData">
            <summary> Hand Data smoothers, with entries for each hand / glove / hw combinations. Expecting there won't be more than 2 of these. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.GetSimulationTime">
            <summary> Retrieve the current simulation time - used for generating timestamps. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.DataIndex(SGCore.CV.CV_HandTrackingData)">
            <summary> Returns the index within smoothedData that matches the handednedd / glove / subtype combination of a particular output. </summary>
            <param name="cvData"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.DataIndex(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Returns the index within smoothedData that matches the handednedd / glove / subtype combination. </summary>
            <param name="rightHand"></param>
            <param name="devType"></param>
            <param name="hwVer"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.PostHandData(SGCore.CV.CV_HandTrackingData)">
            <summary> Post new CV output once it becomes available. Will be used to calculate smoothed Data </summary>
            <param name="cvData"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.ClearCVData">
            <summary> Clear all Data from memory. Useful if you're restarting. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.PoseAvailable(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Returns true if data is available for a hand of a specific handedness / DeviceType / hwVersion </summary>
            <param name="rightHand"></param>
            <param name="deviceType"></param>
            <param name="hwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.TryGetPose(System.Boolean,SGCore.DeviceType,System.String,SGCore.CV.CV_ProcessedHandData@,System.Boolean)">
            <summary> Returns true if  the data was succesfully gathered. Simulation time is gathered GetSimulationTime(). </summary>
            <param name="rightHand"></param>
            <param name="deviceType"></param>
            <param name="hwVersion"></param>
            <param name="handData"></param>
            <param name="clampValues"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.TryGetPose(System.Single,System.Boolean,SGCore.DeviceType,System.String,SGCore.CV.CV_ProcessedHandData@,System.Boolean)">
            <summary> Returns true if  the data was succesfully grathered for a custom timeStamp. </summary>
            <param name="currentTime"></param>
            <param name="rightHand"></param>
            <param name="deviceType"></param>
            <param name="hwVersion"></param>
            <param name="handData"></param>
            <param name="clampValues"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.CV.CV_ProcessedHandData">
            <summary> CVHandOutput converted into HandAngles + wrist location. Has all the information needed to determine when and how to convert this data into an actual HandPose. </summary>
            <remarks> Can generate a "smoothed" version of this via the HandDatSmoothing or just return the latets one. </remarks>
        </member>
        <member name="F:SGCore.CV.CV_ProcessedHandData.timeStamp">
            <summary> The data point's timestamp, used for smoothing </summary>
        </member>
        <member name="F:SGCore.CV.CV_ProcessedHandData.handAngles">
            <summary> The HandAngles caluclated at ttimeStamp </summary>
        </member>
        <member name="F:SGCore.CV.CV_ProcessedHandData.wristWorldPosition">
            <summary> The wrist position calculated at timeStamp </summary>
        </member>
        <member name="F:SGCore.CV.CV_ProcessedHandData.wristWorldRotation">
            <summary> The wrist rotation calculated at timeStamp </summary>
        </member>
        <member name="F:SGCore.CV.CV_ProcessedHandData.rightHand">
            <summary> Whether or not this data point was generated for a left- or right hand </summary>
        </member>
        <member name="F:SGCore.CV.CV_ProcessedHandData.globalCertainty">
            <summary> Certainties of the whole hand tracking. </summary>
        </member>
        <member name="M:SGCore.CV.CV_ProcessedHandData.#ctor">
            <summary> Created empty arrays and data. </summary>
        </member>
        <member name="M:SGCore.CV.CV_ProcessedHandData.#ctor(System.Boolean,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D[][],System.Single,System.Single)">
            <summary> Create a new instance of a HandDataPoint with a custom timestamp. </summary>
            <param name="isRight"></param>
            <param name="wristPos"></param>
            <param name="wristRot"></param>
            <param name="fingerAngles"></param>
            <param name="time"></param>
            <param name="globalCert"></param>
            <param name="fingerCert"></param>
        </member>
        <member name="M:SGCore.CV.CV_ProcessedHandData.#ctor(System.Boolean,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D[][],System.Single)">
            <summary> Create a new instance of a HandDataPoint using an autmatically generated timestamp. </summary>
            <param name="isRight"></param>
            <param name="wristPos"></param>
            <param name="wristRot"></param>
            <param name="fingerAngles"></param>
            <param name="globalCert"></param>
        </member>
        <member name="M:SGCore.CV.CV_ProcessedHandData.ToString">
            <summary> Prints the tracking data of this HandDataPoint </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_ProcessedHandData.ToHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Convert the handAngles etc of this HandDataPoint into an acual HandPose </summary>
            <param name="handDimensions"></param>
            <param name="handPose"></param>
        </member>
        <member name="M:SGCore.CV.CV_ProcessedHandData.ToHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Convert the handAngles etc of this HandDataPoint into an acual HandPose </summary>
            <param name="handDimensions"></param>
            <param name="handPose"></param>
            <param name="wristPosition"></param>
            <param name="wristRotation"></param>
        </member>
        <member name="M:SGCore.CV.CV_ProcessedHandData.InterpolateData(System.Single,SGCore.CV.CV_ProcessedHandData,SGCore.CV.CV_ProcessedHandData,System.Boolean)">
            <summary> Interpolate beween two HandDataPoints to generate a new one </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="t"></param>
            <param name="clampOutput"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_ProcessedHandData.InterpolateData(System.Single,SGCore.CV.CV_ProcessedHandData,SGCore.CV.CV_ProcessedHandData,System.Boolean,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@,SGCore.Kinematics.Vect3D[][]@)">
            <summary> Interpolate all Hand Data between two points. </summary>
            <param name="t"></param>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="clampOutput"></param>
            <param name="wristPos"></param>
            <param name="wristRot"></param>
            <param name="handAngles"></param>
        </member>
        <member name="T:SGCore.CV.CV_HandDataSmoother">
            <summary> Keeps track of a small history of CV Outputs to compensate for low(er) update rates. For example, running a VR simulation at 90Hz while sampling at 30. </summary>
        </member>
        <member name="T:SGCore.CV.CV_HandDataSmoother.SmoothingMethod">
            <summary> The way handPoses are smoothed in this class. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.SmoothingMethod.None">
            <summary> None. You'll always get the latest pose received. No performance increase, but might result in a "stop-motion" effect on lower framerates.  </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.SmoothingMethod.InterpolateBehind">
            <summary> Pretend you're one sample behind, and interpolate along the exact paths. More accurate, but we will lag 1 frame behind. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.SmoothingMethod.ExtrapolateAhead">
            <summary> Take the last two handPoses and estimate the current values based on extrapolation. Is percieved as "faster", but is more likely to overhoot during sudden changes in direction.  </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.initialInput">
            <summary> What the HandPos was originally made for. Used to deterime which DeviceType / Handedness / subHW version this data was generated for. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.maxDataPoints">
            <summary> The maximum amount of points we keep track of for smoothed hand data. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.lastFrames">
            <summary> The last X amount of frames this data keeps in memory. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.smoothMethod">
            <summary> The way in which we're smoothing the incoming data </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.lastSmoothedData">
            <summary> When using SmoothingMethod.ExtrapolateAhead: The last dmoothed data, used to determine projection and PosAtPrediction when both are null. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.projection">
            <summary> When using SmoothingMethod.ExtrapolateAhead: What the next frame is estimated to look like, based on the last two data points. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.posAtPrediction">
            <summary> When using SmoothingMethod.ExtrapolateAhead: The variables we had calculated to be at during the last GetSmoothedPose call. </summary>
            <remarks> Interpolating from this to the projection as opposed to the last two frames, so that we don't "jump" around. </remarks>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.#ctor(SGCore.CV.CV_HandTrackingData)">
            <summary> Create a new instance of Smoothed Hand Data, using a first frame. </summary>
            <param name="firstFrame"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.MatchesDevice(SGCore.CV.CV_HandTrackingData)">
            <summary> Returns true if this Smoother was created for the same device as the one of this cvPose. Used in CVHandLayer </summary>
            <param name="cvPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.MatchesDevice(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Returns true if this Smoother was created for a particular hand / deviceType / hw. Used in CVHandLayer </summary>
            <param name="isRight"></param>
            <param name="type"></param>
            <param name="hwVer"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.ClearFrames">
            <summary> Clear smoothing data. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.FrameCount">
            <summary> The amount of frames currently in this smoother (0 .. maxDataPoints). </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.GetFrame(System.Int32,SGCore.CV.CV_ProcessedHandData@)">
            <summary> Safely retrieve a HandDataPoint out of this class' frame buffer. </summary>
            <param name="index"></param>
            <param name="frame"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.AddFrame(SGCore.CV.CV_HandTrackingData)">
            <summary> Post new CVHandOutput into this Smoother, which will converted into handAngles and calculate the appropriate values.. </summary>
            <param name="nextFrame"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.UpdateProjection">
            <summary> Updates Projection values, which is used when using SmoothingMethod.ExtrapolateAhead. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.SetLastSmoothed(SGCore.CV.CV_ProcessedHandData)">
            <summary> Since the last smoothed pose is updated every time I request one, I need to keep track of it When using SmoothingMethod.ExtrapolateAhead </summary>
            <param name="newSmoothedData"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.GetSmoothedPose(System.Single,SGCore.CV.CV_ProcessedHandData@,System.Boolean)">
            <summary> Based on the last X frames in this buffer, each with an earlier timestamp, Retrieve Smoothed Hand Data at currentTime </summary>
            <param name="currentTime">Time at which this data is requested, used to interpolate / extrapolate. </param>
            <param name="smoothedData"> Output: Smoothed Hand Data </param>
            <param name="clampValues"> If true, any smoothed output pose cannot 'extend' beyond the latest (predicted) values. </param>
            <returns></returns>
        </member>
        <member name="T:SGCore.HapticChannelType">
            <summary> Different types of Haptic Channels - with different behaviours </summary>
        </member>
        <member name="F:SGCore.HapticChannelType.StreamingChannel">
            <summary> This type of haptic channel can be constantly overridden. SGConnect will only send a command if a change occurs. Ideal for Force-Feedback. </summary>
        </member>
        <member name="F:SGCore.HapticChannelType.FireAndForgetChannel">
            <summary> These commands must be sent once, after thire queue is cleared. </summary>
        </member>
        <member name="T:SGCore.HapticChannelInfo">
            <summary> Contains information on Haptic channels available to this device for IPC.  </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.streamingType">
            <summary> Byte used to identify streaming channels </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.fireNforgetType">
            <summary> byte used to indicate fire-and-forget channels. </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.streamIndices">
            <summary> Becuase the names are dependent of device index, and I want to be able to regenerate them, I need to keep track of the original number... </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.fNfIndices">
            <summary> Becuase the names are dependent of device index, and I want to be able to regenerate them, I need to keep track of the original number... </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.ipcAddresses">
            <summary> Allof the IPC adress names. </summary>
        </member>
        <member name="M:SGCore.HapticChannelInfo.#ctor">
            <summary> Creates a default HapticChannelInfo, with solely a single streaming haptic Channel </summary>
        </member>
        <member name="M:SGCore.HapticChannelInfo.#ctor(System.Int32[],System.Int32[])">
            <summary>  </summary>
            <param name="streamInd"></param>
            <param name="fireNforgetInd"></param>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetStreamChannelCount">
            <summary> Returns the amount of streaming channels available for haptics. Will indicate if a device can support the haptics you're trying to send through it. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetFireAndForgetChannelCount">
            <summary> Returns the amount of fire-and-forget channels available for haptics. Will indicate if a device can support the haptics you're trying to send through it. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetTotalChannelCount">
            <summary> retrieve the total amount of channels for this device. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetAddress_Unguarded(SGCore.HapticChannelType,System.Int32)">
            <summary> Returns the address that corresponds to the nth channel of a specific type. It's unguarded, which means I dont check the validity of index - could result in an exception. Optimized piece of code for for loops. </summary>
            <param name="type"></param>
            <param name="typeIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetIPCParams_Unguarded(SGCore.HapticChannelType,System.Int32,System.Int32@,System.String@)">
            <summary> Returns the address that corresponds to the nth channel of a specific type. It's unguarded, which means I dont check the validity of index - could result in an exception. Optimized piece of code for for loops. Used for Internals </summary>
            <param name="type"></param>
            <param name="typeIndex"></param>
            <param name="addressString"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.RegenerateAddresses(System.Int32)">
            <summary> Regenerate the channel names for a specific device Index in shared memory. </summary>
            <param name="forDeviceIndex"></param>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetAllAddresses">
            <summary> Returns an array of all the haptic addrsses stored for this info channel. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GenerateAddress(System.Int32,System.Int32)">
            <summary> Generate a single IPCAddress for an address. </summary>
            <param name="deviceIndex"></param>
            <param name="channelIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.Parse(System.String)">
            <summary> Parse HapticChannelInfo received through IPC into useable data </summary>
            <param name="ipcString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.HandLayer">
            <summary> A way to access all sorts of Hand Tracking and -Haptics without needing to cache any device instances.
            Use this layer if you don't care where a HandPose is coming from, and are fine with calling generic haptic functions. </summary>
        </member>
        <member name="M:SGCore.HandLayer.DeviceConnected(System.Boolean)">
            <summary> Returns true if there is a HapticGlove Device connected that corresponds to the chosen hand. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.GetDeviceType(System.Boolean)">
            <summary> Returns the Device Type of the right / left hand. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.GetFirstGloveHandedness">
            <summary> Returns the handedness of the first device you can find; true for right, false for left. Use this for testing a ginle glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.GlovesConnected">
            <summary> Returns the number of Haptic Gloves connected to the system </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.GetGloveInstance(System.Boolean,SGCore.HapticGlove@)">
            <summary> Retireve a Glove Instance for the right- or left hand to do more cmplixated, device-sepecific stuff. </summary>
            <param name="rightHand"></param>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.GetCalibrationState(System.Boolean)">
            <summary> Retruns the calibration state of the chosen hand. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.GetCalibrationInstructions(System.Boolean)">
            <summary> Returns the Calibration Instructions for the chosen hand </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.ResetCalibration(System.Boolean)">
            <summary> Reset the calibration of the left/right hand. </summary>
            <param name="rightHand"></param>
        </member>
        <member name="M:SGCore.HandLayer.EndCalibration(System.Boolean)">
            <summary> Reset the calibration of the left/right hand. </summary>
            <param name="rightHand"></param>
        </member>
        <member name="M:SGCore.HandLayer.LoadCalibrationFromDisk">
            <summary> Windows-only. If calibration is available (via SenseCom, for instance) we can use this to (re)load it. This step happens autmagically at the start of your runtime. </summary>
        </member>
        <member name="M:SGCore.HandLayer.GetHandPose(System.Boolean,SGCore.HandPose@)">
            <summary> Attempt to get the HandPose through any of our gloves. You don't care which one is on the other side, as long as you get one. </summary>
            <param name="rightHand"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.GetWristLocation(System.Boolean,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Calculate the Wirst Location of the chosen hand, based on a reference location and tracking hardware. </summary>
            <param name="rightHand"></param>
            <param name="referencePosition"></param>
            <param name="referenceRotation"></param>
            <param name="trackingHardware"></param>
            <param name="wristPosition"></param>
            <param name="wristRotation"></param>
        </member>
        <member name="M:SGCore.HandLayer.SendHaptics(System.Boolean)">
            <summary> Sends all haptics in the queue for the Left / Right hand. </summary>
            <param name="rightHand"></param>
        </member>
        <member name="M:SGCore.HandLayer.StopAllHaptics(System.Boolean)">
            <summary> Stopa all haptics on the chosen hand. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.QueueCmd_FFBLevel(System.Boolean,System.Int32,System.Single,System.Boolean)">
            <summary> Tell a specific hand to hold the force-feedback at a certain level. </summary>
            <param name="rightHand"></param>
            <param name="finger"></param>
            <param name="level01"></param>
            <param name="sendImmediate"></param>
        </member>
        <member name="M:SGCore.HandLayer.QueueCmd_FFBLevels(System.Boolean,System.Single[],System.Boolean)">
            <summary> Queue Force Feedback for multiple fingers. Up to 5. Make sure the value is not NULL. </summary>
            <param name="rightHand"></param>
            <param name="levels01"></param>
            <param name="sendImmediate"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.QueueCmd_SetVibroLevel(System.Boolean,System.Int32,System.Single,System.Boolean)">
            <summary> Queue a command to set the vibration level(s) of a Haptic Glove's finger. Note: This is only for Nova 1.0 and DK1.0. </summary>
            <param name="rightHand"></param>
            <param name="finger"></param>
            <param name="level01"></param>
            <param name="sendImmediate"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.QueueCmd_SetVibroLevel(System.Boolean,SGCore.HapticLocation,System.Single,System.Boolean)">
            <summary> A more genetric queue vibro lovel command for nova 1 wrist / thumper. </summary>
            <param name="rightHand"></param>
            <param name="location"></param>
            <param name="level01"></param>
            <param name="sendImmediate"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.QueueCmd_SetVibroLevels(System.Boolean,System.Single[],System.Boolean)">
            <summary> Queue a command to set the vibration level(s) of a Haptic Glove's finger. Note: This is only for Nova 1.0 and DK1.0. </summary>
            <param name="rightHand"></param>
            <param name="levels01"></param>
            <param name="sendImmediate"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.SupportsCustomWaveforms(System.Boolean,SGCore.HapticLocation)">
            <summary> Returns true if the glove for this hand supports a custom waveform vibration on said location. </summary>
            <param name="rightHand"></param>
            <param name="atLocation"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.SendCustomWaveform(System.Boolean,SGCore.CustomWaveform,SGCore.HapticLocation)">
            <summary> Send a Custom Waveform to a glove at a specific location </summary>
            <param name="rightHand"></param>
            <param name="waveform"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.SupportsWristSqueeze(System.Boolean)">
            <summary> Retruns tru if the chosen glove supports active contact feedback on the Wrist </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.QueueCmd_WristSqueeze(System.Boolean,System.Single,System.Boolean)">
            <summary> Queue a command to set a squeeze level on the wrist, and optionally send it right away. </summary>
            <param name="rightHand"></param>
            <param name="squeezelvl01"></param>
            <param name="sendImmediate"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.SupportsFlexionLocks(System.Boolean)">
            <summary> Returns true is the chosen hand supports flexion locking; automatic locking of FFB when flexed beyond a specific point. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.QueueCmd_FlexionLock(System.Boolean,System.Int32,System.Single,System.Boolean)">
            <summary> If the flexion exceeds a particular value, turn on the Force-Feedback </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandLayer.QueueCmd_ClearFlexionLock(System.Boolean,System.Int32,System.Boolean)">
            <summary> Stop any Flexion Threshold active on the chosen finger </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.IFingerFFB_SetLevels">
            <summary> Represents a device of which you can directly set the Force-Feedback level for one or more fingers. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.IFingerFFB_SetLevels.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.IFingerFFB_SetLevels.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0f means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <remarks> Devices that 'only' have on/off FFB will treat any value > 0.0 as 1.0. </remarks>
            <returns>Returns true if the command was sucessfully added to the queue. If false, the device might not support the chosen finger(s) or have the appropriate firmware.</returns>
        </member>
        <member name="M:SGCore.IFingerFFB_SetLevels.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucesfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="T:SGCore.IFingerVibro_SetLevels">
            <summary> A device of which you can directly control the amplitude of vibration motors on each finger, at a set frequency. Note: You'll still have to turn these off! </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.IFingerVibro_SetLevels.QueueVibroLevels(System.Single[])" -->
        <member name="M:SGCore.IFingerVibro_SetLevels.QueueVibroLevel(SGCore.Finger,System.Single)">
            <summary> Set the vibration amplitude of a particular finger to a specific level </summary>
            <param name="amplitude"> Value will be clamped between [0...1], where 0.0 means no vibration, and 1.0 means full vibration. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <remarks> Devices that 'only' have on/off vibration control will treat any value > 0.0 as 1.0. </remarks>
            <returns>Returns true if the command was sucessfully added to the queue. If false, the device might not support the chosen finger(s) or have the appropriate firmware.</returns>
        </member>
        <member name="M:SGCore.IFingerVibro_SetLevels.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucesfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="T:SGCore.IFingerFFB_Thresholds">
            <summary> Represents a Device that can automatically engage Force-Feedback on the finger(s) when a specific threshold is reached. </summary>
        </member>
        <member name="M:SGCore.IFingerFFB_Thresholds.QueueThresholdCmd(SGCore.Finger,System.Single)">
            <summary> Queue a command to autmatically engage a finger's Force-Feedback when the sensor value exceeds a set threshold. </summary>
            <param name="sensorValueThreshold"> Sensor Value for thresholds. Not Flexion </param>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.IFingerFFB_Thresholds.QueueThresholdCmd_Flexion(SGCore.Finger,System.Single)">
            <summary> Stops the glove when flexing pas this point. </summary>
            <param name="finger"></param>
            <param name="flexionThreshold"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.IFingerFFB_Thresholds.QueueThresholdCmd_Flexions(System.Boolean[],System.Single[])" -->
        <member name="M:SGCore.IFingerFFB_Thresholds.QueueClearThreshold(SGCore.Finger)">
            <summary> Queue a command to clear the threshold for a specific finger. </summary>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.IFingerFFB_Thresholds.QueueClearThresholds">
            <summary> Queue a command to clear the thresholds for each finger. </summary>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.IFingerFFB_Thresholds.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucesfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="T:SGCore.Nova.Nova2Glove">
            <summary> Interface for Nova 2.0 Gloves.  A soft glove with detachable force-feedback and sensor module, and active contact feedback in the front strap. </summary>
        </member>
        <member name="T:SGCore.Nova.Nova2Glove.Nova2_VibroMotors">
            <summary> Which vibration motors to send vibrations to </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.Nova2_VibroMotors.Unknown">
            <summary> Not sure which motor this is meant for. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.Nova2_VibroMotors.ThumbFingerTip">
            <summary> LRA Vibration Motor that is located on the thumb fingertip </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.Nova2_VibroMotors.IndexFingerTip">
            <summary> LRA Vibration Motor that is located on the index fingertip </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.Nova2_VibroMotors.PalmIndexSide">
            <summary> LRA Vibration Motor that is located on the hand palm, roughly at the Index MCP joint. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.Nova2_VibroMotors.PalmPinkySide">
            <summary> LRA Vibration Motor that is located on the hand palm, roughly at the Pinky MCP joint. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.gloveInfo">
            <summary> Contains Nova-specific device information. Contained inside its own class. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.hapticStream">
            <summary> Haptic Stream </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.sensorNormalizer">
            <summary> Normalization for senor inputs. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2Glove.IndexInfluencesOthers">
            <summary> If true, this Index Finger trackign influences that of others (default = true). </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.nova2SensorRanges">
            <summary> Ranges before a Nova 2.0 Sensor is allowed to move. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.lastStreamCmd">
            <summary> The last command sent to the device, used to not send anything too often </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.streamByte">
            <summary> Special Byte to identify the command as a Streaming Byte. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2Glove.OnBoardNormalization">
            <summary> If true, this Glove runs sensor normalization on-board the glove. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.abductionMoving">
            <summary> If set to true, we've recognized that abduction is currently moving. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.confirmCalibration">
            <summary> If true, the calibration is currently being confirmed. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.endCalibrationTime">
            <summary> The time for which one needs to hold a thumbs up. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.startConfirmTime">
            <summary> Time that we've started confirming the calibration. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2Glove.LockCalibrationInternal">
            <summary> A way to enable / disable internal calibration confirmation. If false, the glove will never 'lock' in values with a thumb up. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.#ctor(SGCore.Nova.Nova_GloveInfo)">
            <summary> Create a new instance of a Nova2Glove. </summary>
            <param name="info"></param>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetDeviceID">
            <summary> Retrieve this device's uniqie identifier / serial number. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetDeviceType">
            <summary> Retrieve this device's specific DeviceType </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetFirmwareVersion">
            <summary> Retrieve this device's main Firmware version. (e.g. v4.2 -> 4). </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetSubFirmwareVersion">
            <summary> Retieve this device's sub-firmware version. (e.g. v4.2 -> 2). </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetHardwareVersion">
            <summary> Get the hardware sub-version of this Nova Glove (v1.1, v1.2 etc). </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.ToString">
            <summary>  </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.HasBattery">
            <summary> If true, this device runs on a battery </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.IsCharging">
            <summary> If true, this device's firmware has recognized that it is charging. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetBatteryLevel(System.Single@)">
            <summary> Retruns the battery level of this wireless device, as a value between  0..1. </summary>
            <param name="battLvl"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.IsRight">
            <summary> Returns true if this glove is useable for a right hand. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetIMURotation(SGCore.Kinematics.Quat@)">
            <summary> Retireve this glove's latest IMU rotation, if one is present. </summary>
            <param name="IMU"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve this Glove's location, based on its internal IsRight and DeviceType properties. if you're interested in Hand Tracking, use GetWristLocation instead. </summary>
            <param name="refPosition"></param>
            <param name="refRotation"></param>
            <param name="trackingHardware"></param>
            <param name="glovePos"></param>
            <param name="gloveRot"></param>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.CalculateGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve any Glove's location, based on the device properties. if you're interested in Hand Tracking, use GetWristLocation instead. </summary>
            <param name="refPosition"></param>
            <param name="refRotation"></param>
            <param name="trackingHardware"></param>
            <param name="rightHand"></param>
            <param name="hardwareVersion"></param>
            <param name="glovePos"></param>
            <param name="gloveRot"></param>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the Wrist location based on this glove's internal handed-ness and hardware version. </summary>
            <param name="refPosition"></param>
            <param name="refRotation"></param>
            <param name="trackingHardware"></param>
            <param name="wristPos"></param>
            <param name="wristRot"></param>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.CalculateWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the Wrist location based on any glove's handed-ness and hardware version. </summary>
            <param name="refPosition"></param>
            <param name="refRotation"></param>
            <param name="trackingHardware"></param>
            <param name="rightHand"></param>
            <param name="hardwareVersion"></param>
            <param name="wristPos"></param>
            <param name="wristRot"></param>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetCalibrationState">
            <summary> Retrieve the calilbration status of this Nova 2.0 Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.TryLoadProfile">
            <summary> Attempt to load a HapticGlove Profile from disk, if one exists. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetMinimalSensorMovement">
            <summary> Retireve the minimum sensor ranges for a Nova Glove's Raw ADC values. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetNormalizedInput(System.Single[]@)">
            <summary> Returns the normalized Sensor Data of this Nova Glove. If no normalization is running on the glove(s), then it's done on the PC side. </summary>
            <param name="normalizedValues"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.ToNormalizedValues(SGCore.Nova.Nova2_SensorData,SGCore.Util.SensorNormalization)">
            <summary> Convert Sensor Data into a series of normalized values. </summary>
            <param name="sData"></param>
            <param name="sensorNormalizer"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetHandAngles(SGCore.Kinematics.Vect3D[][]@)">
            <summary> Returns the Hand Angles calculated by this Nova 2 Glove. Used for input for HandPoses, but can be used in and of itself. </summary>
            <param name="handAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.CalculateHandAngles(System.Single[],SGCore.Kinematics.HandInterpolator,System.Boolean)">
            <summary> Calculate Hand Angles for a Nova 2.0 Glove, based on normalized input. </summary>
            <param name="normalizedValues"></param>
            <param name="interpolator"></param>
            <param name="influenceIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Calculate a HandPose from this glove's latest Sensor Data </summary>
            <param name="handGeometry"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.ToNormalizedAngles(System.Single[],SGCore.Nova.Nova_GloveInfo@)">
            <summary> Convert normalized inputs (5-6 sensors) to input for an Interpolator. </summary>
            <param name="normalizedData"></param>
            <param name="gloveInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetGloveModel">
            <summary> Access DeviceInfo of this Nova </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.NormalizationOnGlove">
            <summary> Returns true if this Nova Glove requires Normalization on the glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetSensorData(SGCore.Nova.Nova2_SensorData@)">
            <summary> Get the latest Sensor Data from this Sense Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.NormalizedOnGlove">
            <summary> If true, this glove is supposed to run sensor normalization on-board the glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.EndCalibration">
            <summary> Completes sensor Normalization on the Nova 2.0's end. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.ResetCalibration">
            <summary>  Completes sensor Normalization on the Nova 2.0's end. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetCalibrationInstruction">
            <summary> Returns current calibration instructions... </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.ToNormalizedValues(SGCore.Nova.Nova2_SensorData)">
            <summary> Converts Nova_Sensor Data into floating point inputs for normalization. </summary>
            <param name="sensorData"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetSensorNormalizer">
            <summary> Access this Glove's Sensor Normalizer. Only edit this when you know what you're doing! </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.SetSensorNormalizer(SGCore.Util.SensorNormalization)">
            <summary> If settings match, set the SensorNormalizer for this Nova Glove manually. </summary>
            <param name="newNormalizer"></param>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.FingerToHapticLocation(SGCore.Finger)">
            <summary> Converts a Finger into a Haptic Location for the Nova 2.0 Glove </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.SendHaptics">
            <summary> Flush all streaming haptic effects on the different fingers to the Nova 2.0 Glove </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetLastSentForces">
            <summary> Returns the last compiled FFB levels that have made it to the glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.StopHaptics">
            <summary> Shot all haptic feedback effects playing on this device </summary>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.StopVibrations">
            <summary> Stop only all vibrotactile feedback </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Nova.Nova2Glove.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.Nova.Nova2Glove.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0 means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.QueueSqueezeLevel(System.Single)">
            <summary> Set the amount of squeeze-feedback to the desired level (0 = no squeeze, 1 = full squeeze). </summary>
            <param name="squeezeLevel01"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.StopSqueezeFeedback">
            <summary> Immedeately stops the squeeze feedback and any active effects </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.QueueThresholdCmd(SGCore.Finger,System.Single)">
            <summary> Queue a command to autmatically engage a finger's Force-Feedback when the sensor value exceeds a set threshold. </summary>
            <param name="sensorValueThreshold"></param>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.QueueClearThreshold(SGCore.Finger)">
            <summary> Queue a command to clear the threshold for a specific finger. </summary>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.QueueClearThresholds">
            <summary> Queue a command to clear the thresholds for each finger. </summary>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.QueueThresholdCmd_Flexion(SGCore.Finger,System.Single)">
            <summary> Stops the glove when flexing pas this point. </summary>
            <param name="finger"></param>
            <param name="flexionThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.QueueThresholdCmd_Flexions(System.Boolean[],System.Single[])">
            <summary> Queue a command for all of the fingers. When thresholdsActive is false, we turn off the thresholds for that finger </summary>
            <param name="thresholdsActive"></param>
            <param name="flexionThresholds"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.FlexionToThreshold(System.Single,SGCore.Finger)">
            <summary> Nova-Specific. Take a Flexion value and convert it into raw ADC values. </summary>
            <param name="flexion"></param>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.FlexionToThreshold(System.Single,SGCore.Finger,SGCore.Kinematics.HandInterpolator)">
            <summary> Converts a flexion value [0..1] to a raw adv value, based on a HandInterpolator + movement. </summary>
            <param name="flexion"></param>
            <param name="finger"></param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.SupportsCustomWaveform(SGCore.HapticLocation)">
            <summary> Returns true if this Glove supports the chosen haptic location. </summary>
            <param name="atLocation"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.SendCustomWaveform(SGCore.CustomWaveform,SGCore.HapticLocation)">
            <summary> Send a custom waveform to the Nova 2.0 </summary>
            <param name="waveform"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.ToNova2Motor(SGCore.HapticLocation)">
            <summary> Convert a HapticLocation into a Nova 2.0 Motor location </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.SupportsMotor(SGCore.Nova.Nova2Glove.Nova2_VibroMotors)">
            <summary> Returns true if this Nova Glove has access to this specific motor installed. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.ChannelIndex(SGCore.Nova.Nova2Glove.Nova2_VibroMotors)">
            <summary> Returns the channel index for a particular motor. Can make this a s complex as I want for the Nova GLove(s). </summary>
            <param name="motor"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.ValidateWaveform(SGCore.CustomWaveform@,SGCore.Nova.Nova2Glove.Nova2_VibroMotors@)">
            <summary> Ensures the waveform that is to be sent to this Nova Glove has the appropriate parameters. </summary>
            <param name="waveform"></param>
            <param name="motor"></param>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.SendCustomWaveform(SGCore.CustomWaveform,SGCore.Nova.Nova2Glove.Nova2_VibroMotors,System.Boolean)">
            <summary> Directly sends a custom waveform to the Nova Glove. </summary>
            <param name="waveform"></param>
            <param name="motor"></param>
            <param name="validateWaveform"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.SendRawData">
            <summary> Tell the Nova Glove to send Raw Data instead of normalized data. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.SendNormalizedData">
            <summary> Tell the Nova Glove to send normalized data. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.Parse(System.String)">
            <summary> Parse a Nova 2.0 Glove's raw string into an SGDevice for in the DeviceList </summary>
            <param name="cString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetNova2Glove(SGCore.Nova.Nova2Glove@)">
            <summary> Returns the first connected Nova 2.0 Glove, for any hand. </summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetNova2Glove(SGCore.Nova.Nova2Glove@,System.Boolean)">
            <summary> Returns the first connected glove for a specific hand. </summary>
            <param name="glove"></param>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2Glove.GetNova2Gloves">
            <summary> Returns a list of all connected Nova 2.0 gloves. </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Nova.NormalizationState">
            <summary> State of the Nova's sensor Normalization.  </summary>
        </member>
        <member name="F:SGCore.Nova.NormalizationState.Unknown">
            <summary> Unable to retrieve the state out of our Sensor Data :( </summary>
        </member>
        <member name="F:SGCore.Nova.NormalizationState.SendingRawData">
            <summary> Developer has asked the glove to send raw data. So  </summary>
        </member>
        <member name="F:SGCore.Nova.NormalizationState.Normalizing_MoveFingers">
            <summary> The glove is currently normalzing, but the fingers haven't moved enough. </summary>
        </member>
        <member name="F:SGCore.Nova.NormalizationState.Normalizing_AwaitConfirm">
            <summary> Fires when all fingers have moved enough and you _could_ stop normalization collection. </summary>
        </member>
        <member name="F:SGCore.Nova.NormalizationState.NormalizationFinished">
            <summary> Normalization is completed. The user  </summary>
        </member>
        <member name="T:SGCore.Nova.Nova2_SensorData">
            <summary> Nova Glove 2.0 Sensor data, which had additional feedback and calibration parameters </summary>
        </member>
        <member name="T:SGCore.Nova.Nova2_SensorData.SensorLocation">
            <summary> Used to access a sensor Movement of the Nova_SensorData class. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2_SensorData.SensorLocation.Abduction">
            <summary> Sideways motion; finger splay, movind the thumb away from the hand palm </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2_SensorData.SensorLocation.Flexion_Proximal">
            <summary> Flexion of any sensor close to the thumb. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova2_SensorData.SensorLocation.Flexion_Distal">
            <summary> flexion of any sensor further from the hub. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2_SensorData.SensorState">
            <summary> Sensor Data State based on the internal data... </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2_SensorData.SensorValues">
            <summary> Pronation/Supination, Flexion/Extension and Abduction/Adduction values for each finger. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2_SensorData.IMURotation">
            <summary> Quaternion rotation relative to magnetic north. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2_SensorData.IsCharging">
            <summary> Returns true if this NovaGlove is connected to a power source </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2_SensorData.BatteryLevel">
            <summary> A value between 0..1 that represents the battery level of this Nova Glove (0 .. 100%). Returns -1 if the value wasn't received. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2_SensorData.ParsedValues">
            <summary> The number of values that were parsed from the sensor string. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova2_SensorData.IMUParsed">
            <summary> Whether or not the IMU values were all succesfully parsed. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova2_SensorData.#ctor(SGCore.Nova.NormalizationState,SGCore.Kinematics.Vect3D[][],System.Int32,SGCore.Kinematics.Quat,System.Boolean,System.Single,System.Boolean)">
            <summary>  </summary>
            <param name="normState"></param>
            <param name="values"></param>
            <param name="numberOfVals"></param>
            <param name="imuRot"></param>
            <param name="imuComplete"></param>
            <param name="battLvl"></param>
            <param name="charging"></param>
        </member>
        <member name="M:SGCore.Nova.Nova2_SensorData.Empty">
            <summary> Generates empty data </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2_SensorData.ToString">
            <summary> Create a readable string representation of this Sensor Data </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2_SensorData.Equals(SGCore.Nova.Nova2_SensorData)">
            <summary> Returns true if this sensor data contains the same values as another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2_SensorData.GetSensorValue(SGCore.Finger,SGCore.Nova.Nova2_SensorData.SensorLocation)">
            <summary> Returns the sensor movement of a specific finger. </summary>
            <param name="finger"></param>
            <param name="location"> If a Nova glove has only one flexion sensor, it will return the same value for Flexion_Proximal and Flexion_Distal.</param>
        </member>
        <member name="M:SGCore.Nova.Nova2_SensorData.Parse(System.String,SGCore.Nova.Nova_GloveInfo@)">
            <summary> Parse the bytes as they come in from the device into useable values. </summary>
            <param name="rawData"></param>
            <param name="gloveInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2_SensorData.Serialize">
            <summary> Convert this sensor data into a string so it can be stored on disk. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova2_SensorData.Deserialize(System.String)">
            <summary> Convert this sensor data into ta string representation.  </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Nova.Nova_HapticStream">
            <summary> A buffer to queue and flush Nova commands specifically. Not guarateed to work with other devices. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.FingerForceLevels">
            <summary> The force-feedback levels of each finger that is desired for this frame (0 .. 1). </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.fingerFFBUpdate">
            <summary> Whether or not the finger FFB data has been updated this frame, or if we need to fall back to the 'last command' </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.lastFFBLevels">
            <summary> The last FFB levels that were sent to the glove. Used as a fallback in case there are no updates needed. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.AddForceLevel(System.Int32,System.Single)">
            <summary> Sets the force level for a specific finger in the buffer. </summary>
            <param name="level01"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.StoreLastFFB(System.Single[])">
            <summary> Copy a set of FFB levels into the 'previous command', which will be used as a fallback value in case no change is made to a specific finger. </summary>
            <param name="levels"></param>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.NextThresholdCmd">
            <summary> The Next Threshold command to send next frame. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.lastThresholds">
            <summary> The last sent threshold command. Used to check if an update is required. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.LastThresholdCmd">
            <summary> Access the last sent threshold command. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.GetLastForceLevels">
            <summary> Returns a copy of the last ffb levels compiled / stored in this stream. </summary>
            <returns></returns>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.FingerVibroLevels">
            <summary> The finger vibration levels that are desired for this frame. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.fingerVibroUpdate">
            <summary> whether or not there have been updates to the finger vibration this frame </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.lastVibroLevels">
            <summary> The last vibro that were sent to the glove. Used as a fallback when no update is made. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.AddVibrationLevel(System.Int32,System.Single)">
            <summary> Sets the amplitude for a specific finger in the buffer. </summary>
            <param name="amplitude"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.StoreLastVibro(System.Single[])">
            <summary> Copy a set of amplitiudes into the 'previous command', which will be used as a fallback value in case no change is made to a specific finger. </summary>
            <param name="levels"></param>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.WristVibroLevel">
            <summary> The desired Thumper vibration level for this frame </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.wristVibroUpdate">
            <summary> Whether or not a thumper command was sent this frame </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.lastWristLevel">
            <summary> The last vibro that were sent to the glove. Used as a fallback in case there isn't anything sent this frame </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.AddWristCommand(System.Single)">
            <summary> Sets the Latest Wrist Level to a desired level </summary>
            <param name="amplitude"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.StoreLastWrist(System.Single)">
            <summary> Copy an amplitiude into the 'previous command', which will be used as a fallback value in case no change is made to the wrist. </summary>
            <param name="wrist"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.ClearWristCommands">
            <summary> Clear the wrist command </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.#ctor">
            <summary> Create a new Nova HapticStream </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.CompileTraditionalCommands(System.Single[]@,System.Single[]@,System.Single@)">
            <summary> Compile the commands into a set of traditional Nova Commands. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.ClearAllCommands">
            <summary> Clears any active command(s) on the Nova Glove, completely resetting the stream. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.ResetBuffer">
            <summary> Removes all non-active or elapsed Nova effects from the stream, ready for the next frame. </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_HapticEncoder">
            <summary> Non-exposed class that converts command classes into encoded strings. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticEncoder.RepeatByte(System.Int32,System.Boolean)">
            <summary> Encode a 'repeat' byte based on the amount of times someone wants to repeat it, vs whether or not its set to infinite. </summary>
            <param name="repeatAmout"></param>
            <param name="infinite"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticEncoder.ToNovaCommand(SGCore.CustomWaveform,System.Int32)">
            <summary> Encodes the values of a CustomWaveform into a command that can be sent to the Nova Glove. </summary>
            <param name="waveform"></param>
            <param name="motor"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticEncoder.DecodeWaveform(System.String,SGCore.CustomWaveform@,System.Int32@)">
            <summary> Decode a command back into a waveform (though it won't be exactly the same due to the resolution of said encoding). </summary>
            <param name="command"></param>
            <param name="waveform"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Nova.NovaGlove">
            <summary> A soft glove with detachable force-feedback and sensor module. </summary>
        </member>
        <member name="T:SGCore.Nova.NovaGlove.Nova_VibroMotor">
            <summary> Specific vibration motor location(s) for the Nova's </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.Nova_VibroMotor.Unknown">
            <summary> Not sure which motor to send this to. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.Nova_VibroMotor.BackOfHand">
            <summary> Vibration motor located at the back of the hand. A.k.a. "The Thumper" </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.Nova_VibroMotor.ThumbTip">
            <summary> Vibration motor located at the tip of the thumb </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.Nova_VibroMotor.IndexFingerTip">
            <summary> Vibration motor located at the tip of the index finger </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.hapticsByte">
            <summary> Byte indicating a new Sense Glove haptic command. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.gloveInfo">
            <summary> Contains Nova-specific device information. Contained inside its own class. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.hapticStream">
            <summary> Special Nova Haptic Stream to buffer commands. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.lastTraditionalCmd">
            <summary> Used to more eaailty detect change in setting FFB / vibro command. </summary>
        </member>
        <member name="P:SGCore.Nova.NovaGlove.SupportsThresholds">
            <summary> If true, this Nova Glove supports sending special firmware commands to lock brakes at specific sensor values. </summary>
            <remarks> Defined here because 1) we only need to know this once, and 2) support is not only dependent on hardware, but also on the channels detected in the software's IPC </remarks>
        </member>
        <member name="P:SGCore.Nova.NovaGlove.SupportsCustomWaveforms">
            <summary> If true, this Nova Glove supports sending custom 'fire-and-forget' waveforms, </summary>
            <remarks> Defined here because 1) we only need to know this once, and 2) support is not only dependent on hardware, but also on the channels detected in the software's IPC </remarks>
        </member>
        <member name="P:SGCore.Nova.NovaGlove.OnBoardNormalization">
            <summary> If true, this glove's sesnor calibration runs on board the device. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.sensorMovementRanges">
            <summary> The movement ranges of each sensor that allow from movement. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.sensorNormalizer">
            <summary> Normalization for senor inputs. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.abductionMoving">
            <summary> If set to true, we've recognized that abduction is currently moving. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.confirmCalibration">
            <summary> If true, the calibration is currently being confirmed. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.endCalibrationTime">
            <summary> The time for which one needs to hold a thumbs up. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.startConfirmTime">
            <summary> Time that we've started confirming the calibration. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.LockCalibrationInternal">
            <summary> A way to enable / disable internal calibration confirmation. If false, the glove will never 'lock' in values with a thumb up. </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.#ctor(SGCore.Nova.Nova_GloveInfo)">
            <summary> Create a new instance of a Nova Glove that is not yet linked  viaIPC. </summary>
            <param name="deviceInfo"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SetHapticChannels(SGCore.HapticChannelInfo)">
            <summary> Re-evaluate the support for additional functions after this is assigned. </summary>
            <param name="channels"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToString">
            <summary> Returns this Nova's DeviceID. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetDeviceID">
            <summary> Returns this Nova Glove's DeviceID, a.k.a. it's unique serial number. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetFirmwareVersion">
            <summary> Returns the main firmware version of this Nova. (ex: v4.2 -> 4) </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetSubFirmwareVersion">
            <summary> Returns the sub-firmware version of this Nova. (ex: v4.2 -> 2) </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetHardwareVersion">
            <summary> Returns the hardware (sub) identifier of this Nova Glove; "1.0, 1.1, 1.X". Used to filter for glove functions. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetDeviceType">
            <summary> Return the SGCore deviceType wihtout having to cast. Used to deterime which icons to show, etc. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.HasBattery">
            <summary> Returns true if this device operates on a battery </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.IsCharging">
            <summary> Returns true if this device is currently charging </summary>
            <returns> </returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetBatteryLevel(System.Single@)">
            <summary> Returns the device's battery level, as a value between 0 (empty) and 1 (full). </summary>
            <param name="battLvl"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.IsRight">
            <summary> Returns true if this Nova Glove is made for the right hand. If false, it's a left hand. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetGloveModel">
            <summary> Access DeviceInfo of this Nova </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.NormalizationOnGlove">
            <summary> Returns true if this Nova Glove requires Normalization on the glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetSensorData(SGCore.Nova.Nova_SensorData@)">
            <summary> Get the latest Sensor Data from this Sense Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetIMURotation(SGCore.Kinematics.Quat@)">
            <summary> Retrieve Nova rotation </summary>
            <param name="IMU"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetCalibrationState">
            <summary> Retrieve the calilbration status of this Nova Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.TryLoadProfile">
            <summary> Attempt to load a HapticGlove Profile from disk, if one exists. </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToNormalizedValues(SGCore.Nova.Nova_SensorData)">
            <summary> Converts Nova_Sensor Data into floating point inputs for normalization. </summary>
            <param name="sensorData"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetNormalizedInput(System.Single[]@)">
            <summary> Returns the normalized Sensor Data of this Nova Glove. If no normalization is running on the glove(s), then it's done on the PC side. </summary>
            <param name="normalizedValues"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetHandAngles(SGCore.Kinematics.Vect3D[][]@)">
            <summary> Returns the Hand Angles calculated by this Nova Glove. Used for input for HandPoses, but can be used in and of itself. </summary>
            <param name="handAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalculateHandAngles(System.Single[],SGCore.Kinematics.HandInterpolator)">
            <summary> Calculate Hand Angles for a Nova 2.0 Glove, based on normalized input. </summary>
            <param name="normalizedValues"></param>
            <param name="interpolator"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Calculate a HandPose from this glove's latest Sensor Data </summary>
            <param name="handGeometry"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToNormalizedAngles(System.Single[],SGCore.Nova.Nova_GloveInfo@)">
            <summary> Convert normalized inputs (5-6 sensors) to input for an Interpolator. </summary>
            <param name="normalizedData"></param>
            <param name="gloveInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetMinimalSensorMovement">
            <summary> Retireve the minimum sensor ranges for a Nova Glove's Raw ADC values. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToNormalizedValues(SGCore.Nova.Nova_SensorData,SGCore.Util.SensorNormalization)">
            <summary> Convert Sensor Data into a series of normalized values. </summary>
            <param name="sData"></param>
            <param name="sensorNormalizer"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetSensorNormalizer">
            <summary> Access this Glove's Sensor Normalizer. Only edit this when you know what you're doing! </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SetSensorNormalizer(SGCore.Util.SensorNormalization)">
            <summary> If settings match, set the SensorNormalizer for this Nova Glove manually. </summary>
            <param name="newNormalizer"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.StopHaptics">
            <summary> End all haptic effects on the SenseGlove, at the end of your simulation. </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.StopVibrations">
            <summary> Stops all vibrotactile actuators on the Nova Glove, but does not affect the force-feedback. </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToNovaCommand(System.Single[],System.Single[],System.Single)">
            <summary> Converts a set of commands into a series of bytes (string) this glove can understand. </summary>
            <param name="ffbLevels">Force-Feedback levels for each finger</param>
            <param name="buzzLevels">Vibration levels for each finger</param>
            <param name="wristLevel">Value between 0 and 1 for the wirst amplitude to set</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToNovaCommand(SGCore.Haptics.ThresholdCommand)">
            <summary> Converts a Threshold command into a Nova Glove command. </summary>
            <param name="thresholds"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucessfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetLastSentForces">
            <summary> Returns the last compiled FFB levels that have made it to the glove. </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Nova.NovaGlove.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.Nova.NovaGlove.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0 means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Nova.NovaGlove.QueueVibroLevels(System.Single[])" -->
        <member name="M:SGCore.Nova.NovaGlove.QueueVibroLevel(SGCore.Finger,System.Single)">
            <summary> Queue a command to set the vibration amplitude of a particular finger to a specific level </summary>
            <param name="amplitude"> Value will be clamped between [0...1], where 0.0 means no vibration, and 1.0 means full vibration. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <remarks> Devices that 'only' have on/off vibration control will treat any value > 0.0 as 1.0. </remarks>
            <returns>Returns true if the command was sucessfully added to the queue. If false, the device might not support the chosen finger(s) or have the appropriate firmware.</returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueVibroLevel(SGCore.HapticLocation,System.Single)">
            <summary> More Generic Approach for HapticLocation. Only for nova 1. </summary>
            <param name="location"></param>
            <param name="amplitude"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueWristLevel(System.Single)">
            <summary> Queue a command to the vibration amplitude of a general wrist actuator to a set level.  </summary>
            <param name="amplitude"> The amplitude of the wrist vibration, where 0.0 means no vibration, and 1.0 means full vibration. </param>
            <returns> Returns true if the wrist command has been sucesfully queued. If false, the device might not support direct wrist control or have the appropriate firmware.  </returns>
            <remarks> This one isn't contained in an interface as it's not used outside of the NovaGlove class. </remarks>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueThresholdCmd(SGCore.Finger,System.Single)">
            <summary> Queue a command to autmatically engage a finger's Force-Feedback when the sensor value exceeds a set threshold. </summary>
            <param name="sensorValueThreshold"></param>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueClearThreshold(SGCore.Finger)">
            <summary> Queue a command to clear the threshold for a specific finger. </summary>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueClearThresholds">
            <summary> Queue a command to clear the thresholds for each finger. </summary>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueThresholdCmd_Flexion(SGCore.Finger,System.Single)">
            <summary> Stops the glove when flexing pas this point. </summary>
            <param name="finger"></param>
            <param name="flexionThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueThresholdCmd_Flexions(System.Boolean[],System.Single[])">
            <summary> Queue a command for all of the fingers. When thresholdsActive is false, we turn off the thresholds for that finger </summary>
            <param name="thresholdsActive"></param>
            <param name="flexionThresholds"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.FlexionToThreshold(System.Single,SGCore.Finger)">
            <summary> Nova-Specific. Take a Flexion value and convert it into raw ADC values. </summary>
            <param name="flexion"></param>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.FlexionToThreshold(System.Single,SGCore.Finger,SGCore.Util.SensorNormalization)">
            <summary> Converts a flexion value [0..1] to a raw adv value, based on a HandInterpolator + movement. </summary>
            <param name="flexion"></param>
            <param name="finger"></param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SupportsCustomWaveform(SGCore.HapticLocation)">
            <summary> Retruns true if this Nova Glove supports the chosen waveform </summary>
            <param name="atLocation"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendCustomWaveform(SGCore.CustomWaveform,SGCore.HapticLocation)">
            <summary> Sends a Custom Waveform to this Nova Glove. </summary>
            <param name="waveform"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToNovaMotor(SGCore.HapticLocation)">
            <summary> Convert a Vibration Location into a motor for this Nova Glove. </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SupportsMotor(SGCore.Nova.NovaGlove.Nova_VibroMotor)">
            <summary> Returns true if this Nova Glove has access to this specific motor installed. </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ChannelIndex(SGCore.Nova.NovaGlove.Nova_VibroMotor)">
            <summary> Returns the channel index for a particular motor. Can make this a s complex as I want for the Nova GLove(s). </summary>
            <param name="motor"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ValidateWaveform(SGCore.CustomWaveform@,SGCore.Nova.NovaGlove.Nova_VibroMotor@)">
            <summary> Ensures the waveform that is to be sent to this Nova Glove has the appropriate parameters. </summary>
            <param name="waveform"></param>
            <param name="motor"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendCustomWaveform(SGCore.CustomWaveform,SGCore.Nova.NovaGlove.Nova_VibroMotor,System.Boolean)">
            <summary> Directly sends a custom waveform to the Nova Glove. </summary>
            <param name="waveform"></param>
            <param name="motor"></param>
            <param name="validateWaveform"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.Parse(System.String)">
            <summary> Deserializes a Sense Glove from its CString. Returns a nullptr if unsuccesful. </summary>
             <param name="cString"></param>
             <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetCalibrationInstruction">
            <summary> Returns the current Calibration Instructions </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.EndCalibration">
            <summary> End Calibration when we detect a thumbs up in finger movement for enough time </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ResetCalibration">
            <summary> Reset calibration for the sensors, and on the glove if it's running there... </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the Nova.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalculateGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location without requiring an object reference.. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="rightHand">Whether or not this is a left or right handed glove.</param>
            <param name="hardwareVersion">Can be left blank for DK 1 offsets</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalculateGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Nova.Nova_GloveInfo,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location without requiring an object reference.. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="gloveInfo">Glove information.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets. </summary>
            <remarks> The simplest interface, using default offsets </remarks>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalculateWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Nova.Nova_GloveInfo,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets, without needing an object reference. </summary>
            <remarks> The simplest interface, using default offsets </remarks>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="gloveInfo">Whether this is right or left hand</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetNovaGlove(System.Boolean,SGCore.Nova.NovaGlove@)">
            <summary> Retrieve the first connected Nova Glove, for a specific hand. </summary>
            <param name="rightHand"></param>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetNovaGlove(SGCore.Nova.NovaGlove@)">
            <summary> Retrieve the first connected Nova Glove</summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetNovaGloves">
            <summary> Returns a list of all connected Nova Gloves. </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Nova.Nova_GloveInfo">
            <summary> Contains Information on the Nova Glove. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_GloveInfo.IsRight">
            <summary> Determines if this is a right-handed Nova. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_GloveInfo.ImuCorrection">
            <summary> The IMU correction of this Nova. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_GloveInfo.Equals(SGCore.Nova.Nova_GloveInfo)">
            <summary> Returns true if one Nova has the same properties as another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="F:SGCore.Nova.Parsing.Nova_CVar.AllC">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_SensorData">
            <summary> Sensor Data coming from a Nova Glove, converted into useful values. </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_SensorData.SensorLocation">
            <summary> Used to access a sensor Movement of the Nova_SensorData class. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_SensorData.SensorLocation.Abduction">
            <summary> Sideways motion; finger splay, movind the thumb away from the hand palm </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_SensorData.SensorLocation.Flexion">
            <summary> Flexion of any sensor </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_SensorData.NovaData">
            <summary> Enumerators for Nova Data position in the parseable string. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.SensorState">
            <summary> Sensor Data State that determines on-board calibration state </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.SensorValues">
            <summary> Pronation/Supination, Flexion/Extension and Abduction/Adduction values for each finger. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.IMURotation">
            <summary> Quaternion rotation relative to magnetic north. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.ParsedValues">
            <summary> The number of values that were parsed from the sensor string. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.IMUParsed">
            <summary> Whether or not the IMU values were all succesfully parsed. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.IsCharging">
            <summary> Returns true if this NovaGlove is connected to a power source </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.BatteryLevel">
            <summary> A value between 0..1 that represents the battery level of this Nova Glove (0 .. 100%). Returns -1 if the value wasn't received. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.#ctor(SGCore.Nova.NormalizationState,SGCore.Kinematics.Vect3D[],System.Int32,SGCore.Kinematics.Quat,System.Boolean,System.Single,System.Boolean)">
            <summary>  </summary>
            <param name="sensorState"></param>
            <param name="values"></param>
            <param name="numberOfVals"></param>
            <param name="imuRot"></param>
            <param name="imuComplete"></param>
            <param name="battLvl"></param>
            <param name="charging"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Empty">
            <summary> Generates empty data </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.ToString">
            <summary> Create a readable string representation of this Sensor Data </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Equals(SGCore.Nova.Nova_SensorData)">
            <summary> Returns true if this sensor data contains the same values as another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.GetSensorValue(SGCore.Finger,SGCore.Nova.Nova_SensorData.SensorLocation)">
            <summary> Returns the sensor movement of a specific finger. </summary>
            <param name="finger"></param>
            <param name="location"> If a Nova glove has only one flexion sensor, it will return the same value for Flexion_Proximal and Flexion_Distal.</param>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Parse(System.String,SGCore.Nova.Nova_GloveInfo@)">
            <summary> Parse the bytes as they come in from the device into useable values. </summary>
            <param name="rawData"></param>
            <param name="gloveInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Serialize">
            <summary> Convert this sensor data into a string so it can be stored on disk. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Deserialize(System.String)">
            <summary> Convert this sensor data into ta string representation.  </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SG.SG_HapticStream">
            <summary> A buffer to queue and flush SenseGlove DK1 commands specifically. Not guarateed to work with other devices. </summary>
        </member>
        <member name="P:SGCore.SG.SG_HapticStream.FingerForceLevels">
            <summary> The force-feedback levels of each finger that is desired for this frame (0 .. 1). </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticStream.fingerFFBUpdate">
            <summary> Whether or not the finger FFB data has been updated this frame, or if we need to fall back to the 'last command' </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticStream.lastFFBLevels">
            <summary> The last FFB levels that were sent to the glove. Used as a fallback in case there are no updates needed. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.AddForceLevel(System.Int32,System.Single)">
            <summary> Sets the force level for a specific finger in the buffer. </summary>
            <param name="level01"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.StoreLastFFB(System.Single[])">
            <summary> Copy a set of FFB levels into the 'previous command', which will be used as a fallback value in case no change is made to a specific finger. </summary>
            <param name="levels"></param>
        </member>
        <member name="P:SGCore.SG.SG_HapticStream.FingerVibroLevels">
            <summary> The finger vibration levels that are desired for this frame. </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticStream.fingerVibroUpdate">
            <summary> whether or not there have been updates to the finger vibration this frame </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticStream.lastVibroLevels">
            <summary> The last vibro that were sent to the glove. Used as a fallback when no update is made. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.AddVibrationLevel(System.Int32,System.Single)">
            <summary> Sets the amplitude for a specific finger in the buffer. </summary>
            <param name="amplitude"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.StoreLastVibro(System.Single[])">
            <summary> Copy a set of amplitiudes into the 'previous command', which will be used as a fallback value in case no change is made to a specific finger. </summary>
            <param name="levels"></param>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.#ctor">
            <summary> Create a new Nova HapticStream </summary>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.CompileTraditionalCommands(System.Single[]@,System.Single[]@,SGCore.SG.SG_ThumperCmd@)">
            <summary> Compile the commands into a set of traditional Nova Commands. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.ClearAllCommands">
            <summary> Clears any active command(s) on the Nova Glove, completely resetting the stream. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.ResetBuffer">
            <summary> Removes all non-active or elapsed Nova effects from the stream, ready for the next frame. </summary>
        </member>
        <member name="T:SGCore.SG.SG_SensorNormalizer">
            <summary> Acts as a sort of 'in between' handProfile. This class converts SG Dk1 Angles into 'normalized data' - between 0 .. 1. </summary>
        </member>
        <member name="F:SGCore.SG.SG_SensorNormalizer.flexionNormalizers">
            <summary> Interpolation for Finger Flexions </summary>
        </member>
        <member name="F:SGCore.SG.SG_SensorNormalizer.abductionNormalizers">
            <summary> Interpolation for Finger Abductions </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorNormalizer.#ctor(System.Boolean)">
            <summary> Creates a new SenseGlove Sensor Normalizer based off the device's sensor angles. </summary>
            <param name="rightHand"></param>
        </member>
        <member name="M:SGCore.SG.SG_SensorNormalizer.NormalizeFlexion(System.Int32,System.Single)">
            <summary> Normalize a finger's flexion, based on the total flexion of the exoskeleton </summary>
            <param name="finger"></param>
            <param name="sumFlexAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_SensorNormalizer.NormalizeAbduction(System.Int32,System.Single)">
            <summary> Normalize a finger's abduction, based on the total abduction of the exoskeleton>  </summary>
            <param name="finger"></param>
            <param name="sumAbdAngles"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SG.SG_FingerSolver">
            <summary> How this Sense Glove converts sensor data into a HandPose. </summary>
        </member>
        <member name="F:SGCore.SG.SG_FingerSolver.Interpolation">
            <summary> Hand angles are interpolated based on the total flexion / abduction of the exoskeleton </summary>
        </member>
        <member name="T:SGCore.SG.SG_ThumbSolver">
            <summary> How this Sense Glove converts sensor data into a HandPose. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumbSolver.Interpolation">
            <summary> Hand angles are interpolated based on the total flexion / abduction of the exoskeleton </summary>
        </member>
        <member name="T:SGCore.SG.SG_ThumperCmd">
            <summary> A command to activate the Sense Glove Thumper Module, which is responsible for wrist feedback. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.None">
            <summary> We don't want the thumper to do anything right now... </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.TurnOff">
            <summary> Turn off the thumper effects. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Cue_Game_Over">
            <summary> A 5-second long, constant vibration. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Button_Double_100">
            <summary> A double-click at 100% intensity. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Button_Double_60">
            <summary> A double click at 60% intensity. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Impact_Thump_100">
            <summary> Simulates an impact of the hand at 100% intensity. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Impact_Thump_30">
            <summary> Simulates an impact of the hand at 30% intensity. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Impact_Thump_10">
            <summary> Simulates an sharp impact of the hand at 40% intensity. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Object_Grasp_100">
            <summary> A light vibration to cue the user that an object it picked up. 100% intensity. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Object_Grasp_60">
            <summary> A light vibration to cue the user that an object it picked up. 60% intensity. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumperCmd.Object_Grasp_30">
            <summary> A light vibration to cue the user that an object it picked up. 30% intensity. </summary>
        </member>
        <member name="T:SGCore.SG.SenseGlove">
            <summary> Interface for the Sense Glove; and exoskeleton Force-Feedback glove. </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.gloveModel">
            <summary> Contains all data regarding this Sense Glove </summary>
            <remarks> 
            We're not using a generic DeviceModel as that would require casting
            its DeviceModel to an SGModel each frame. Adding this interface here is faster
            </remarks>
        </member>
        <member name="F:SGCore.SG.SenseGlove.hapticsByte">
            <summary> Byte indicating a new Sense Glove haptic command. </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.thumperByte">
            <summary> Byte indicating a new Thumper command. </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.hapticStream">
            <summary> Buffer to keep track of all incoming commands </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.lastHapticCmd">
            <summary> Used to check for a difference. </summary>
        </member>
        <member name="P:SGCore.SG.SenseGlove.ThumbSolver">
            <summary> The Solver used for the Thumb </summary>
        </member>
        <member name="P:SGCore.SG.SenseGlove.FingerSolver">
            <summary> The Solver used by the Finger </summary>
        </member>
        <member name="P:SGCore.SG.SenseGlove.FingerThimbleOffsets">
            <summary> Offset from thimble to fingertip, used for Inverse Kinematics. </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.dThimbleOffset">
            <summary> Default offset from thimble to fingertip. </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.gloveAngleNormalizer">
            <summary> Converts glove angles into 0 .. 1 input for gestures and for hand angle solving. </summary>
        </member>
        <member name="P:SGCore.SG.SenseGlove.GloveAngleNormalization">
            <summary> Values used in Glove Angle normalization. </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.#ctor(SGCore.SG.SG_GloveInfo)">
            <summary> Create a new instance of a Sense Glove. </summary>
            <param name="myModel"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetDeviceType">
            <summary> Get the DeviceType enumerator of this SenseGlove, used in DeviceList enumeration. </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetDeviceID">
            <summary> Retrieve this Sense Glove's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetHardwareVersion">
            <summary> Retrieve thisglove's hardware (sub) version.  </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetFirmwareVersion">
            <summary> Retrieve this device's firmware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSubFirmwareVersion">
            <summary> Retrieve this device's sub-firmware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.IsRight">
            <summary> Check if this Sense Glove is right handed. </summary>
            <remarks> While the variable is stored in SG_GloveModel, added direct access here since its frequently used. </remarks>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGloveModel">
            <summary> Retrieve this glove's hardware model, which contains its hardware data. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.ToString">
            <summary> Create a string representation of this device for reporting purposes. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSensorData(SGCore.SG.SG_SensorData@)">
            <summary> Get the latest Sensor Data from this Sense Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetIMURotation(SGCore.Kinematics.Quat@)">
            <summary> SenseGlove's IMU Rotation </summary>
            <param name="IMU"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGlovePose(SGCore.SG.SG_GlovePose@)">
            <summary> Get the pose of this Sense Glove's hardware, based on its latest Sensor Data. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGlovePose(SGCore.SG.SG_SensorData,SGCore.SG.SG_GlovePose@)">
            <summary> Get the pose of this Sense Glove's hardware based on a set of Sensor Data. </summary>
            <param name="sData"></param>
            <param name="pose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Retrieve a HandPose </summary>
            <param name="handGeometry"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetHandAngles(SGCore.Kinematics.Vect3D[][]@)">
            <summary> Get the hand angles generated by this SenseGlove DK1 </summary>
            <param name="handAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateHandAngles(SGCore.SG.SG_GlovePose,SGCore.SG.SG_SensorNormalizer,SGCore.Kinematics.HandInterpolator,SGCore.Kinematics.Vect3D[][]@)">
            <summary> Calculate Hand Angles from a GlovePose and relevaent normalizers </summary>
            <param name="glovePose"></param>
            <param name="normalizer"></param>
            <param name="normalizedToAngles"></param>
            <param name="handAngles"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.ToSenseGloveCmd(System.Single[],System.Single[],SGCore.SG.SG_ThumperCmd)">
            <summary> Convert amplitudes into a SenseGlove command </summary>
            <param name="ffbLevels"></param>
            <param name="buzzLevels"></param>
            <param name="thumperCmd"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucessfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="M:SGCore.SG.SenseGlove.StopHaptics">
            <summary> End all haptic effects on the SenseGlove, at the end of your simulation. </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.StopVibrations">
            <summary> Stop all vibrations on the SenseGlove </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.SG.SenseGlove.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.SG.SenseGlove.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0 means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.SG.SenseGlove.QueueVibroLevels(System.Single[])" -->
        <member name="M:SGCore.SG.SenseGlove.QueueVibroLevel(SGCore.Finger,System.Single)">
            <summary> Queue a command to set the vibration amplitude of a particular finger to a specific level </summary>
            <param name="amplitude"> Value will be clamped between [0...1], where 0.0 means no vibration, and 1.0 means full vibration. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <remarks> Devices that 'only' have on/off vibration control will treat any value > 0.0 as 1.0. </remarks>
            <returns>Returns true if the command was sucessfully added to the queue. If false, the device might not support the chosen finger(s) or have the appropriate firmware.</returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.QueueVibroLevel(SGCore.HapticLocation,System.Single)">
            <summary> More Generic Approach for HapticLocation. </summary>
            <param name="location"></param>
            <param name="amplitude"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SupportsWristActuator">
            <summary> Returns tru if this device support wrist actuation </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.QueueWristCommand(SGCore.SG.SG_ThumperCmd)">
            <summary> Queue a command to the wrist actuator, a.k.a. the Thumper. These effects are hard-coded on the driver. </summary>
            <param name="effectToPlay"> The Thumper effect to play. </param>
            <returns> Returns true if the wrist command has been sucesfully queued. If false, the device might not support direct wrist control or have the appropriate firmware.  </returns>
            <remarks> This one isn't contained in an interface as it's not used outside of the SenseGlove class. </remarks>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SupportsCustomWaveform(SGCore.HapticLocation)">
            <summary> Retruns true if this glove supports a custom vibration at said location. </summary>
            <param name="atLocation"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetCalibrationState">
            <summary> Returns Haptic Glove Calibration State. It's always locked for now, since it's based on interpolation of absolute values. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateGlovePose(SGCore.SG.SG_SensorData,SGCore.SG.SG_GloveInfo)">
            <summary> Calculates a GlovePose based on gloveAngles and a glove model. </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateGlovePose(SGCore.Kinematics.Vect3D[][],SGCore.SG.SG_GloveInfo)">
            <summary> Calculates a GlovePose based on gloveAngles and a glove model. </summary>
            <remarks> Use this when you already have gloveAngles collected </remarks>
            <param name="gloveAngles"></param>
            <param name="gloveModel"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetNormalizedValues(System.Single[]@,System.Single[]@)">
            <summary> Retrieve this Glove's Normalized Angles </summary>
            <param name="flexions"></param>
            <param name="abductions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.NormalizeValues(SGCore.Kinematics.Vect3D[],SGCore.SG.SG_SensorNormalizer,System.Single[]@,System.Single[]@)">
            <summary> Returns normalized flexions and abductions. </summary>
            <param name="sumAngles"></param>
            <param name="normalizer"></param>
            <param name="flexions"></param>
            <param name="abductions"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateHandPose(SGCore.SG.SG_GlovePose,SGCore.Kinematics.BasicHandModel,SGCore.SG.SG_SensorNormalizer,SGCore.Kinematics.HandInterpolator)">
            <summary> Calculate a HandPose based on a glovePose and a solver. </summary>
            <remarks> Use this when you already have a GlovePose </remarks>
            <param name="glovePose"></param>
            <param name="handModel"></param>
            <param name="normalizer"></param>
            <param name="normalizedToAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.Parse(System.String)">
            <summary> Deserializes a Sense Glove from its CString. Returns a nullptr if unsuccesful. </summary>
             <param name="cString"></param>
             <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSenseGloves(System.Boolean)">
            <summary> Retrieve all connected Sense Gloves. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSenseGlove(SGCore.SG.SenseGlove@)">
            <summary> Retrieve the first connected Sense Glove connected to this System </summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSenseGlove(System.Boolean,SGCore.SGDevice@)">
            <summary> Retrieve the first (connected) right- or left handed sense glove as an abstract SGDevice. </summary>
            <param name="rightHanded"></param>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSenseGlove(System.Boolean,SGCore.SG.SenseGlove@)">
            <summary> Retrieve the first (connected) right- or left handed sense glove. </summary>
            <param name="rightHanded"></param>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,System.Boolean,SGCore.Finger,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location without requiring an object reference.. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="rightHand">Whether or not this is a left or right handed glove.</param>
            <param name="mountedOn">Which finger module the hardware is mounted on. Default is Middle finger.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,System.Boolean,SGCore.Finger,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location without requiring an object reference.. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="rightHand">Whether or not this is a left or right handed glove.</param>
            <param name="mountedOn">Which finger module the hardware is mounted on. Default is Middle finger.</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
            <param name="gloveWristOffPos"></param>
            <param name="gloveWristOffRot"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Finger,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="mountedOn">Which finger module the hardware is mounted on.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets. </summary>
            <remarks> The simplest interface, using default offsets </remarks>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets. </summary>
            <param name="refPosition"></param>
            <param name="refRotation"></param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="gloveWristOffPos">Position offset, in mm, from the glove origin to wrist (default = 0,0,-30 mm)</param>
            <param name="gloveWristOffRot">Rotation offset from the glove origin to wrist (default = 0,-5,0 degrees)</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="T:SGCore.SG.SG_GlovePose">
            <summary> Represents a pose of a Sense Glove exoskeleton. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.JointPositions">
            <summary> Positions of each glove joint, relative to the Glove's Origin. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.JointRotations">
            <summary> Quaternion rotation of each glove joint, relative to the Glove Origin. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.GloveAngles">
            <summary> Glove joint angles in euler notation, relative to the last segment. </summary>
            <remarks> Essentially sensor angles, though placed in their proper xyz notation </remarks>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.IsRight">
            <summary> Determines if this GlovePose was created for a left- or right hand. </summary>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.#ctor(System.Boolean,SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Quat[][],SGCore.Kinematics.Vect3D[][])">
            <summary> Creates a new instance of a SG_GlovePose </summary>
            <param name="right"></param>
            <param name="positions"></param>
            <param name="rotations"></param>
            <param name="jointAngles"></param>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.IdlePose(SGCore.SG.SG_GloveInfo)">
            <summary> Returns an idle pose for the Sense Glove if no data can be found. </summary>
            <param name="glove"> The glove model to use for the idle position. </param>
            <returns></returns>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.ThimblePositions">
            <summary> The position of the tip of the 'thimbles', the furthest link on each glove link. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.ThimbleRotations">
            <summary> The (quaternion) rotation of the 'thimbles', the furthest link on each link.  </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.TotalGloveAngles">
            <summary> Sum of the Sensor angles in each (xyz) direction. "Total Pronation / Flexion / Abduction" </summary>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.CalculateFingerTips(SGCore.Kinematics.Vect3D[])">
            <summary> Calculate fingertip positions, knowing the offset between thimble and fingertips. </summary>
            <param name="fingerOffsets"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.Equals(SGCore.SG.SG_GlovePose)">
            <summary> Returns true if this GlovePOse equals another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.Serialize">
            <summary> Convert a GlovePose into a string that can be unpacked later </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.Deserialize(System.String)">
            <summary> Convert a serialized SG_GlovePose back into a useable class. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SG.SG_Functions">
            <summary> Functions that a Sense Glove cound have. </summary>
        </member>
        <member name="F:SGCore.SG.SG_Functions.SG_BuzzMotors">
            <summary> Vibration Motors to send haptic pulses to individual fingers  </summary>
        </member>
        <member name="F:SGCore.SG.SG_Functions.SG_ForceFeedback">
            <summary> Brakes which can inhibit grasping motions to create force feedback. </summary>
        </member>
        <member name="F:SGCore.SG.SG_Functions.SG_Thumper">
            <summary> A Thumper Module for global feedback. </summary>
        </member>
        <member name="F:SGCore.SG.SG_Functions.SG_AllFunctions">
            <summary> Utility value used for enumeration. It can also be used to check if a Sense Glove has all possible functionalities. </summary>
        </member>
        <member name="T:SGCore.SG.SG_GloveInfo">
            <summary> Contains device information about a Sense Glove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.IsRight">
            <summary> Check if this Sense Glove belongs to a left or right hand. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.NumberOfSensors">
            <summary> The number of Sensors in this SenseGlove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.ImuCorrection">
            <summary> The IMU correction of this Sense Glove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.StartPositions">
            <summary> The starting positions of each Sense Glove finger, relative to the glove origin </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.StartRotations">
            <summary> The starting rotations of each Sense Glove finger, relative to the glove origin </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.GloveLengths">
            <summary> The lengths of each Sense Glove finger section, in mm. </summary>
        </member>
        <member name="F:SGCore.SG.SG_GloveInfo.functions">
            <summary> Whether this device has a specific function (T/F). </summary>
            <remarks> Functions are dependent on Device Type. </remarks>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.#ctor(System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Quat[],SGCore.Kinematics.Vect3D[][],System.Boolean[])">
            <summary> Create a new Sense Glove device model </summary>
            <param name="ID"></param>
            <param name="hwVer"></param>
            <param name="fwVerMain"></param>
            <param name="fwVerSub"></param>
            <param name="rightHand"></param>
            <param name="noSensors"></param>
            <param name="imuCorr"></param>
            <param name="startPos"></param>
            <param name="startRot"></param>
            <param name="lengths"></param>
            <param name="functionality"></param>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.GetStartPosition(SGCore.Finger)">
            <summary> Retrieve the starting position of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.GetStartRotation(SGCore.Finger)">
            <summary> Retrieve the starting rotation of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.GetGloveLengths(SGCore.Finger)">
            <summary> Retrieve the finger section lengths of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.HasFunction(SGCore.SG.SG_Functions)">
            <summary> Check if this Sense Glove has a particular function. </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ToGloveAngles(System.Single[][])">
            <summary> Place incoming sensor data into the right xyz format, according to this glove's model. </summary>
            <param name="sensorAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ToString">
            <summary> Create a string representation for fast logging. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ToString(System.Boolean)">
            <summary> Create a string representation for logging. </summary>
            <param name="shortNotation">If set to false, an more extensive log is created.</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.Serialize">
            <summary> Convert this SG_GloveInfo into a serialized string to use later. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.Deserialize(System.String)">
            <summary> Convert a serialized GloveInfo string back into a SG_GloveInfo class. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.Parse(System.String,SGCore.SG.SG_GloveInfo@,System.Boolean)">
            <summary> Create an instance of the SGModel from its string representation. </summary>
            <param name="cString"></param>
            <param name="model"></param>
            <param name="updateOldModels">if set to true, it will automatically update older glove models to ones measured in CAD.</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ParseLengthString(System.String)">
            <summary> Parse a section of constants into a set of glove lengths. </summary>
            <param name="rawLengths"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ParseStartValues(System.String,SGCore.Kinematics.Vect3D[]@,SGCore.Kinematics.Quat[]@)">
            <summary> Parse a section of constants into a set starting positions and -rotations. </summary>
            <param name="rawValues"></param>
            <param name="startPos"></param>
            <param name="startRot"></param>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.Equals(SGCore.SG.SG_GloveInfo,System.Boolean)">
            <summary> Check if this GloveInfo contains the same data as another. </summary>
            <param name="other"></param>
            <param name="geometryOnly">If set to true, we're only checking if the geometry is the same.</param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SG.SG_SensorData">
            <summary> Processed Sensor Data coming from a Sense Glove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_SensorData.ParsedValues">
            <summary> The total amount of sensor values that were parsed in the string (used to check for validity / sensor placement). </summary>
        </member>
        <member name="P:SGCore.SG.SG_SensorData.SensorAngles">
            <summary> Glove angles in radians, sorted by finger, from proximal to distal </summary>
        </member>
        <member name="P:SGCore.SG.SG_SensorData.ImuValues">
            <summary> Quaternion rotation of the IMU within the Sense Glove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_SensorData.ImuParsed">
            <summary> Whether or not the IMU was properly parsed. </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.#ctor(System.Single[][],SGCore.Kinematics.Quat,System.Int32,System.Boolean)">
            <summary> Create a new instance of a Sense Glove Sensor Data class. </summary>
            <param name="angles"></param>
            <param name="imu"></param>
            <param name="sNumber"></param>
            <param name="imuComplete"></param>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.GetAngles(SGCore.Finger)">
            <summary> Get the glove angles of a specific finger segment </summary>
             <param name="finger"></param>
             <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.GetAngleSequence">
            <summary> Returns all glove angles in a sequence, without splitting them per finger. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.ToString">
            <summary> Retrieve a simple representaton of this sensor data for debugging purposes. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.Parse(System.String,SGCore.SG.SG_GloveInfo)">
            <summary> Deserialize Sense Glove sensor data from a raw char[] recieved through IPC. </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.Empty">
            <summary> Returns sensor data with no values. </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.Serialize">
            <summary> Serialize this HandProfile into a string representation </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.Deserialize(System.String)">
            <summary> Deserialize a HandProfile back into useable values. </summary>
        </member>
        <member name="T:SGCore.Haptics.ThresholdCommand">
            <summary> A command to set thresholds for specific fingers. Can be sent to a Device, or used internally. </summary>
        </member>
        <member name="P:SGCore.Haptics.ThresholdCommand.Thresholds">
            <summary> The Value at which to lock the finger(s), if ActiveFingers is true. </summary>
        </member>
        <member name="P:SGCore.Haptics.ThresholdCommand.ActiveFingers">
            <summary> The fingers that have a Threshold Mode active. If False, no thresholds should be activated. </summary>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.#ctor">
            <summary>  </summary>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.#ctor(System.Boolean[],System.Single[])">
            <summary>  </summary>
            <param name="thresholdValues"></param>
            <param name="affectedFingers"></param>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.#ctor(SGCore.Haptics.ThresholdCommand)">
            <summary> Copies the values of one ThresholdCommand into this Class. </summary>
            <param name="toCopy"></param>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.SetThreshold(System.Int32,System.Single)">
            <summary> Activates the threshold for a finger at a particular value. </summary>
            <param name="finger"></param>
            <param name="thresholdValue"></param>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.GetThreshold(System.Int32)">
            <summary> Retrieve the threshold of a particular finger </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.ClearThreshold(System.Int32)">
            <summary> Deactivates Threshold Mode for a particular finger. </summary>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.ClearThresholds">
            <summary> Disables Threshold mode for all fingers. Clears the ActiveFingers, but keeps the Thresholds value for now, in case you want to re-apply them later. </summary>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.ToString">
            <summary> Print the contents of this Threshold Command. If inactive, a '-' is shown. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCommand.Equals(SGCore.Haptics.ThresholdCommand)">
            <summary> Returns true if both values are exactly equal </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.WaveformType">
            <summary> Waveform type for an advanced Buzz Command </summary>
        </member>
        <member name="F:SGCore.WaveformType.Sine">
            <summary> Smooth sine wave </summary>
        </member>
        <member name="F:SGCore.WaveformType.Square">
            <summary> Can shift duty Cycle </summary>
        </member>
        <member name="F:SGCore.WaveformType.SawUp">
            <summary> Inverse of SawDown  </summary>
        </member>
        <member name="F:SGCore.WaveformType.SawDown">
            <summary> Inverse of SawUp </summary>
        </member>
        <member name="F:SGCore.WaveformType.Triangle">
            <summary> Triangle waveform </summary>
        </member>
        <member name="F:SGCore.WaveformType.Noise">
            <summary> A random, noisy signal </summary>
        </member>
        <member name="T:SGCore.CustomWaveform">
            <summary> Allows for extended vibration commands. Can be applied to any finger, and any actuator, but there is no guarantee the associated actuator will actually do so. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.minAttackTime">
            <summary> The maximum attack time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.maxAttackTime">
            <summary> The maximum attack time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.minSustainTime">
            <summary> The minimum value for sustain time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.maxSustainTime">
            <summary> The maximum sustain time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.minDecayTime">
            <summary> The maximum attack time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.maxDecayTime">
            <summary> The maximum attack time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.freqRangeMin">
            <summary> Minimum Frequency Range </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.freqRangeMax">
            <summary> Maximum Frequency Range </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.maxRepeatAmount">
            <summary> Maximum amount a singnal is allowed to repeat, limited by encoding. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.minAmplitude">
            <summary> The minimum master control 'volume'. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.maxAmplitude">
            <summary> The maximum master control 'volume'. </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.minFreqFactor">
            <summary> Minimum value of minimum frequency factor </summary>
        </member>
        <member name="F:SGCore.CustomWaveform.maxFreqFactor">
            <summary> Maximum value of minimum frequency factor</summary>
        </member>
        <member name="P:SGCore.CustomWaveform.Amplitude">
            <summary> The total amplitude of the wavefrom, represented by 0 (off) or 1 (maximum value) </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.WaveType">
            <summary> The Type of waveform pattern that is used. </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.Infinite">
            <summary> Whether or not this Waveform is infinitely repeating </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.RepeatAmount">
            <summary> The amount of times to repeat this waveform. 1 is the default. If set to 0, repreats indefinitely. </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.AttackTime">
            <summary> Time, in seconds, before the signal reaches its maximum amplitude. Limited to 0.01 - 1s. Set to 0 for an instant start. Linear only </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.SustainTime">
            <summary> Time, in seconds, to keep the signal at one Amplidue. Limited to 0.01 - 1s. </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.DecayTime">
            <summary> Time it takes for the effect to fade out after AttackTime+SuatainTime has passed. Limited to 0.01 - 1s. Set to 0 for instant stop. Linear only </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.FrequencyStart">
            <summary> The Wavefrom Frequency at the start of the wavefrom. Limited between [10 - 500Hz] for Nova Gloves </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.FrequencyEnd">
            <summary> The Frequency at the end of the waveform. Keep the same as FrequencyStart to have one conitnuous frequency.  Limited between [10 - 500Hz] for Nova Gloves </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.FrequencySwitchTime">
            <summary> value of [0..1], repesenting a perentage of total time (attack+sustain+decay). After that moment passes, we increase the frequency by FrequencySwicth factor </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.FrequencySwitchFactor">
            <summary> After a certain % of the waveform (FrequencySwitchTime) plays, multiply the frequency by this factor [1x .. 3x]  </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.EffectTime">
            <summary> The total command time of a single play of this pattern (not taking into account the RepeatAmount). </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.TotalEffectTime">
            <summary> Total time for the entire effect (effecttime multipled by the repeatamount) </summary>
        </member>
        <member name="P:SGCore.CustomWaveform.FrequencyJumps">
            <summary> If true, the frequency of this waveform jumps at any time during its playtime by FrequencySwitchFactor. </summary>
        </member>
        <member name="M:SGCore.CustomWaveform.#ctor">
            <summary> Default constructor with all values set to 0 - even the frequency? </summary>
        </member>
        <member name="M:SGCore.CustomWaveform.#ctor(SGCore.CustomWaveform)">
            <summary> Create a new BuzzCommand with the exact same parameters. </summary>
            <param name="wfToCopy"></param>
        </member>
        <member name="M:SGCore.CustomWaveform.#ctor(System.Single,System.Single)">
            <summary> A basic waveform to vibrate at a specific amplitude for a specific duration  </summary>
            <param name="amplitude"> Should be between 0 (off) and 1 (full vibration force) </param>
            <param name="duration"> A time in seconds, limited from 0 to 1s? </param>
        </member>
        <member name="M:SGCore.CustomWaveform.#ctor(System.Single,System.Single,System.Single)">
            <summary> A basic waveform to vibrate at a specific amplitude for a specific duration  </summary>
            <param name="amplitude"></param>
            <param name="duration"> A time in seconds, limited from 0 to 1s? </param>
            <param name="frequency"> 10 Hz to 510 Hz </param>
        </member>
        <member name="M:SGCore.CustomWaveform.ToString">
            <summary> Create an easy-enough string representation of this custom waveform. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CustomWaveform.Equals(SGCore.CustomWaveform)">
            <summary> Returns true if a Waveform has the exact same parameters as this one. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Diagnostics.DebugLevel">
            <summary> Levels of debugging available from the Sense Glove API. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.Disabled">
            <summary> No debug messages will be sent. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.ErrorsOnly">
            <summary> Send only messages if errors are caught. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.CalibrationMessages">
            <summary> Send messages from calibration algorithms </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.DeviceParsing">
            <summary> Send messages from device Parsing. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.Backend_Communication">
            <summary> Send messages related to backed communications. Mostly relevant when using Ports / Android Strings. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.Haptics_Sent">
            <summary> Which haptics are eventually sent to the glove </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.Haptics_Queue">
            <summary> Which haptics are added into our queue. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.ALL">
            <summary> For those we have no place for yet. </summary>
        </member>
        <member name="T:SGCore.Diagnostics.DebugArgs">
            <summary> Debugging arguments containing the message sent and its level. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugArgs.message">
            <summary> The message sent by the Debugger. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugArgs.debugLv">
            <summary> The Debug level of the accompanying message </summary>
        </member>
        <member name="M:SGCore.Diagnostics.DebugArgs.#ctor(System.String,SGCore.Diagnostics.DebugLevel)">
            <summary> Create a new Instance of DebugArgs. </summary>
            <param name="msg"></param>
            <param name="lv"></param>
        </member>
        <member name="T:SGCore.Diagnostics.Debugger">
            <summary> Singleton class that reports debug messages. Can be subscribed to by other programs. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.Debugger.debugLv">
            <summary> The current debug level of the Sense Glove Debugger. </summary>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.#ctor">
            <summary> Empty Constructor to create the instance. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.Debugger.defaultDebugLvl">
            <summary> The Default debug level for any application </summary>
        </member>
        <member name="F:SGCore.Diagnostics.Debugger.instance">
            <summary> Instance of the Debugger to which events can be subscribed. </summary>
        </member>
        <member name="P:SGCore.Diagnostics.Debugger.Instance">
            <summary> Access the Debugger instance. </summary>
        </member>
        <member name="P:SGCore.Diagnostics.Debugger.DebugLevel">
            <summary> The debug level of the Debugger </summary>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.Log(System.String,SGCore.Diagnostics.DebugLevel)">
            <summary>
            Attempt to post output to the System.Console class. If that fails, try to write to the System.Diagnostics.Debug class.
            </summary>
            <param name="message">The message to write to the user.</param>
            <param name="level"></param>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.SetConnectionLibCollection(System.Boolean)">
            <summary> Enable / Disable debug queueing on the SGConnect library. </summary>
            <param name="active"></param>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.GetConnectionLibMessages(System.String@)">
            <summary> Gte queued messages from the Connection library, provided it is running from this same main thread. </summary>
            <param name="messages"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Diagnostics.Debugger.MessageRecievedEventHandler">
            <summary> Delegate for the DebugMessageRecieved event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SGCore.Diagnostics.Debugger.DebugMessageRecieved">
            <summary> Fires when a new message is recieved by the Debugger. </summary>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.OnMessageRecieved(System.String,SGCore.Diagnostics.DebugLevel)">
            <summary> Constructs DebugArs and Fires the MessageRecieved event. </summary>
            <param name="msg"></param>
            <param name="lvl"></param>
        </member>
        <member name="T:SGCore.DeviceList">
            <summary> Interface for SenseCom, allows the retrieval of Devices and Data. </summary>
        </member>
        <member name="F:SGCore.DeviceList.devices">
            <summary> A list of all devices that have been detected via the SenseComm executable. </summary>
        </member>
        <member name="F:SGCore.DeviceList.connStateDelim">
            <summary> Delimiter for the connection state </summary>
        </member>
        <member name="M:SGCore.DeviceList.ActiveDevices">
            <summary> Retrieve the number of devices that have been detected by the SenseComm executable. </summary>
        </member>
        <member name="M:SGCore.DeviceList.GetDevices">
            <summary> Retrieve all Sense Glove Devices that were once connected to this system. </summary>
        </member>
        <member name="M:SGCore.DeviceList.GetDevices``1">
            <summary> Retrieve a list of SGDevices of a specific class. </summary>
            <typeparam name="T"> Subclass of SGDevice. </typeparam>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.SenseCommRunning">
            <summary> Returns true if the SenseComm program is running. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.CheckDevices">
            <summary> Check the IPC for new data, and add any new devices to our list. </summary>
            <remarks> Should be called whenver any GetDevices functions is called. </remarks>
        </member>
        <member name="M:SGCore.DeviceList.GetAddress(System.Int32,System.String)">
            <summary> Retrieve Device Address </summary>
            <param name="ipcAddress"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetConnectionType(System.Int32,System.String)">
            <summary> Retieve this device's connectionType. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.IsConnected(System.Int32,System.String)">
            <summary> Returns true if the device at  this connection side is properly connected. </summary>
            <param name="ipcAddress"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.PacketsPerSecondReceived(System.Int32,System.String)">
            <summary> Retrieve the device's Packets per Second Variable </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.PacketsPerSecondSent(System.Int32,System.String)">
            <summary> Retrieve the device's Packets per Second sent Variable </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetSensorDataString(System.Int32,System.String,System.String@)">
            <summary> Retrieve the latest sensor data string from the device at ipcAddress. </summary>
            <param name="ipcAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetConnectionStates">
            <summary> Retrieve the Connection States inside the SGConnect Library. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.SendHaptics(System.Int32,System.String,System.Int32,System.String)">
            <summary> Send command(s) in string format to the device at ipcAddress. </summary>
            <param name="deviceIndex"></param>
            <param name="ipcAddress"></param>
            <param name="commands"></param>
            <param name="channelIndex"> Sent for Android </param>
            <returns> Returns true if the command has been sent succesfully. </returns>
        </member>
        <member name="M:SGCore.DeviceList.Initialize">
            <summary> Initialize Communications - Required when compiled with Sockets Mode </summary>
        </member>
        <member name="M:SGCore.DeviceList.Dispose">
            <summary> Initialize Communications - Not required when compiled with Sockets Mode </summary>
        </member>
        <member name="M:SGCore.DeviceList.GetPingTime(System.Double@)">
            <summary> Server-side only. Returns the time between clientside responses. </summary>
            <param name="pingTime_ms"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.Deserialize(System.String,SGCore.SGDevice@)">
            <summary> Factory function to deserialize an SGDevice out of a DeviceList string. </summary>
            <remarks> Intended use: Returns true if serialization is succesfull, false if errors occured. In that case output = null. </remarks>
            <param name="serialized"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetDeviceStringAt(System.Int32,System.String,System.Int32)">
            <summary> Grab data from the Device string (connected/pps/type) at a specific index. </summary>
            <param name="ipcIndex"></param>
            <param name="ipcAddress"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetHapticString(System.Int32,System.String,System.String@)">
            <summary> Retrieve the string that SenseCom wants to send to the device. </summary>
            <param name="ipcIndex"></param>
            <param name="ipcAddress"></param>
            <param name="hapticStr"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.DeviceModel">
            <summary> Base class containing the minimum amount of data for device models. </summary>
        </member>
        <member name="P:SGCore.DeviceModel.DeviceID">
            <summary> Unique identifier of this device. </summary>
        </member>
        <member name="P:SGCore.DeviceModel.HardwareVer">
            <summary> Hardware (sub) version of this Sense Glove Device. </summary>
        </member>
        <member name="P:SGCore.DeviceModel.FirmwareVer">
            <summary> Firmware version running on the device's MicroController. (as v4.12, this is the 4) </summary>
        </member>
        <member name="P:SGCore.DeviceModel.SubFirmwareVer">
            <summary> Sub firmware version runnning on the device's microcontroller (as v4.12, this is the .12) </summary>
        </member>
        <member name="M:SGCore.DeviceModel.ParseFunctions(System.Int32,System.Int32)">
            <summary> Convert an integer into an array of functions. </summary>
            <param name="value"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceModel.FirmwareNewerThan(System.Int32,System.Int32,System.Boolean)">
            <summary> Returns true if this glove's firmware is older than certain version </summary>
            <param name="fwMain"></param>
            <param name="fwSub"></param>
            <param name="inclusive"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceModel.FirmwareOlderThan(System.Int32,System.Int32,System.Boolean)">
            <summary> Returns true if this glove's firmware is older than certain version </summary>
            <param name="fwMain"></param>
            <param name="fwSub"></param>
            <param name="inclusive"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.DeviceType">
            <summary> Specific Sense Glove Device Types. </summary>
        </member>
        <member name="F:SGCore.DeviceType.UNKNOWN">
            <summary> This device is not recognized by the Sense Glove API. </summary>
        </member>
        <member name="F:SGCore.DeviceType.BETADEVICE">
            <summary> A Device that is in development, with direct access to sensor data and commands. </summary>
        </member>
        <member name="F:SGCore.DeviceType.SENSEGLOVE">
            <summary> An exoskeleton glove that provides force- and haptic feedback. </summary>
        </member>
        <member name="F:SGCore.DeviceType.NOVA">
            <summary> A soft glove with force feedback and optional on-board sensors. </summary>
        </member>
        <member name="F:SGCore.DeviceType.NOVA_2_GLOVE">
            <summary> An advanced version of the Nova Glove, with force-, vibrotactile, and squeeze feedback. </summary>
        </member>
        <member name="T:SGCore.Finger">
            <summary> One of the fingers on the hand </summary>
        </member>
        <member name="F:SGCore.Finger.Thumb">
            <summary> Responsible for our evolutionary success! </summary>
        </member>
        <member name="F:SGCore.Finger.Index">
            <summary> Used to point at what you want </summary>
        </member>
        <member name="F:SGCore.Finger.Middle">
            <summary> On its own, this one is used to indicate frustration. </summary>
        </member>
        <member name="F:SGCore.Finger.Ring">
            <summary> If you like it then you should have put a ___ on it </summary>
        </member>
        <member name="F:SGCore.Finger.Pinky">
            <summary> The little finger. </summary>
        </member>
        <member name="T:SGCore.HandPose">
            <summary> Contains all variables required to draw or analyze a virtual hand. </summary>
        </member>
        <member name="F:SGCore.HandPose.isRight">
            <summary> Whether or not this HandPose was created to be a right- or left hand. </summary>
        </member>
        <member name="F:SGCore.HandPose.jointPositions">
            <summary> Positions of all hand joints relative to the Sense Glove origin. From thumb to pinky, proximal to distal. </summary>
        </member>
        <member name="F:SGCore.HandPose.jointRotations">
            <summary> Quaternion rotations of all hand joints. From thumb to pinky, proximal to distal. </summary>
        </member>
        <member name="F:SGCore.HandPose.handAngles">
            <summary> Euler representations of all possible hand angles. From thumb to pinky, proximal to distal. </summary>
        </member>
        <member name="M:SGCore.HandPose.#ctor(System.Boolean,SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Quat[][],SGCore.Kinematics.Vect3D[][])">
            <summary> Create a new instance of HandPose. </summary>
            <param name="right"></param>
            <param name="jointPos"></param>
            <param name="jointRot"></param>
            <param name="hAngles"></param>
        </member>
        <member name="M:SGCore.HandPose.Equals(SGCore.HandPose,System.Boolean)">
            <summary> Returns true if this HandPose contains the same values as another. </summary>
            <param name="other"></param>
            <param name="anglesOnly">Optional parameters to compare hand angles only.</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.GetNormalizedFlexion(System.Int32,System.Boolean)">
            <summary> Returns the total flexion of a specific finger as a value between 0 (fully extended) and 1 (fully flexed). </summary>
            <remarks> Separate function because we use it multiple times, protected because we don't want indexOutOfRange exceptions. </remarks>
        </member>
        <member name="M:SGCore.HandPose.GetNormalizedFlexion(SGCore.Finger,System.Boolean)">
            <summary> Returns the total flexion of a specific finger as a value between 0 (fully extended) and 1 (fully flexed). </summary>
            <remarks> Useful for animation or for detecting gestures </remarks>
        </member>
        <member name="M:SGCore.HandPose.GetNormalizedFlexion(System.Boolean)">
            <summary> Returns the total flexion the fingers as a value between 0 (fully extended) and 1 (fully flexed). </summary>
            <remarks> Useful for animation or for detecting gestures </remarks>
        </member>
        <member name="M:SGCore.HandPose.ToJointIndex(SGCore.Kinematics.FingerMovement)">
            <summary> Check which joint index a particlar finger movement is linked to. </summary>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.ToJointIndex(SGCore.Kinematics.ThumbMovement)">
            <summary> Check which joint index a particlar thumb movement is linked to. </summary>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.GetJointAngle(SGCore.Kinematics.FingerMovement,SGCore.Finger)">
            <summary> Returns a specific Joint Angle of a finger, in radians. </summary>
            <param name="movement"></param>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.GetJointAngle(SGCore.Kinematics.FingerMovement,System.Int32)">
            <summary> Returns a specific Joint Angle of a finger, in radians. This version is useful for iteration. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.GetThumbAngle(SGCore.Kinematics.ThumbMovement)">
            <summary> Returns a specific Joint Angle of the thumb, in radians </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.Serialize">
            <summary> Create a string representation of this HandPose to store on disk. It can later be deserialized. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.Deserialize(System.String)">
            <summary> Unpack a HandPose back into its Class representation. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.ToString">
            <summary> Returns a string representation of this HandPose. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.FromHandAngles(SGCore.Kinematics.Vect3D[][],System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Generate a HandPose based on articulation angles (handAngles). </summary>
            <param name="handAngles"></param>
            <param name="rightHanded"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.DefaultIdle(System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Create a new instance of a left or right handed Pose that is "idle"; in a neutral position. </summary>
            <param name="right"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.FlatHand(System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Generates a HandPose representing an 'open hand', used in calibration to determine finger extension. </summary>
            <param name="rightHand"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.ThumbsUp(System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Generates a HandPose representing a 'thumbs up', used in calibration to determine finger flexion, thumb extension and adduction. </summary>
            <param name="rightHand"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.Fist(System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Generates a HandPose representing a 'fist', used in calibration to determine, thumb flexion and abduction. </summary>
            <param name="rightHand"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.HapticLocation">
            <summary> All of the locations supported by the SenseGlove API </summary>
        </member>
        <member name="F:SGCore.HapticLocation.Unknown">
            <summary> Unknown location. Calling haptic function(s) with this parameter will not play anything </summary>
        </member>
        <member name="F:SGCore.HapticLocation.Thumb_Tip">
            <summary> Fingertip of the Thumb </summary>
        </member>
        <member name="F:SGCore.HapticLocation.Index_Tip">
            <summary> Fingertip of the Index Finger </summary>
        </member>
        <member name="F:SGCore.HapticLocation.Middle_Tip">
            <summary> Fingertip of the Middle Finger </summary>
        </member>
        <member name="F:SGCore.HapticLocation.Ring_Tip">
            <summary> Fingertip of the Ring Finger </summary>
        </member>
        <member name="F:SGCore.HapticLocation.Pinky_Tip">
            <summary> Fingertip of the Pinky Finger </summary>
        </member>
        <member name="F:SGCore.HapticLocation.Palm_IndexSide">
            <summary> Vibration on the hand palm, close to the index finger. </summary>
        </member>
        <member name="F:SGCore.HapticLocation.Palm_PinkySide">
            <summary> Vibration on the hand palm close to the pinky finger. </summary>
        </member>
        <member name="F:SGCore.HapticLocation.WholeHand">
            <summary> Play this Haptic Effect on the whole hand. For General Hand Feedback. </summary>
        </member>
        <member name="T:SGCore.HG_CalibrationState">
            <summary> The Calibration State of this Glove. </summary>
        </member>
        <member name="F:SGCore.HG_CalibrationState.Unknown">
            <summary> No idea what the calibrationState of this glove is... </summary>
        </member>
        <member name="F:SGCore.HG_CalibrationState.MoveFingers">
            <summary> One or more sensors still need to move... </summary>
        </member>
        <member name="F:SGCore.HG_CalibrationState.AllSensorsMoved">
            <summary> All sensors have moved.  </summary>
        </member>
        <member name="F:SGCore.HG_CalibrationState.CalibrationLocked">
            <summary> Calibration is locked in. Done collecting Data. </summary>
        </member>
        <member name="T:SGCore.HapticGlove">
            <summary> A type of glove that includes finger tracking and/or force-feedback methods. </summary>
        </member>
        <member name="F:SGCore.HapticGlove.interpolator">
            <summary> The actual Interpolation Model. </summary>
        </member>
        <member name="P:SGCore.HapticGlove.HandInterpolation">
            <summary> Returns the Hand Interpolation Model used by this HapticGlove. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.GetDeviceType">
            <summary> Retrieve this HapticGlove's DeviceType. Used to distinguish between SenseGove and Nova Gloves. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetDeviceID">
            <summary> Return this HapitcGlove's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHardwareVersion">
            <summary> Retrieve this glove's hardwareversion (DK1, etc). </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetFirmwareVersion">
            <summary> Retrieve this device's main firmware version. v4.12 returns 4. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetSubFirmwareVersion">
            <summary> Retrieve this device's sub firmware version. v4.12 returns 12. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.ToString">
            <summary> Convert this device's variables into something readable by humans. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.IsRight">
            <summary> Returns true if this glove is made for a right hand. If false, it's a left hand. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetIMURotation(SGCore.Kinematics.Quat@)">
            <summary> Retrieve this glove's IMU rotation, if if has any </summary>
            <param name="IMU"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHandAngles(SGCore.Kinematics.Vect3D[][]@)">
            <summary> HandAngles is a 5x3 array containing the joint angles as calculated by this HapticGlove, using the device's current solver.
            Can return false if this glove is disconnected, or if sensor data is incomplete. </summary>
            <param name="handAngles"></param>
        </member>
        <member name="M:SGCore.HapticGlove.GetHandPose(SGCore.HandPose@)">
            <summary> Retruns the latest handPose using a default HandGeometry and the latest profile stored on disk. </summary>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Returns the latest hand pose for a specific hand geometry, using this glove's HandInterpolation profile </summary>
            <param name="handGeometry"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.StopHaptics">
            <summary> Stops all Haptic effects if any are currently playing. Useful at the end of simulations or when resetting. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.StopVibrations">
            <summary> Stops all vibrations, but does not affect the force-feedback </summary>
        </member>
        <member name="M:SGCore.HapticGlove.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucesfully sent to SenseCom. </returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetLastSentForces">
            <summary> Returns the last force levels sent to this glove (though this interface!, that does not mean another program can't have been sinding stuff too!)  </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.HapticGlove.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.HapticGlove.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0f means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.QueueVibroLevels(System.Single[])">
            <summary> Queue a vibrotactile level for each finger. </summary>
            <param name="amplitudes"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.QueueVibroLevel(SGCore.Finger,System.Single)">
            <summary> Queue a vibrotactle level for a specific finger </summary>
            <param name="finger"></param>
            <param name="amplitude"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.SupportsCustomWaveform(SGCore.HapticLocation)">
            <summary> Returns true if the HapticGlove supports vibration feedback on the specified location. </summary>
            <param name="atLocation"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.SendCustomWaveform(SGCore.CustomWaveform,SGCore.HapticLocation)">
            <summary> Sends a custom waveform to the location specified, provided that the glove has a motor there, and can support custom waveforms. </summary>
            <param name="waveform"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHapticGloves(System.Boolean)">
            <summary> Get all Haptic Gloves connected to this system. They may or may not be connected </summary>
            <param name="connectedOnly">If false, we'll return all haptic gloves ever detected during this session</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetGlove(SGCore.HapticGlove@)">
            <summary> Get the first Haptic Glove connected to this System </summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetGlove(System.Boolean,SGCore.HapticGlove@)">
            <summary> Get the first left/right Haptic Glove connected to this System </summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetCalibrationState">
            <summary> Returns the HapticGlove's state of calibration for its on-board sensors. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.ResetCalibration">
            <summary> Resets internal calibration of the Haptic Glove. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.EndCalibration">
            <summary> Force-End any form of calibration manually, if any is still running. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.GetCalibrationInstruction">
            <summary> Retrieve the current calibration instruction. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.TryLoadProfile">
            <summary> Attempt to load a HapticGlove Profile from disk, if one exists.  </summary>
        </member>
        <member name="M:SGCore.HapticGlove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets. </summary>
            <remarks> The simplest interface, using default offsets </remarks>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="M:SGCore.HapticGlove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="T:SGCore.SenseCom">
            <summary> SenseCom application interface </summary>
        </member>
        <member name="M:SGCore.SenseCom.RegisterExe">
            <summary> Registers current process as the latest SenseCom build. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.RegisterExe(System.String)">
            <summary> Register a particular path as the SenseGlove executable location </summary>
            <param name="exePath"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.GetExePath(System.String@)">
            <summary> Retrieve the location of SenseGlove executable </summary>
            <param name="exePath"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.IsRunning">
            <summary> Retruns true if SenseCom scanning is active. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.SenseCom_Installed">
            <summary> Returns true if a valid path to SenseCom exists. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.GetCurrentExeDir(System.String@)">
            <summary> Returns the directory of the current process </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.StartupSenseCom">
            <summary> Force-starts the SenseCom application if it is active on the system </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Parsing.SG_CVar">
            <summary> Sense Glove C string Variables, enumerated for our convinience. </summary>
        </member>
        <member name="F:SGCore.Parsing.SG_CVar.AllC">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="T:SGCore.Parsing.SG_SVar">
            <summary> Sense Glove sensor string Variables, enumerated for our convinience. </summary>
        </member>
        <member name="F:SGCore.Parsing.SG_SVar.AllS">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="T:SGCore.Parsing.SenseGloveVars">
            <summary> "Database" class containing Sense Glove internal variables </summary>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GetStdCString(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary> Retrieve a basic Cstring for a Sense Glove of a specific Hardware Version. Used for debugging / unit tests. </summary>
             <param name="hwVersion"></param>
             <param name="fwVersionMain"></param>
             <param name="fwVersionSub"></param>
             <param name="rightHand"></param>
             <returns> Returns an empty string when an invalid glove version is requested. </returns>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GetSensorString(System.String,System.Single)">
            <summary> Retrieve an example sensor string of a Sense Glove with a particular hardware- and firmware version. </summary>
            <param name="hwVersion"></param>
            <param name="fwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GetStartPositions(System.String,System.Boolean)">
            <summary> Retrieve the starting positions of a particular Sense Glove. </summary>
            <param name="hwVersion"></param>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GetStartRotations(System.String,System.Boolean)">
            <summary> Retrieve the starting rotations of a particular Sense Glove. </summary>
            <param name="hwVersion"></param>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GetGloveLengths(System.String)">
            <summary> Retrieve the glove finger lengths of a particular Sense Glove. </summary>
            <param name="hwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GetSensors(System.String)">
            <summary> Get the number of sensors of a SenseGlove </summary>
            <param name="hwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GetIMUCorrection(System.String,System.Int32,System.Int32)">
            <summary> Get the default IMUCorrection for the SenseGlove </summary>
            <param name="hwVersion"></param>
            <param name="fwVersionMain"></param>
            <param name="fwVersionSub"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GetFunctions(System.String,System.Int32,System.Int32)">
            <summary> Check all functionality of a SenseGlove </summary>
            <param name="hwVersion"></param>
            <param name="fwVersionMain"></param>
            <param name="fwVersionSub"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Parsing.SenseGloveVars.GenerateGloveModel(System.String,System.Int32,System.Int32,System.Boolean,System.String)">
            <summary> Generate a custom glove info. </summary>
            <param name="hwVersion"></param>
            <param name="fwVersionMain"></param>
            <param name="fwVersionSub"></param>
            <param name="rightHand"></param>
            <param name="customID"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SGConnect">
            <summary> The only class within the DLL to allow access to the SGComm C++ library. </summary>
            <remarks> Should therefore only contain static methods. </remarks>
        </member>
        <member name="M:SGCore.SGConnect.I_GetSGConnectionInfo(System.Boolean,System.Text.StringBuilder)">
            <summary> Retrieve the devices detected by the SenseComm. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_ActiveDevices">
            <summary> Retrieve the devices detected by the SenseComm. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetDeviceString(System.String,System.Text.StringBuilder)">
            <summary> Gets the raw string from the DeviceList memory block. </summary>
            <param name="deviceAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetSensorString(System.String,System.Text.StringBuilder)">
            <summary>  Get the raw (unprocessed) sensor data of the SGDevice at index, as discovered by SenseCom  </summary>
            <param name="deviceAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_WriteHaptics(System.String,System.String)">
            <summary>  </summary>
            <param name="deviceAddress"></param>
            <param name="commands"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetHapticString(System.String,System.Text.StringBuilder)">
            <summary> Retrives a Haptic String </summary>
            <param name="deviceAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_ScanningActive">
            <summary> Scheck if the SenseCom scanning is running. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetLibraryVersion(System.Text.StringBuilder)">
            <summary> Check if the SenseCom scanning is running. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetConnectionStates(System.Text.StringBuilder)">
            <summary> Check if the SenseCom scanning is running. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_Init">
            <summary> Internal Init </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_Dispose">
            <summary> Internal Dispose </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_SetDebugLevel(System.Int32)">
            <summary> Internal SetDebugLvl </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetDebugLevel">
            <summary> Internal GetDebugLvl </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_ReleaseIdleConnections">
            <summary> Release Idle Connections </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_AddToSerialWhiteList(System.String)">
            <summary>  </summary>
            <param name="pidVidContains"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_RemoveFromSerialWhiteList(System.String)">
            <summary>  </summary>
            <param name="pidVidContains"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.InitCommunications">
            <summary>  Returns 1 if the communications were initialized of, 0 if this wasn't possible, -1 if the dll is missing. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.DisposeCommunications">
            <summary> Returns 1 if the communications were disposed of, 0 if this wasn't possible, 2 if we are already disposing. -1 if the dll is missing. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.GetSGConnectVersion(System.String@)">
            <summary> Retrieve the library version of SGConnect that is paired with this DLL. </summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.SetDebugLevel(System.Int32)">
            <summary> Set the internal debug level of the SGConnect library. 0 .. 6.  </summary>
            <param name="newLevel"></param>
        </member>
        <member name="M:SGCore.SGConnect.GetDebugLevel">
            <summary> Get the debug level of the current Library </summary>
        </member>
        <member name="M:SGCore.SGConnect.GetConnectionStates(System.String@)">
            <summary> Retrieve the connection states in a list </summary>
            <param name="connectionsList"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.GetSGConnectionInfo(System.Boolean,System.String[]@)">
            <summary> Retrieve the connection states in a list </summary>
            <param name="withBT"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.ReleaseIdleConnections">
            <summary> Attempts to release the idle connections on your system... </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.Validate_DLLs">
            <summary> Returns true if SenseCom and it's relevant C++ Redistibutables have been succesfully connected. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.GetHapticString(System.String,System.String@)">
            <summary> Wrapper for the extenal method. </summary>
            <param name="deviceAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.AddToSerialWhiteList(System.String)">
            <summary> Add a string to the PID / VID whitelist. This is for Windows / Linux Purposes. Returns true if it was indeed added </summary>
            <param name="pidVidContains"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.RemoveFromSerialWhiteList(System.String)">
            <summary> Add a string to the PID / VID whitelist. This is for Windows / Linux Purposes. Returns true if it was indeed added </summary>
            <param name="pidVidContains"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Library">
            <summary> Contains info about this DLL </summary>
        </member>
        <member name="T:SGCore.Library.BackEndType">
            <summary> The type of back-end communcation </summary>
        </member>
        <member name="F:SGCore.Library.BackEndType.SharedMemory">
            <summary> Back-end info comes from shared memory on the device </summary>
        </member>
        <member name="F:SGCore.Library.BackEndType.AndroidStrings">
            <summary> Back-end Data comes from an Android Library </summary>
        </member>
        <member name="F:SGCore.Library.BackEndType.Sockets">
            <summary> Back-end Data comes from Sockets (QuarkVR Server Mode) </summary>
        </member>
        <member name="M:SGCore.Library.GetBackEndType">
            <summary> Check wwhat back-end connections are used for this version of SGConnect </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Library.BackEndVersion">
            <summary> Back-End version in string notation </summary>
            <returns></returns>
        </member>
        <member name="P:SGCore.Library.Version">
            <summary> C# Core library version in a string notation </summary>
        </member>
        <member name="P:SGCore.Library.SGConnectVersion">
            <summary> Version of the SConnect Library, provided this project has a reference to one. </summary>
        </member>
        <member name="T:SGCore.SGDevice">
            <summary> A Sense Glove device that can send / recieve data via the SenseComm program. </summary>
        </member>
        <member name="T:SGCore.SGDevice.ConnectionType">
            <summary> The type of connection this device is using </summary>
        </member>
        <member name="F:SGCore.SGDevice.ConnectionType.Unknown">
            <summary> This device has been disconnected, or this version of SGCore does not recognize the type of connection. </summary>
        </member>
        <member name="F:SGCore.SGDevice.ConnectionType.Serial">
            <summary> USB Serial port connection. Used for DK1 SenseGloves </summary>
        </member>
        <member name="F:SGCore.SGDevice.ConnectionType.BluetoothSerial">
            <summary> Blueooth connection through Serial ports. Used for Wireless Kits and early Nova prototypes. </summary>
        </member>
        <member name="F:SGCore.SGDevice.ConnectionType.BluetoothAndroid">
            <summary> Bluetooth Connection Via Android/Java SDK </summary>
        </member>
        <member name="F:SGCore.SGDevice.deviceIndex">
            <summary> The index of this device inside the SenseComm program. Used to access shared memory. </summary>
        </member>
        <member name="F:SGCore.SGDevice.ipcAddress">
            <summary> Internal shared memory adress. </summary>
        </member>
        <member name="F:SGCore.SGDevice.lastCmdID">
            <summary> used to generate new cmd ids when sending special commands </summary>
        </member>
        <member name="F:SGCore.SGDevice.hapticChannels">
            <summary> Contains information regarding this device's Haptics. </summary>
        </member>
        <member name="M:SGCore.SGDevice.GetDeviceType">
            <summary> Retrieve the DeviceType of this SGDevice. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetDeviceID">
            <summary> Retrieve this device's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetHardwareVersion">
            <summary> Retrieve this device's hardware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetFirmwareVersion">
            <summary> Retrieve this device's main firmware version. v4.12 returns 4. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetSubFirmwareVersion">
            <summary> Retrieve this device's sub firmware version. v4.12 returns 12. </summary>
        </member>
        <member name="M:SGCore.SGDevice.FirmwareString">
            <summary> Retreive the Device's firmware as a string. Ex. "v4.7" </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.SetHapticChannels(SGCore.HapticChannelInfo)">
            <summary>  </summary>
            <param name="channels"></param>
        </member>
        <member name="M:SGCore.SGDevice.FirmwareNewerThan(System.Int32,System.Int32,System.Boolean)">
            <summary> Returns true if this glove's firmware is older than certain version </summary>
            <param name="fwMain"></param>
            <param name="fwSub"></param>
            <param name="inclusive"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.FirmwareOlderThan(System.Int32,System.Int32,System.Boolean)">
            <summary> Returns true if this glove's firmware is older than certain version </summary>
            <param name="fwMain"></param>
            <param name="fwSub"></param>
            <param name="inclusive"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetAddress">
            <summary> Retrieve this Device's Serial/Bluetooth address. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetConnectionType">
            <summary> Retrieve the connection type of this Sense Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.IsConnected">
            <summary> Check if this device is currently connected to the system. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.PacketsPerSecondReceived">
            <summary> Retrieve the device's Packets per Second Variable </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.PacketsPerSecondSent">
            <summary> Retrieve the device's Packets per Second Variable </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetDeviceIndex">
            <summary> Retrieve the index of this device within SenseComm. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.IsWireless">
            <summary> Returns true if this device is connected over a connection other than usb cable. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.HasBattery">
            <summary> Returns true if this device operates on abattery </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.IsCharging">
            <summary> Returns true if this device is currently charging </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetBatteryLevel(System.Single@)">
            <summary> Returns the device's battery level, as a value between 0 (empty) and 1 (full). </summary>
            <param name="battLvl"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetHapticChannelCount">
            <summary> The number of haptic channels this device can support. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetHapticChannelCount(SGCore.HapticChannelType)">
            <summary> How many channels of a specific type this SGDevice posesses. </summary>
            <param name="channelType"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.SetDeviceIndex(System.Int32)">
            <summary> Change this device's index within the SenseComm. Warning: Can cause errors. </summary>
            <remarks> Which is why its internal. </remarks>
            <param name="newIndex"></param>
        </member>
        <member name="M:SGCore.SGDevice.ToString">
            <summary> Retrieve a String representation of this object. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.ParseFirmware(System.String,System.Int32@,System.Int32@)">
            <summary> Parse a main and sub firmware version from its raw (v4.12) notation </summary>
            <param name="rawFW"></param>
            <param name="mainVer"></param>
            <param name="subVer"></param>
        </member>
        <member name="M:SGCore.SGDevice.FirmwareNewerThan(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary> If true, my firmware is newer than the reference firmware. </summary>
            <param name="myFirmwareMain"></param>
            <param name="myFirmwareSub"></param>
            <param name="referenceMain"></param>
            <param name="referenceSub"></param>
            <param name="inclusive"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.FirmwareOlderThan(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary> If true, my firmware is newer than the reference firmware. </summary>
            <param name="myFirmwareMain"></param>
            <param name="myFirmwareSub"></param>
            <param name="referenceMain"></param>
            <param name="referenceSub"></param>
            <param name="inclusive"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.PosTrackingHardware">
            <summary> Tracking Hardware used for positional tracking. </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.Custom">
            <summary> Custom tracking hardware, we don't apply any offsets </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.ViveTracker">
            <summary> HTC Vive Tracker (v1.0 or v2.0). </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.OculusTouch">
            <summary> Oculus Touch controller (left or right) for Rift S and Quest 1 </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.Quest2Controller">
            <summary> Touch controller for Oculus Quest 2 </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.PicoNeo2">
            <summary> Pico Neo 2 Controller(s) </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.PicoNeo3">
            <summary> Pico Neo 3 Controllers(s) </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.ViveFocus3WristTracker">
            <summary> Wrist tracker for the Vive Focus 3 </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.QuestProController">
            <summary> Oculus Touch Controller that comes with the Meta Quest Pro. </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.Quest3Controller">
            <summary> Meta Quest 3 Controllers.  </summary>
        </member>
        <member name="T:SGCore.Tracking">
            <summary> Utility class containing tracking offset information </summary>
        </member>
        <member name="F:SGCore.Tracking.zeroOffset_trackerPos">
            <summary> If true, we set glove-tracker position offsets to zero - used for debugging </summary>
        </member>
        <member name="F:SGCore.Tracking.zeroOffset_trackerRot">
            <summary> If true, we set glove-tracker rotation offsets to zero - used for debugging </summary>
        </member>
        <member name="F:SGCore.Tracking.zeroOffset_handPos">
            <summary> If true, we set glove-hand position offsets to zero - used for debugging </summary>
        </member>
        <member name="F:SGCore.Tracking.zeroOffset_handRot">
            <summary> If true, we set glove-hand position offsets to zero - used for debugging </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Tracking.CalculateLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)" -->
        <member name="F:SGCore.Tracking.sg_fingerToGloveOrigin_Pos">
            <summary> Positional offset from each finger to the glove origin </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_fingerToGloveOrigin_Rot">
            <summary>  </summary>
        </member>
        <member name="M:SGCore.Tracking.GetSenseGloveOffset_Glove_Mount(System.Boolean,SGCore.Finger,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Get the position and rotation offsets to go from the glove origin to the mounted position </summary>
            <remarks> Based on CAD. needs to be inverted when going from tracker to glove origin. </remarks>
            <param name="rightHand"></param>
            <param name="toFinger"></param>
            <param name="iPos"></param>
            <param name="iRot"></param>
        </member>
        <member name="M:SGCore.Tracking.GetSenseGloveOffset_Tracker_Mount(SGCore.PosTrackingHardware,System.Boolean,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Get the offset to get from the TrackedHardware to a SenseGlove mounting location. Combined with Glove-Mount offset to get the glove location. </summary>
            <param name="hardware"></param>
            <param name="rightHand"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="F:SGCore.Tracking.sg_gloveWristOffsetPos">
            <summary> Default position offset from glove origin to wrist location, in mm. </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_gloveWristOffsetRot">
            <summary> Default rotation offset from glove origin to wrist location. </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_viveToAttach_Pos">
            <summary> Vive Tracker origin to Finger rotational offset </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_viveToAttach_Rot">
            <summary> Vive Tracker origin to Finger rotational offset </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_ocTouchToAttach_Pos">
            <summary> Oculus Touch origin to Finger rotational offset </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_ocTouchToAttach_Rot">
            <summary> Oculus Touch origin to Finger rotational offset </summary>
        </member>
        <member name="M:SGCore.Tracking.GetNovaOffset_Glove_Wrist(System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Returns the Offsets that will bring us from the Nova origin to the wrist position. </summary>
            <param name="rightHand"></param>
            <param name="hardwareVersion"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="M:SGCore.Tracking.GetNovaOffset_Glove_Wrist(SGCore.Nova.Nova_GloveInfo,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Returns the Offsets that will bring us from the Nova origin to the wrist position. </summary>
            <param name="gloveInfo"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="M:SGCore.Tracking.GetNovaOffset_Tracker_Glove(SGCore.PosTrackingHardware,System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieves Offsets for a particular device. </summary>
            <param name="hardware"></param>
            <param name="rightHand"></param>
            <param name="hardwareVersion"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="M:SGCore.Tracking.GetNovaOffset_Tracker_Glove(SGCore.PosTrackingHardware,SGCore.Nova.Nova_GloveInfo,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary>  Retrieves Offsets for a particular device. </summary>
            <param name="hardware"></param>
            <param name="gloveInfo"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="F:SGCore.Tracking.nova2_glove_wristOffset_pos_R">
            <summary> Position Offsets to get from the Nova 2.0 Hub to the Right Hand Wrist </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_glove_wristOffset_pos_L">
            <summary> Position Offsets to get from the Nova 2.0 Hub to the Left Hand Wrist </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_glove_wristOffset_rot">
            <summary> Rotation Offsets to get from the Nova 2.0 Hub to the any Wrist (it's symmetrical) </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_quest2ToHub_pos_R">
            <summary> Nova 2 Quest 2 to Nova Hub position offset for right hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_quest2ToHub_rot_R">
            <summary>  Nova 2 Quest 2 to Nova Hub rotation offset for right hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_quest2ToHub_pos_L">
            <summary> Nova 2 Quest 2 to Nova Hub position offset for left hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_quest2ToHub_rot_L">
            <summary>  Nova 2 Quest 2 to Nova Hub rotation offset for left hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_viveTrackerToHub_pos_R">
            <summary> Nova 2 Vive Tracker to Nova Hub position offset for right hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_viveTrackerToHub_rot_R">
            <summary>  Nova 2 Vive Tracker to Nova Hub rotation offset for right hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_viveTrackerToHub_pos_L">
            <summary> Nova 2 Vive Tracker to Nova Hub position offset for left hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_viveTrackerToHub_rot_L">
            <summary>  Nova 2 Vive Tracker to Nova Hub rotation offset for left hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_VF3TrackerToHub_pos_R">
            <summary> Nova 2 Vive Tracker to Nova Hub position offset for right hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_VF3TrackerToHub_rot_R">
            <summary>  Nova 2 Vive Tracker to Nova Hub rotation offset for right hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_VF3TrackerToHub_pos_L">
            <summary> Nova 2 Vive Tracker to Nova Hub position offset for left hand. </summary>
        </member>
        <member name="F:SGCore.Tracking.nova2_VF3TrackerToHub_rot_L">
            <summary>  Nova 2 Vive Tracker to Nova Hub rotation offset for left hand. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Tracking.GetNova2Offset_Glove_Wrist(System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)" -->
        <!-- Badly formed XML comment ignored for member "M:SGCore.Tracking.GetNova2Offset_Tracker_Glove(SGCore.PosTrackingHardware,System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)" -->
    </members>
</doc>
