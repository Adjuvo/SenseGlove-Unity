<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SGCoreCs</name>
    </assembly>
    <members>
        <member name="T:SGCore.Kinematics.Anatomy">
            <summary> "Database" of anatomical values, such as joint limits. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.LIMIT_MIN">
            <summary> Index of the minimum value in the array(s) </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.LIMIT_MAX">
            <summary> Index of the maximum value in the array(s) </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.thumbLimits">
            <summary> Hard Coded thumb limits, in radians </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.fingerLimits">
            <summary> Hard Coded finger limits, in radians </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iPronation">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iSupination">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iFlexion">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iExtension">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iAbduction">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.iAdduction">
            <summary> Movement indices with which to access specific motions. Usage: movement == Anatomy.iFlexion </summary>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.ClampJointAngle(System.Single,SGCore.Finger,System.Boolean,System.Int32,System.Int32)">
            <summary> Limit a value between specific joint angles. </summary>
            <param name="value"></param>
            <param name="finger"></param>
            <param name="rightHand"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.ClampJointAngle(System.Single,System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary> Limit a value between specific joint angles. </summary>
            <param name="value"></param>
            <param name="finger"></param>
            <param name="rightHand"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetFingerJointLimit(System.Boolean,System.Int32,System.Int32,System.Boolean)">
            <summary> Retrieve one of the limits of a finger joint's movement. </summary>
            <param name="right"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetThumbJointLimit(System.Boolean,System.Int32,System.Int32,System.Boolean)">
            <summary> Retrieve one of the limits of a thumb joint's movement. </summary>
            <param name="right"></param>
            <param name="joint"></param>
            <param name="movement"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.thumbFlexions01">
            <summary> Used for Normalization. Sorted per joint, indices by 0 (normalized =0) and 1 (normalized =1). </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.fingerFlexions01">
            <summary> Used for normalization. Sorted per joint, indices by 0 (normalized =0) and 1 (normalized =1). </summary>
        </member>
        <member name="F:SGCore.Kinematics.Anatomy.abductions01_R">
            <summary> used for normalization. Sorted per joint, indices by 0 (normalized =0) and 1 (normalized =1). </summary>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetFlexNormalizers(SGCore.Finger,System.Single@,System.Single@)">
            <summary> Generic Entry point.</summary>
            <param name="finger"></param>
            <param name="flex0"></param>
            <param name="flex1"></param>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.NormalizeFingerFlex(System.Single)">
            <summary> Convert a total finger flexion in radians into a 0..1 representation. </summary>
            <param name="totalFlex_Rad"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.NormalizeThumbFlex(System.Single)">
            <summary> Convert a total finger flexion in radians into a 0..1 representation. </summary>
            <param name="totalFlex_Rad"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.NormalizeFlexion(SGCore.Finger,System.Single)">
            <summary> A generic entry point for fingers. </summary>
            <param name="finger"></param>
            <param name="totalFlex_Rad"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.NormalizeAbduction(SGCore.Finger,System.Single,System.Boolean)">
            <summary> Normalize finger abuction of a single finger </summary>
            <param name="finger"></param>
            <param name="totalAbd_Rad"></param>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.FingerFlexion_FromNormalized(System.Single,System.Int32)">
            <summary> Based on a normalized flexion, return a proper flexion angle for a specific finger joint. </summary>
            <param name="normalizedFlexion"> Accepteable values are 0, 1, 2. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.ThumbFlexion_FromNormalized(System.Single,System.Int32)">
            <summary> Based on a normalized flexion, return a proper flexion angle for a specific thumb joint. </summary>
            <param name="normalizedFlexion"></param>
            <param name="joint"> Accepteable values are 0, 1, 2. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.Abduction_FromNormalized(SGCore.Finger,System.Single,System.Boolean)">
            <summary> Convert a normalized abduction back into a radian angle for a specific finger. </summary>
            <param name="finger"></param>
            <param name="normalizedAbduction"></param>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.Flexions_FromNormalized(SGCore.Finger,System.Single)">
            <summary> Calculates the three flexion angles from a normalized angle (value between 0 .. 1. </summary>
            <param name="finger"></param>
            <param name="normalizedFlexion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.FingerAngles_FromNormalized(SGCore.Finger,System.Single,System.Single,System.Boolean)">
            <summary> Returns joint angles for a finger, with a normalized flexion and abduction. </summary>
            <param name="finger"></param>
            <param name="normalizedFlexion"></param>
            <param name="normalizedAbd"></param>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_FromNormalized(System.Boolean,System.Single[],System.Single,System.Single)">
            <summary> Generates a set of HandAngles from normalized finger flexions, thumb abduction and a global finger spread. </summary>
            <param name="isRight"></param>
            <param name="flexions01"></param>
            <param name="thumbAbd01"></param>
            <param name="fingerSpread01"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_Default(System.Boolean)">
            <summary> Get Hand Angles that would make a Default Pose; fingers stretched and thumb abducted by 30 degrees. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_Flat(System.Boolean)">
            <summary> Get Hand Angles that would make a flat hand </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_ThumbsUp(System.Boolean)">
            <summary> Get Hand Angles that would make a thumbs up </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.HandAngles_Fist(System.Boolean)">
            <summary> Get Hand Angles that would make a fist </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Anatomy.GetThumbJointName(System.Int32)">
            <summary> Get the name of a thumb joint by the index. </summary>
            <param name="joint"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Kinematics.Anatomy.GetFingerJointName(System.Int32)" -->
        <member name="M:SGCore.Kinematics.Anatomy.GetJointName(SGCore.Finger,System.Int32,System.String)">
            <summary> Get the name of a specific joint_finger combination. </summary>
            <param name="finger"></param>
            <param name="joint"></param>
            <param name="delim">Optional joint delimiter.</param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.BasicHandModel">
            <summary> Represents data of a user's hand required for forward kinematics. </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.FingerLengths">
            <summary> The length of individual finger phalangers in mm, soted per finger. Generally 5x3 </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.StartJointPositions">
            <summary> Starting joint positions relative to the device Origin </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.StartJointRotations">
            <summary> Starting joint rotations relative to the device Origin </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.TotalLengths">
            <summary> Calculated Total finger lengths </summary>
        </member>
        <member name="P:SGCore.Kinematics.BasicHandModel.FingerRatios">
            <summary> Calculated Finger ratios [0..1] </summary>
        </member>
        <member name="F:SGCore.Kinematics.BasicHandModel.baseFingerLengths">
            <summary> Default finger lengths (based on right hand). </summary>
            <remarks> Any missing fingers are replaced with their respective value. </remarks>
        </member>
        <member name="F:SGCore.Kinematics.BasicHandModel.baseJointPositions">
            <summary> Default joint positions (based on right hand). </summary>
            <remarks> Any missing positions are replaced with their respective value. </remarks>
        </member>
        <member name="F:SGCore.Kinematics.BasicHandModel.baseJointRotations">
            <summary> Default joint rotations (based on right hand). </summary>
            <remarks> Any missing rotation are replaced with their respective value. </remarks>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.#ctor(System.Boolean,System.Single[][],SGCore.Kinematics.Vect3D[])">
            <summary> Create a new basicHandModel with no starting rotations. </summary>
            <param name="right">If this is a right hand (used in validation)</param>
            <param name="lengths"></param>
            <param name="startPositions"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.#ctor(System.Boolean,System.Single[][],SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Quat[])">
            <summary> Create a new basicHandModel </summary>
            <param name="right">If this is a right hand (used in validation)</param>
            <param name="lengths"></param>
            <param name="startPositions"></param>
            <param name="startRotations"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Default(System.Boolean)">
            <summary> Retrieve a default left or right hand model. </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Validate">
            <summary> Test if the input has enough values. if not, add the appropriate values to compensate. </summary>
            <param name="right"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.GetFingerLengths(SGCore.Finger)">
            <summary> Retrieve the finger lengths of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.SetFingerLengths(System.Single[],SGCore.Finger)">
            <summary> Set the finger lengths of a specific finger. </summary>
            <param name="newLengths"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.GetJointPosition(SGCore.Finger)">
            <summary> Retrieve the start position of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.SetJointPosition(SGCore.Kinematics.Vect3D,SGCore.Finger)">
            <summary> Set the start position of a specific finger </summary>
            <param name="newPosition"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.GetJointRotation(SGCore.Finger)">
            <summary> Retrieve the start rotation of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.SetJointRotation(SGCore.Kinematics.Quat,SGCore.Finger)">
            <summary> Set the start rotation of a specific finger </summary>
            <param name="newRotation"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Get3DLengths(SGCore.Finger)">
            <summary> Retrieve the lengths of a specific finger, as Vect3D representation (L, 0, 0). </summary>
            <remarks> Used for forwards kinematics. </remarks>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.ToString">
            <summary> ToString notation using only  </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Equals(SGCore.Kinematics.BasicHandModel)">
            <summary> Check if one HandModel equals another in geometry. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Serialize">
            <summary> Convert this BasicHandModel into a string representation </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.BasicHandModel.Deserialize(System.String)">
            <summary> Convert a string representation of a BasicHandModel back to a useable class. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.ThumbMovement">
            <summary> Anatomical movements of the thumb joints. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_CMC_Twist">
            <summary> Pronation/Supination of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_CMC_Flex">
            <summary> Flexion of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_CMC_Abd">
            <summary> Abduction of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_MCP_Flex">
            <summary> Flexion of the second thumb joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.ThumbMovement.T_IP_Flex">
            <summary> Flexion of the third thumb joint. </summary>
        </member>
        <member name="T:SGCore.Kinematics.FingerMovement">
            <summary> Anatomical movements of the finger joints. </summary>
        </member>
        <member name="F:SGCore.Kinematics.FingerMovement.F_MCP_Flex">
            <summary> Flexion of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.FingerMovement.F_MCP_Abd">
            <summary> Abduction of the first finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.FingerMovement.F_PIP_Flex">
            <summary> Flexion of the second finger joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.FingerMovement.F_DIP_Flex">
            <summary> Flexion of the third finger joint. </summary>
        </member>
        <member name="T:SGCore.Kinematics.HandInterpolator">
            <summary> Contains interpolation sets of all joint movements that can be caluclated into a handPose. </summary>
        </member>
        <member name="P:SGCore.Kinematics.HandInterpolator.CmcStartRot">
            <summary> Starting rotation of the thumb cmc joint. </summary>
        </member>
        <member name="F:SGCore.Kinematics.HandInterpolator.jointInterpolations">
            <summary> Interpolation sets for each finger. First index indicates which finger, Second index indicates the joint movement. </summary>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.#ctor(SGCore.Kinematics.InterpolationSet[][])">
            <summary> Create a new basic HandInterpolator without a starting rotation. </summary>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.#ctor(SGCore.Kinematics.InterpolationSet[][],SGCore.Kinematics.Quat)">
            <summary> Create a new basic HandInterpolator with a starting rotation. </summary>
            <param name="interpolations"></param>
            <param name="cmcStart"></param>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.Default(System.Boolean)">
            <summary> Create a default instance of a left- or right handed interpolator. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.CalculateAngle(SGCore.Finger,System.Int32,System.Single)">
            <summary> Calculate any finger's movement rotation, using an input value. </summary>
            <param name="finger"></param>
            <param name="movement"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.CalculateAngle(SGCore.Finger,SGCore.Kinematics.FingerMovement,System.Single)">
            <summary> Calculate a finger movement's rotation, using an input value. </summary>
            <param name="finger"></param>
            <param name="movement"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.CalculateAngle(SGCore.Finger,SGCore.Kinematics.ThumbMovement,System.Single)">
            <summary> Calculate a thumb movement's rotation, using an input value. </summary>
            <param name="finger"></param>
            <param name="movement"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.CalculateAngle(SGCore.Kinematics.ThumbMovement,System.Single)">
            <summary> Calculate a thumb movement's rotation, using an input value </summary>
            <param name="movement"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.Equals(SGCore.Kinematics.HandInterpolator)">
            <summary> Check if this handInterpolator matches another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.InterpolateFingerAngles(SGCore.Finger,SGCore.Kinematics.HandInterpolator,SGCore.Kinematics.Vect3D)">
            <summary> Calculate all angles of a specific finger based on an Interpolator and input angles. </summary>
            <param name="finger"></param>
            <param name="interpolator"></param>
            <param name="totalAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.InterpolateThumbAngles(SGCore.Kinematics.HandInterpolator,SGCore.Kinematics.Vect3D)">
            <summary> Calculate all angles of the Thumb based on an Interpolator and input angles. </summary>
            <param name="interpolator"></param>
            <param name="totalAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.InterpolateHandAngles(SGCore.Kinematics.HandInterpolator,SGCore.Kinematics.Vect3D[])">
            <summary> Calculate all hand angles based on an interpolator and total xyz angles. </summary>
            <param name="profile"></param>
            <param name="totalAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.SetInterpolation(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary> Updates a particular joint movement interpolation, without changing its limits. </summary>
            <param name="finger"></param>
            <param name="movement"></param>
            <param name="inputAt0"></param>
            <param name="inputAt1"></param>
            <param name="angleAt0"></param>
            <param name="angleAt1"></param>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.SetInterpolation(SGCore.Finger,SGCore.Kinematics.FingerMovement,System.Single,System.Single,System.Single,System.Single)">
            <summary> Updates a particular joint movement interpolation, without changing its limits </summary>
            <param name="finger"></param>
            <param name="movement"></param>
            <param name="inputAt0"></param>
            <param name="inputAt1"></param>
            <param name="angleAt0"></param>
            <param name="angleAt1"></param>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.SetInterpolation(SGCore.Kinematics.ThumbMovement,System.Single,System.Single,System.Single,System.Single)">
            <summary> Updates a particular joint movement interpolation, without changing its limits </summary>
            <param name="movement"></param>
            <param name="inputAt0"></param>
            <param name="inputAt1"></param>
            <param name="angleAt0"></param>
            <param name="angleAt1"></param>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.GetInterpolation(System.Int32,System.Int32)">
            <summary> Returns an interpolationSet </summary>
            <param name="finger"></param>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.Serialize">
            <summary> Serialize this HandInterpolator into a string representation. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.Deserialize(System.String)">
            <summary> Convert a serialized HandInterpolator back into a class representation. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.HandInterpolator.BetweenPoses(SGCore.HandPose,SGCore.HandPose)">
            <summary> Generates a HandInterpolator that returns PoseAt0's handAngles at input 0, and PoseAt1's handAngles at input 1. </summary>
            <param name="poseAt0"></param>
            <param name="poseAt1"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.InterpolationSet">
            <summary> Set of variables to map a value from one range to the next. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.x0">
            <summary> First value of input range.</summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.x1">
            <summary> Second value of input range. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.y0">
            <summary> First value of output range. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.y1">
            <summary> Second value of output range. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.min">
            <summary> Minumum range of the output value. </summary>
        </member>
        <member name="P:SGCore.Kinematics.InterpolationSet.max">
            <summary> Maximum range of the output value. </summary>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.#ctor">
            <summary> Creates a basic interpolation set, without limits. </summary>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new interpolation set without limits. </summary>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new interpolation set with limits. </summary>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.#ctor(SGCore.Kinematics.InterpolationSet)">
            <summary> Create a new InterpolationSet with the same values as another. </summary>
            <param name="toCopy"></param>
        </member>
        <member name="M:SGCore.Kinematics.InterpolationSet.Get(System.Single,System.Boolean,System.Boolean)">
            <summary> Calculate an output value in range [x0...x1] to [y0..y1] </summary>
            <param name="value"> The input value to map to range [y0...y1] </param>
            <param name="limit"> Set to true to limit the value between [min...max] </param>
            <param name="normalizeAngle"> If this value is true, the output is limited between [-Pi, Pi]. </param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.JointKinematics">
            <summary> Class to calculate Sense Glove kinematics. </summary>
        </member>
        <member name="M:SGCore.Kinematics.JointKinematics.ForwardKinematics(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[]@,SGCore.Kinematics.Quat[]@)">
            <summary> 
            Perform foward Kinematics on a set of joints, defined by a start position- and rotation, 
            joint angles and the lenghts in between. Outputs the calculated positions and rotations.
            </summary>
            <param name="startPosition"></param>
            <param name="startRotation"></param>
            <param name="jointLengths"></param>
            <param name="jointAngles"></param>
            <param name="newPositions"></param>
            <param name="newRotations"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.JointKinematics.ForwardKinematics(SGCore.Kinematics.BasicHandModel,SGCore.Finger,SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[]@,SGCore.Kinematics.Quat[]@)">
            <summary> Calculate positions and rotations of a finger based on input angles and profile. </summary>
            <param name="profile"></param>
            <param name="finger"></param>
            <param name="jointAngles"></param>
            <param name="newPositions"></param>
            <param name="newRotations"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.JointKinematics.GetBestFinger(SGCore.Kinematics.Vect3D[],SGCore.Finger@,SGCore.Kinematics.Vect3D@)">
            <summary> Get the closest finger to the thumb? </summary>
            <param name="tipPositions"></param>
            <param name="bestFinger"></param>
            <param name="offset"></param>
        </member>
        <member name="T:SGCore.Kinematics.Quat">
            <summary> A rotation in 3D space that can be applied to a 3D vector or converted into Euler Angles. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.x">
            <summary> Quaternion element. Not directly related to a rotation or position. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.y">
            <summary> Quaternion element. Not directly related to a rotation or position. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.z">
            <summary> Quaternion element. Not directly related to a rotation or position. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.w">
            <summary> Quaternion element. Not directly related to a rotation or position. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Quat.identity">
            <summary> Represents 'no rotation' in quaternion space. </summary>
        </member>
        <member name="M:SGCore.Kinematics.Quat.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new Quaternion rotation. </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="w"></param>
        </member>
        <member name="M:SGCore.Kinematics.Quat.#ctor(SGCore.Kinematics.Quat)">
            <summary> Copy this Quat's values into another </summary>
            <param name="quatToCopy"></param>
        </member>
        <member name="M:SGCore.Kinematics.Quat.FromEuler(System.Single,System.Single,System.Single)">
            <summary> Create a new Quaternion from an euler angle representation. </summary>
            <param name="xAngle"></param>
            <param name="yAngle"></param>
            <param name="zAngle"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.FromEuler(SGCore.Kinematics.Vect3D)">
            <summary> Create a new Quaternion from an euler angle representation. </summary>
            <param name="euler"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.FromAngleAxis(System.Single,System.Single,System.Single,System.Single)">
            <summary> Create a new Quaternion Rotation from an angle-axis representation. </summary>
            <param name="angle"></param>
            <param name="axisX"></param>
            <param name="axisY"></param>
            <param name="axisZ"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.FromAngleAxis(System.Single,SGCore.Kinematics.Vect3D)">
            <summary> Create a new Quaternion Rotation from an angle-axis representation. </summary>
            <param name="angle"></param>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.ToString">
            <summary> Create a string representation of the Quaternion rotation. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.ToDeclaration">
            <summary> Creates a string to create this Quat in code. Useful for replicating test cases. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.ToEuler">
            <summary> Retrieve this Quaternion's euler angle notation. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Rotate(SGCore.Kinematics.Vect3D)">
            <summary> Rotate myVect by this quaternion rotation. </summary>
            <param name="v">The vector to rotate by</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Equals(SGCore.Kinematics.Quat,System.Single)">
            <summary> Check if two quaternions have equal values. </summary>
            <param name="that"></param>
            <param name="acceptableOffset"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.GetHashCode">
            <summary> Returns the hash code for this instance. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.IsIdentity">
            <summary> Check if this Quaternion is the identity quaternion (meaning it does not rotate anything.) </summary>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Magnitude">
            <summary> Returns the magnitude of this Quaternion. Used in normalization. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Normalized">
            <summary> Returns a unit length version of this quaternion. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.LookRotation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary>Calculate the Quat that, when applied to the "forward" axis and "up axis", results in the input vectors." In Unity notation, "forward" is Z, and "up" is Y. </summary>
            <param name="forward"></param>
            <param name="up"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.LookRotation_XYZ(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary>  Calculate the Quaternion that, when applied to (1, 0, 0), (0, 1, 0) and (0, 0, 1) will result in teh vectors X, Y, Z. </summary>
            <param name="X">In Orignal function - Side, calculated from Cross Up(input)-FWD, Unity (2D) Left/Right</param>
            <param name="Y">In Orignal function - UP, re-calculated from Cross SIDE-FWD, Unity (2D) Up/Down</param>
            <param name="Z">In Orignal function - Forward, Unity Z (towards screen)</param>
            <remarks> Based on the implementation at https://gist.github.com/aeroson/043001ca12fe29ee911e or https://answers.unity.com/questions/467614/what-is-the-source-code-of-quaternionlookrotation.html, 
            refactored somewhat to make it more readable, and added comments that reflect my own hand solved variables based on the sources from Quat.Rotate. </remarks>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Invert(SGCore.Kinematics.Quat)">
            <summary> Returns the inverse if q (a.k.a. a rotation in the other direction) </summary>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Normalize(SGCore.Kinematics.Quat)">
            <summary> Normalizes a quaternion to have a lenght of 1. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.op_Multiply(SGCore.Kinematics.Quat,SGCore.Kinematics.Quat)">
            <summary> Multiply one quaternion with another one. By order of operations, the q2 is rotated before q1. </summary>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.op_Multiply(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat)">
            <summary> Multiply this quaternion with a Vect3, a.k.a. rotate it. </summary>
            <param name="that"></param>
            <param name="q1"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.AbsErrorSum(SGCore.Kinematics.Quat,SGCore.Kinematics.Quat)">
            <summary> Returns the sum of the abs errors between each quaternion element. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.CalculateDifferences(SGCore.Kinematics.Quat[],SGCore.Kinematics.Quat[])">
            <summary> "subtract" q2  from q1 </summary>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.ToEuler(SGCore.Kinematics.Quat[])">
            <summary> Convert an array of Quat s to an array of Vect3D s. </summary>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Serialize(System.Char)">
            <summary> Serialize this quaternion with a delimiter. </summary>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Quat.Deserialize(System.String,SGCore.Kinematics.Quat@,System.Char)">
            <summary> Parse a Quaternion from a string. </summary>
            <param name="str"></param>
            <param name="result"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.Values">
            <summary> Utility class to convert values into various formats. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Values.Rad2Deg">
            <summary> Converts radians into degrees </summary>
        </member>
        <member name="F:SGCore.Kinematics.Values.Deg2Rad">
            <summary> Converts degrees into radians </summary>
        </member>
        <member name="F:SGCore.Kinematics.Values._2PI">
            <summary> 2*PI is used frequently in angle normalization </summary>
        </member>
        <member name="F:SGCore.Kinematics.Values.defaultFloatOffset">
            <summary> Offset between floating points. </summary>
        </member>
        <member name="M:SGCore.Kinematics.Values.Radians(SGCore.Kinematics.Vect3D)">
            <summary> Convert a vector of degrees angles into radians. </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Degrees(SGCore.Kinematics.Vect3D)">
            <summary> Convert a vector of radian angles into degrees. </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Degrees(SGCore.Kinematics.Vect3D[])">
            <summary> Convert and array of values from radians into degrees. </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Degrees(SGCore.Kinematics.Vect3D[][])">
            <summary> Convert and array of values from radians into degrees. </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.NormalizeAngle(System.Single)">
            <summary> Ensure that a single angle is within the [-Pi...Pi] range. </summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.NormalizeAngle(System.Single,System.Single,System.Single)">
            <summary> Normalize and angle between a variable range. </summary>
            <param name="angle"></param>
            <param name="minAngle"></param>
            <param name="maxAngle"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.NormalizeAngles(SGCore.Kinematics.Vect3D)">
            <summary> Normalize a set of angles in radians. </summary>
            <param name="angles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Clamp(System.Single,System.Single,System.Single)">
            <summary> Ensure that a value remains within the [min...max] range. </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary> Ensure that an integer value remains within the [min...max] range. </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Map(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Map a value from one range [from1...from2] to another range [to1 .. to2] </summary>
            <param name="value"></param>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Map(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary> Clamp the values beween the input and output values. </summary>
            <param name="value"></param>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
            <param name="clampOutput"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.Map(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Map a value from one range [from1...from2] to another range [to1 .. to2],
            while ensuring it stays within the [min...max] range. </summary>
            <param name="value"></param>
            <param name="from1"></param>
            <param name="from2"></param>
            <param name="to1"></param>
            <param name="to2"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateVectors(System.Single,System.Single,System.Single,SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][],System.Boolean)">
            <summary> Interpolate a 2D array of Vectors </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateVectors(System.Single,System.Single,System.Single,SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[],System.Boolean)">
            <summary> Interpolate an array of Vectors </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateVector(System.Single,System.Single,System.Single,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D,System.Boolean)">
            <summary> Interpolate a single Vector </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateQuaternion(System.Single,System.Single,System.Single,SGCore.Kinematics.Quat,SGCore.Kinematics.Quat,System.Boolean)">
            <summary> Interpolate a Quaternion Rotaion </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="q0"></param>
            <param name="q1"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.InterpolateHandAngles_WithJointAngles(System.Single,System.Single,System.Single,SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][],System.Boolean,System.Boolean)">
            <summary> Allows up to pass clamping, but still takes into account the joint angle limits. </summary>
            <param name="t"></param>
            <param name="t0"></param>
            <param name="t1"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="rightHand"></param>
            <param name="clamp"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.FillZero(System.Int32)">
            <summary> Returns an array of Vect3D's, all at 0, 0, 0. Used for quick generation and to avoid NullRefs </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.FillZero(System.Int32,System.Int32)">
            <summary> Returns a 2D of Vect3D's [Length, Width] all at 0, 0, 0. Used for quick generation and to avoid NullRefs </summary>
            <param name="length"></param>
            <param name="width"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.AbsErrorSum(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[])">
            <summary> Returns the sum of the absoulte difference between all elements of two vector arrays. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Values.AbsErrorSum(SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][])">
            <summary>  Returns the sum of the absoulte difference between all elements of two vector arrays. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Kinematics.Vect3D">
            <summary> Represents a vector with x,y,z coordinates. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Vect3D.x">
            <summary> X coordinate. Pronation/Supination for rotations. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Vect3D.y">
            <summary> Y coordinate. Flexion/Extension for rotations. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Vect3D.z">
            <summary> Z coordinate. Abduction/Adduction for rotations. </summary>
        </member>
        <member name="F:SGCore.Kinematics.Vect3D.zero">
            <summary> Represents a vector with coordinates (0, 0, 0). </summary>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.#ctor(System.Single,System.Single,System.Single)">
            <summary> Create a new Vect3D </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Z"></param>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.#ctor(SGCore.Kinematics.Vect3D)">
            <summary> Copy a vector's values into a new instace </summary>
            <param name="vectorToCopy"></param>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Magnitude">
            <summary> Calculate the magnitude or 'length' of this Vector </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Normalized">
            <summary> Returns this vector normalized to have a Magnitude on 1. </summary>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Scale(System.Single)">
            <summary> Scale all elements of this vector by a certain factor. </summary>
            <param name="s"></param>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.DistTo(SGCore.Kinematics.Vect3D)">
            <summary> Calculate the distance between this Vector and another one. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Equals(SGCore.Kinematics.Vect3D,System.Single)">
            <summary> Check if this Vector is roughly equal to another. </summary>
            <param name="that"></param>
            <param name="acceptableOffset"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.ToString">
            <summary> Create a string representation of this Vector. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.DotProduct(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Calculate the dot product between two vectors. If they're at 90 degree angles, the DP is 0. </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.CrossProduct(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Caluculate the Croos product between two vectors. THe result is an orthagonal vector. </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.AngleBetween(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary>   </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.op_Addition(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Add two vectors together. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.op_Subtraction(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Subtract two vectors from each other. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.op_Multiply(System.Single,SGCore.Kinematics.Vect3D)">
            <summary> Scale the vector v by factor S. </summary>
            <param name="S"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.op_Multiply(SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D)">
            <summary> Rotates a vector by a quaternion rotation. </summary>
            <param name="q"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.AbsErrorSum(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Calculates the difference between two vectors, and sums their (abs) differences. Useful if you want to know your error </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Add(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[])">
            <summary> Add v2 to v2 (v = v1 + v2) </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Subtract(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[])">
            <summary> Subtract v2 from v1. (v = v1 - v2) </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Subtract(SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][])">
            <summary> Subtract all corresponding vector elements from one another. </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Scale(SGCore.Kinematics.Vect3D[],System.Single)">
            <summary> Scale an array of Vectors by a global magnitude. </summary>
            <param name="v"></param>
            <param name="globalScale"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Deserialize(System.String,SGCore.Kinematics.Vect3D@,System.Char)">
            <summary> Create a Vect3D from a string representation. </summary>
            <param name="str"></param>
            <param name="result"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Kinematics.Vect3D.Serialize(System.Char)">
            <summary> Serialize this vector to store it on disk. </summary>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.BetaDevice">
            <summary> A Sense Glove device that is not yet added to the API. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.cString">
            <summary> The constants string retrieved when the device is first connected. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.deviceID">
            <summary> The deviceID of this Beta Device. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.hwVersion">
            <summary> The hardware (sub) version of this Beta Device. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.fwVersionMain">
            <summary> The firmware version of the Beta Device. </summary>
        </member>
        <member name="F:SGCore.BetaDevice.fwVersionSub">
            <summary> The firmware version of the Beta Device. </summary>
        </member>
        <member name="M:SGCore.BetaDevice.#ctor(System.String,System.String,System.String,System.String)">
            <summary> Creates a new instance of a Beta Device. </summary>
        </member>
        <member name="M:SGCore.BetaDevice.GetDeviceID">
            <summary> Retrieve this device's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetDeviceType">
            <summary> Retrieve the DeviceType of this SGDevice. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetHardwareVersion">
            <summary> Retrieve this device's hardware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetFirmwareVersion">
            <summary> Retireve this device's firmware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetSubFirmwareVersion">
            <summary>  Retireve this device's sub/minor firmware version </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetConstantsString">
            <summary> Retrieve the Constants string for additional processing. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetSensorData">
            <summary> Retrieve a raw sensor string from this Beta Device. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetLastCmd">
            <summary> Retireve a the last command retrieved from this Beta Device. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.SendCmd(System.String)">
            <summary> Send a raw string command to this device. </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.SendHaptics(System.String,System.Int32)">
            <summary> Send a command over the Haptics Track to the Beta device. </summary>
            <param name="haptics"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetHapticChannelInfo">
            <summary> Retrieve data class containign information about this device's haptic channels. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.ToString">
            <summary> Retrieve a string representation of this BetaDevice. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetBetaDevices">
            <summary> Returns a link to all connected Beta Devices. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetBetaDevice(SGCore.BetaDevice@)">
            <summary> Returns a reference to the very first Beta Device that is connected to the system. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetBetaDevice_ById(System.String,SGCore.BetaDevice@)">
            <summary> Returns true if a reference to a Beta Device that has the same DeviceID as the deviceID parameter could be found. </summary>
            <param name="deviceID"></param>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.GetBetaDevice_ByHwType(System.String,SGCore.BetaDevice@)">
            <summary> Returns true if a reference to a Beta Device that has the same hardware version as the hardwareVer parameter could be found. </summary>
            <param name="hardwareVer"></param>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.BetaDevice.Parse(System.String)">
            <summary> Parse a Beta Device from a cString. </summary>
            <param name="cString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Haptics.HapticLocation">
            <summary> Where this waveform is played </summary>
        </member>
        <member name="T:SGCore.Haptics.BuzzStream">
            <summary> Utility class to stream multiple buzz commands </summary>
        </member>
        <member name="F:SGCore.Haptics.BuzzStream.cmdQueue">
            <summary> The command queue </summary>
        </member>
        <member name="F:SGCore.Haptics.BuzzStream.maxCmdsInQueue">
            <summary> The maximum amount of commands that can be in a queue. </summary>
        </member>
        <member name="T:SGCore.Haptics.HG_HapticStream">
            <summary> A class to pile Force- and vibrotactile feedback into a single point, then flush them to a particular Glove. </summary>
        </member>
        <member name="F:SGCore.Haptics.HG_HapticStream.maxFFBCmds">
            <summary> The base maximum amount of Force-Feedback Commands that can be in a queue. </summary>
        </member>
        <member name="F:SGCore.Haptics.HG_HapticStream.maxBuzzCmds">
            <summary> The base maximum amount of Vibrotactile Commands that can be in a queue. </summary>
        </member>
        <member name="F:SGCore.Haptics.HG_HapticStream.maxThumpCmds">
            <summary> The base maximum amount of Thumper Commands that can be in a queue. </summary>
        </member>
        <member name="F:SGCore.Haptics.HG_HapticStream.ffbQueue">
            <summary> All FFB Commands that have been received this 'frame'. Will be flattened into a single command during FlushHapitcs. </summary>
        </member>
        <member name="F:SGCore.Haptics.HG_HapticStream.buzzQueue">
            <summary> All timed Buzz Commands that have been received this 'frame'. Will be flattened into a single command during FlushHapitcs. </summary>
        </member>
        <member name="F:SGCore.Haptics.HG_HapticStream.thumperQueue">
            <summary> All FFB Commands that have been received this 'frame'. Will be flattened into a single command during FlushHapitcs. </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.#ctor">
            <summary> Create a new HapticsStream for a Haptic Glove. </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.ClearFFB">
            <summary> Clears only the Force-Feedback Queue. </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.ClearVibrations">
            <summary> Clears all vibrations in the queue(s) </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.ClearThumper">
            <summary> Clears the thumper cmd queue. </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.ClearFingerVibrations">
            <summary> Clears all finger vibration </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.ClearAll">
            <summary> Clear all ongaoing effects to this stream. </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.AddCmd(SGCore.Haptics.SG_FFBCmd)">
            <summary> Add a new Force-Feedback command to the queue. Does not actually send it. </summary>
            <param name="ffbCmd"></param>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.AddCmd(SGCore.Haptics.SG_TimedBuzzCmd)">
            <summary> Add a new vibrotactile command to the queue. Does not actually send it. </summary>
            <param name="buzzCmd"></param>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.AddCmd(SGCore.Haptics.TimedThumpCmd)">
            <summary> Add a new Thumper command to the queue. Does not actually send it. Does not work with SenseGlove, only for Nova's </summary>
            <param name="thumpCmd"></param>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.UpdateTimedCommands(System.Single)">
            <summary> Update the active commands, using a deltaTime since last update, in seconds. Any timedCommands that are elapsed will be removed from the list. </summary>
            <param name="dT_seconds"></param>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.TotalFFBLevels(SGCore.Haptics.SG_FFBCmd)">
            <summary> Compiles all FFB Levels in the queue into a single one. Does not clear the queue. Returns lastFFBCmd if no FFB commands are given. </summary>
            <param name="lastFFB"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.TotalFFBLevels">
            <summary> Compiles all FFB Levels in the queue into a single one. Does not clear the queue. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.TotalBuzzLevels">
            <summary> Compiles all active vibrotactile in the queue into a single list of levels. Does not clear the queue. </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.TotalThumperLevels">
            <summary> Compiles all active vibrotactile in the queue into a single list of levels. Does not clear the queue. </summary>
        </member>
        <member name="M:SGCore.Haptics.HG_HapticStream.FlushHaptics(SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_FFBCmd@,SGCore.Haptics.SG_BuzzCmd@,SGCore.Haptics.ThumperCmd@,System.Boolean)">
            <summary> Compile all commands in the queue(s) into a single set of commands that can be sent to the glove. Only clears the FFB queue, and only if you want it to. </summary>
            <param name="lastBrakeLvl"></param>
            <param name="ffbCmd"></param>
            <param name="buzzCmd"></param>
            <param name="thumperCmd"></param>
            <param name="clearFFBqueue"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Haptics.HG_HapticStream.FlushHaptics(System.Single,SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_FFBCmd@,SGCore.Haptics.SG_BuzzCmd@,SGCore.Haptics.ThumperCmd@)" -->
        <member name="M:SGCore.Haptics.HG_HapticStream.FlushHaptics(SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_BuzzCmd,SGCore.Haptics.ThumperCmd,SGCore.Haptics.SG_FFBCmd@,SGCore.Haptics.SG_BuzzCmd@,SGCore.Haptics.ThumperCmd@)">
            <summary> Flushes the Hapitcs, but only returns true if the new cmds are different from the last ones - meaning we should send new Cmds.  Only clears the FFB queue</summary>
            <param name="lastBrakeLvl"></param>
            <param name="lastBuzzCmd"></param>
            <param name="lastThumper"></param>
            <param name="ffbCmd"></param>
            <param name="buzzCmd"></param>
            <param name="thumperCmd"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Haptics.HG_HapticStream.FlushHaptics(System.Single,SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_BuzzCmd,SGCore.Haptics.ThumperCmd,SGCore.Haptics.SG_FFBCmd@,SGCore.Haptics.SG_BuzzCmd@,SGCore.Haptics.ThumperCmd@)" -->
        <member name="T:SGCore.Haptics.IFingerFFB_SetLevels">
            <summary> Represents a device of which you can directly set the Force-Feedback level for one or more fingers. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Haptics.IFingerFFB_SetLevels.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.Haptics.IFingerFFB_SetLevels.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0f means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <remarks> Devices that 'only' have on/off FFB will treat any value > 0.0 as 1.0. </remarks>
            <returns>Returns true if the command was sucessfully added to the queue. If false, the device might not support the chosen finger(s) or have the appropriate firmware.</returns>
        </member>
        <member name="M:SGCore.Haptics.IFingerFFB_SetLevels.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucesfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="T:SGCore.Haptics.IFingerVibro_SetLevels">
            <summary> A device of which you can directly control the amplitude of vibration motors on each finger, at a set frequency. Note: You'll still have to turn these off! </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Haptics.IFingerVibro_SetLevels.QueueVibroLevels(System.Single[])" -->
        <member name="M:SGCore.Haptics.IFingerVibro_SetLevels.QueueVibroLevel(SGCore.Finger,System.Single)">
            <summary> Set the vibration amplitude of a particular finger to a specific level </summary>
            <param name="amplitude"> Value will be clamped between [0...1], where 0.0 means no vibration, and 1.0 means full vibration. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <remarks> Devices that 'only' have on/off vibration control will treat any value > 0.0 as 1.0. </remarks>
            <returns>Returns true if the command was sucessfully added to the queue. If false, the device might not support the chosen finger(s) or have the appropriate firmware.</returns>
        </member>
        <member name="M:SGCore.Haptics.IFingerVibro_SetLevels.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucesfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="T:SGCore.Haptics.IFingerFFB_Thresholds">
            <summary> Represents a Device that can automatically engage Force-Feedback on the finger(s) when a specific threshold is reached. </summary>
        </member>
        <member name="M:SGCore.Haptics.IFingerFFB_Thresholds.QueueThresholdCmd(SGCore.Finger,System.Single)">
            <summary> Queue a command to autmatically engage a finger's Force-Feedback when the sensor value exceeds a set threshold. </summary>
            <param name="sensorValueThreshold"> Sensor Value for thresholds. Not Flexion </param>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Haptics.IFingerFFB_Thresholds.QueueThresholdCmd_Flexion(SGCore.Finger,System.Single)">
            <summary> Stops the glove when flexing pas this point. </summary>
            <param name="finger"></param>
            <param name="flexionThreshold"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Haptics.IFingerFFB_Thresholds.QueueThresholdCmd_Flexions(System.Boolean[],System.Single[])" -->
        <member name="M:SGCore.Haptics.IFingerFFB_Thresholds.QueueClearThreshold(SGCore.Finger)">
            <summary> Queue a command to clear the threshold for a specific finger. </summary>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Haptics.IFingerFFB_Thresholds.QueueClearThresholds">
            <summary> Queue a command to clear the thresholds for each finger. </summary>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Haptics.IFingerFFB_Thresholds.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucesfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="T:SGCore.Haptics.ThresholdCmd">
            <summary> A command to set thresholds for specific fingers. Can be sent to a Device, or used internally. </summary>
        </member>
        <member name="P:SGCore.Haptics.ThresholdCmd.Thresholds">
            <summary> The Value at which to lock the finger(s), if ActiveFingers is true. </summary>
        </member>
        <member name="P:SGCore.Haptics.ThresholdCmd.ActiveFingers">
            <summary> The fingers that have a Threshold Mode active. If False, no thresholds should be activated. </summary>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.#ctor">
            <summary>  </summary>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.#ctor(System.Single[],System.Boolean[])">
            <summary>  </summary>
            <param name="thresholdValues"></param>
            <param name="affectedFingers"></param>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.#ctor(SGCore.Haptics.ThresholdCmd)">
            <summary> Copies the values of one ThresholdCmd into this Class. </summary>
            <param name="toCopy"></param>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.SetThreshold(System.Int32,System.Single)">
            <summary> Activates the threshold for a finger at a particular value. </summary>
            <param name="finger"></param>
            <param name="thresholdValue"></param>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.GetThreshold(System.Int32)">
            <summary> Retrieve the threshold of a particular finger </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.ClearThreshold(System.Int32)">
            <summary> Deactivates Threshold Mode for a particular finger. </summary>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.ClearThresholds">
            <summary> Disables Threshold mode for all fingers. Clears the ActiveFingers, but keeps the Thresholds value for now, in case you want to re-apply them later. </summary>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.ToString">
            <summary> Print the contents of this Threshold Command. If inactive, a '-' is shown. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.ThresholdCmd.Equals(SGCore.Haptics.ThresholdCmd)">
            <summary> Returns true if both values are exactly equal </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Haptics.TimedThumpCmd">
            <summary> A vibration command for the thumper. A pulse for a specific time in seconds.  </summary>
        </member>
        <member name="F:SGCore.Haptics.TimedThumpCmd.magnitude">
            <summary> Magnitude in % </summary>
        </member>
        <member name="F:SGCore.Haptics.TimedThumpCmd.duration">
            <summary> duration in seconds </summary>
        </member>
        <member name="F:SGCore.Haptics.TimedThumpCmd.elapsedTime">
            <summary> The elapsed time so far. </summary>
        </member>
        <member name="M:SGCore.Haptics.TimedThumpCmd.TimeElapsed">
            <summary> Returns true if the timed command has elapsed. </summary>
        </member>
        <member name="M:SGCore.Haptics.TimedThumpCmd.#ctor">
            <summary> Internal, empty, for extended classes. </summary>
        </member>
        <member name="M:SGCore.Haptics.TimedThumpCmd.#ctor(System.Int32,System.Single,System.Single)">
            <summary> Create a new Timed Thumper Command. </summary>
            <param name="amplitude">Value between 0 .. 1 representing the magnitude of the system.</param>
            <param name="duration_seconds"></param>
            <param name="startTime_seconds"></param>
        </member>
        <member name="M:SGCore.Haptics.TimedThumpCmd.#ctor(SGCore.Haptics.ThumperCmd,System.Single,System.Single)">
            <summary> Create a new Timed Thumper Command. </summary>
            <param name="baseCmd"></param>
            <param name="duration_seconds"></param>
            <param name="startTime_seconds"></param>
        </member>
        <member name="M:SGCore.Haptics.TimedThumpCmd.Update(System.Single)">
            <summary> Update the timing on this Thumper Command </summary>
            <param name="dT_seconds"></param>
        </member>
        <member name="M:SGCore.Haptics.TimedThumpCmd.Copy(System.Boolean)">
            <summary> Copy the parameters of this ThumperCommand into another instance. </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Haptics.PatternBuzzCmd">
            <summary>  </summary>
        </member>
        <member name="T:SGCore.Haptics.SG_BuzzCmd">
            <summary> A vibration command for the Sense Glove, with levels for each finger.  </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_BuzzCmd.buzzMin">
            <summary> The minimum buzz motor level input </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_BuzzCmd.buzzMax">
            <summary> The maximum buzz motor level input </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_BuzzCmd.off">
            <summary> A command that turns off all vibration motors of the Sense Glove. </summary>
        </member>
        <member name="P:SGCore.Haptics.SG_BuzzCmd.Off">
            <summary> Retrieve the command that turns off Buzz Motors </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_BuzzCmd.#ctor">
            <summary> Empty constructor for inheritance. </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_BuzzCmd.#ctor(System.Int32[])">
            <summary> Create a new buzz motor command, where each finger level is contained inside an array of size 5. </summary>
            <param name="buzzLvls"></param>
        </member>
        <member name="M:SGCore.Haptics.SG_BuzzCmd.#ctor(System.Boolean[],System.Int32)">
            <summary> Create a new instance of a BuzzCmd where specified fingers have the same buzz lvl. </summary>
            <param name="fingers"></param>
            <param name="buzzLvl"></param>
        </member>
        <member name="M:SGCore.Haptics.SG_BuzzCmd.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Create a new Buzz Motor command, indicating the intensity for each finger. </summary>
            <param name="thumb"></param>
            <param name="index"></param>
            <param name="middle"></param>
            <param name="ring"></param>
            <param name="pinky"></param>
        </member>
        <member name="M:SGCore.Haptics.SG_BuzzCmd.#ctor(SGCore.Finger,System.Int32)">
            <summary> Create a new Buzz Motor command, with only one finger being activated. </summary>
            <param name="finger"></param>
            <param name="level"></param>
        </member>
        <member name="M:SGCore.Haptics.SG_BuzzCmd.Validate(System.Int32)">
            <summary> Ensure that an input values is places in between the minimum and maximum range. </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_BuzzCmd.Merge(SGCore.Haptics.SG_BuzzCmd)">
            <summary> Merge this command with another, taking the maximum value between the two. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_BuzzCmd.Copy">
            <summary> Copy this Buzz Command into a new object. </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Haptics.SG_FFBCmd">
            <summary> A Force-Feedback command for the Sense Glove, with levels for each finger. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_FFBCmd.ffbMin">
            <summary> Minimum Force-Feedback Level </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_FFBCmd.ffbMax">
            <summary> Maximum Force-Feedback Level </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_FFBCmd.off">
            <summary> A command that turns off all force feedback on the Sense Glove. </summary>
        </member>
        <member name="P:SGCore.Haptics.SG_FFBCmd.Off">
            <summary> Retrieve the command that turns off Buzz Motors </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_FFBCmd.#ctor">
            <summary> Empty constructor for internal initialization. </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_FFBCmd.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Create a new Force-Feedback Command, with levels for each finger </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_FFBCmd.#ctor(SGCore.Finger,System.Int32)">
            <summary> Create a new Force-Feedback command, with only one finger being activated. </summary>
            <param name="finger"></param>
            <param name="level"></param>
        </member>
        <member name="M:SGCore.Haptics.SG_FFBCmd.#ctor(System.Int32[])">
            <summary> Create a new Force-Feedback Command, with levels for each finger stored in an int[5] array. </summary>
            <param name="ffbLevels"></param>
        </member>
        <member name="M:SGCore.Haptics.SG_FFBCmd.Validate(System.Int32)">
            <summary> Ensure that an input values is places in between the minimum and maximum range. </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_FFBCmd.Merge(SGCore.Haptics.SG_FFBCmd)">
            <summary> Merge this finger command with another, taking the maximum value between the two. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_FFBCmd.Copy">
            <summary> Copy the values of this Force Feedback command into a new object </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Haptics.SG_FingerCmd">
            <summary> A command that contains values (levels) for five fingers. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_FingerCmd.levels">
            <summary> Input level for specific finger. </summary>
        </member>
        <member name="P:SGCore.Haptics.SG_FingerCmd.ThumbLvl">
            <summary> Level of the Thumb. </summary>
        </member>
        <member name="P:SGCore.Haptics.SG_FingerCmd.IndexLvl">
            <summary> Level of the Index Finger. </summary>
        </member>
        <member name="P:SGCore.Haptics.SG_FingerCmd.MiddleLvl">
            <summary> Level of the Middle Finger. </summary>
        </member>
        <member name="P:SGCore.Haptics.SG_FingerCmd.RingLvl">
            <summary> Level of the Ring Finger. </summary>
        </member>
        <member name="P:SGCore.Haptics.SG_FingerCmd.PinkyLvl">
            <summary> Level of the Little Finger or Pinky. </summary>
        </member>
        <member name="P:SGCore.Haptics.SG_FingerCmd.Levels">
            <summary> Access the levels of this FingerCmd. </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_FingerCmd.GetLevel(System.Int32)">
            <summary> Get the level of a specific finger. </summary>
            <remarks> Marked internal to prevent IndexOutofRangeExceptions</remarks>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_FingerCmd.SetLevel(System.Int32,System.Int32)">
            <summary> Set the level of a specific finger. </summary>
            <remarks> Marked internal to prevent IndexOutofRangeExceptions</remarks>
            <param name="f"></param>
            <param name="lvl"></param>
        </member>
        <member name="M:SGCore.Haptics.SG_FingerCmd.#ctor">
            <summary> Creates a new haptic Command for the hand. </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_FingerCmd.Validate(System.Int32)">
            <summary> Ensure that a value is within acceptable range. </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_FingerCmd.Equals(SGCore.Haptics.SG_FingerCmd)">
            <summary> Check if this command contains the same values as another. </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_FingerCmd.SameLevels(SGCore.Haptics.SG_FingerCmd)">
            <summary> Non-overridebale function that checks specifically for FFB levels. </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_FingerCmd.ToString">
            <summary> Create a string representation of this finger command. </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Haptics.SG_ThumperCmd">
            <summary> A command to activate the Sense Glove Thumper Module, which is responsible for wrist feedback. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.None">
            <summary> We don't want the thumper to do anything right now... </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.TurnOff">
            <summary> Turn off the thumper effects. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Cue_Game_Over">
            <summary> A 5-second long, constant vibration. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Button_Double_100">
            <summary> A double-click at 100% intensity. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Button_Double_60">
            <summary> A double click at 60% intensity. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Impact_Thump_100">
            <summary> Simulates an impact of the hand at 100% intensity. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Impact_Thump_30">
            <summary> Simulates an impact of the hand at 30% intensity. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Impact_Thump_10">
            <summary> Simulates an sharp impact of the hand at 40% intensity. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Object_Grasp_100">
            <summary> A light vibration to cue the user that an object it picked up. 100% intensity. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Object_Grasp_60">
            <summary> A light vibration to cue the user that an object it picked up. 60% intensity. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_ThumperCmd.Object_Grasp_30">
            <summary> A light vibration to cue the user that an object it picked up. 30% intensity. </summary>
        </member>
        <member name="T:SGCore.Haptics.SG_TimedBuzzCmd">
            <summary> Buzz motor commands that is meant to stop after a few miliseconds. </summary>
            <remarks> Intended use; this.levels indicates the actual command </remarks>
        </member>
        <member name="F:SGCore.Haptics.SG_TimedBuzzCmd.baseCmd">
            <summary> The Buzz Motor command used to create the timing. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_TimedBuzzCmd.duration">
            <summary> The total time [millisecons] each buzz motor should be vibrating for. </summary>
        </member>
        <member name="F:SGCore.Haptics.SG_TimedBuzzCmd.elapsedTime">
            <summary> The time elapsed since the command was sent [millisecons]. </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.#ctor">
            <summary> Empty constructor for inheritance. </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.#ctor(SGCore.Finger,System.Int32,System.Single,System.Single)">
            <summary> Create a new TimeBuzzCommand for a single finger. </summary>
            <param name="finger"></param>
            <param name="magnitude"></param>
            <param name="duration_seconds"></param>
            <param name="startTime_seconds"></param>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.#ctor(SGCore.Haptics.SG_BuzzCmd,System.Single,System.Single)">
            <summary>
            Create a new buzz motor command that expires after timing_ms
            </summary>
            <param name="command"></param>
            <param name="duration_seconds"></param>
            <param name="startTime_seconds">Optional, starts the effect at a certain time</param>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.GetBaseCommand">
            <summary> Access the base command, which indicates the buzz levels to keep untill time elapses. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.TimeElapsed">
            <summary> Check if this timed command's timing has elapsed </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.NormalizedTime(System.Boolean)">
            <summary> Represents how far this effect is in its playtime; [0...1], where 0 means at the start, and 1 means at the end </summary>
            <param name="clamp01">Optional parameter; ensures this value is always between 0 and 1.</param>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.Copy">
            <summary> Copy this Buzz Command's values into a new object. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.Merge(SGCore.Haptics.SG_BuzzCmd)">
            <summary> Merges this basecommand with another command </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.ResetTiming">
            <summary> Reset the timings of this BuzzCmd, allowing us to re-use it. </summary>
        </member>
        <member name="M:SGCore.Haptics.SG_TimedBuzzCmd.UpdateTiming(System.Single)">
            <summary> Update the elapsed time to check if the buzz motors should stop. </summary>
            <param name="dT_seconds"></param>
        </member>
        <member name="T:SGCore.Haptics.ThumperCmd">
            <summary> A command that is sent to the wrist vibrotactile actuator, a.k.a. the "Thumper". </summary>
        </member>
        <member name="F:SGCore.Haptics.ThumperCmd.magnitude">
            <summary> Value between 0 and 100% </summary>
        </member>
        <member name="F:SGCore.Haptics.ThumperCmd.maxThump">
            <summary> Minimum allowed thumper magnitude. At this level, it's off </summary>
        </member>
        <member name="F:SGCore.Haptics.ThumperCmd.minThump">
            <summary> Maximum allowed thumper magnitude. At this level, it's at maximum intensity </summary>
        </member>
        <member name="P:SGCore.Haptics.ThumperCmd.Off">
            <summary> A command that represents turning the Thumper off. </summary>
        </member>
        <member name="M:SGCore.Haptics.ThumperCmd.#ctor(System.Int32)">
            <summary> Create a new Thumper Command </summary>
            <param name="intensity"></param>
        </member>
        <member name="M:SGCore.Haptics.ThumperCmd.Validate(System.Int32)">
            <summary> Validate the input values(s) of the ThumperCommand. </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.ThumperCmd.Merge(SGCore.Haptics.ThumperCmd)">
            <summary> Merge two ThumperCommands into one. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Haptics.ThumperCmd.Copy">
            <summary> Deep coop a thumper command </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.ConnectionStatus">
            <summary> Indictaes the status of a connection within the SGConnect library. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.Address">
            <summary> The Connection's COM or MAC address. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.ConnectionType">
            <summary> The type of connection this address is using. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.IsConnected">
            <summary> Whether or not this connection is active. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.LastConnectionCode">
            <summary> The latest Connection code. </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.LastExitCode">
            <summary> The last exit code </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.LastTestState">
            <summary> The latest testing stage, in case this isn't a SenseGlove Device </summary>
        </member>
        <member name="P:SGCore.Util.ConnectionStatus.DeviceType">
            <summary> The DeviceType connected to this port. </summary>
        </member>
        <member name="F:SGCore.Util.ConnectionStatus.connDelimm">
            <summary> Used in parsing. </summary>
        </member>
        <member name="M:SGCore.Util.ConnectionStatus.#ctor(System.String,SGCore.SGDevice.ConnectionType,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Create a new ConnectionStstus </summary>
            <param name="address"></param>
            <param name="connType"></param>
            <param name="connected"></param>
            <param name="connCode"></param>
            <param name="exitCode"></param>
            <param name="testStage"></param>
            <param name="devType"></param>
        </member>
        <member name="M:SGCore.Util.ConnectionStatus.ToString">
            <summary> A reportable string. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.ConnectionStatus.Parse(System.String)">
            <summary> Parse a ConnectionStatus into a proper data class. </summary>
            <param name="single"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.FileIO">
            <summary> Ensures that .txt files are properly handled by Unity. </summary>
        </member>
        <member name="M:SGCore.Util.FileIO.SaveTxtFile(System.String,System.String,System.String[],System.Boolean)">
            <summary> Attempt to save a string[] to a filename within a desired directory. Returns true if succesful. </summary>
            <remarks> Directory is added as a separate variable so we can more easily check for its existence. </remarks>
            <param name="dir"></param>
            <param name="fileName"></param>
            <param name="lines"></param>
            <param name="append"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.ReadTxtFile(System.String,System.String[]@)">
            <summary> Attempt to read all lines from a file and place them in the string[]. Returns true if succesful. If unable to open the file, the string[] will be empty.</summary>
            <param name="path"></param>
            <param name="lines"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.CreateDirectory(System.String)">
            <summary> Creates a new directory. Returns  false if it already existed. </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.GetMyDocumentsPath">
            <summary> Get the Path ot MyDocuments for Profiles </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.GetSenseGloveFileDirectory">
            <summary> Get the path for commonly accessed files, such as profiles </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.FileIO.GetSenseGloveCacheDirectory">
            <summary> Get the path for special SenseGlove Log locations and .ini files... </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.ListFormat">
            <summary> Indices to access DeviceList data in Shared Memory </summary>
        </member>
        <member name="T:SGCore.Util.SensorFormat">
            <summary> Indices to access Sensor Data in Shared Memory </summary>
        </member>
        <member name="T:SGCore.Util.Communications">
            <summary> "Database" containing communications bytes and conversions. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.cmdOpen">
            <summary> Byte indicating the start of a new command. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.cmdClose">
            <summary> Byte indicating the end of a command. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.senseOpen">
            <summary> Byte indicating the start of a new sensor data package. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.senseClose">
            <summary> Byte indicating the end of a sensor data package. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.listDelimiter">
            <summary> Denotes a block section of a DeviceList section. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.sectionDelimiter">
            <summary> ':' - Used to split a set of different contant values into individual groups. </summary>
        </member>
        <member name="F:SGCore.Util.Communications.colDelimiter">
            <summary> ';' - Used to separate individual values </summary>
        </member>
        <member name="F:SGCore.Util.Communications.rowDelimiter">
            <summary> '|' - Used to group a set of values, for example per finger. </summary>
        </member>
        <member name="M:SGCore.Util.Communications.ToSGByte(System.Int32)">
            <summary> Convert a value between 0..100 to a Sense Glove char/byte </summary>
            <param name="lvl"></param>
            <remarks> Placed here so that external parties do not get direct access to this. </remarks>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Communications.ToSGByte(System.Single)">
            <summary> Encodes a floating-point value into a command with a resolution of 100 steps. </summary>
            <param name="value01"></param>
            <remarks> Placed here so that external parties do not get direct access to this. </remarks>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Communications.ToSGBytes(System.Single[],System.Int32,System.Single)">
            <summary> Encode a series of floating-point values into a SenseGlove string </summary>
            <param name="values01"> An array of values that is to be encoded into multiple characters </param>
            <param name="messageLength"> The length of the message. </param>
            <param name="fallbackValue"> If values01 is not long enough to reach messageLength, pad valued with this </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Communications.EncodeLinear(System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary> Encode a single value into a character into a range of bytes. Will alsways clamp! </summary>
            <param name="value"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <param name="minByte"></param>
            <param name="maxByte"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Communications.DecodeLinear(System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary> Convert a decoded byte back into its original floating value. Useful for decoding. </summary>
            <param name="byteFromChar"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <param name="minByte"></param>
            <param name="maxByte"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.Serializer.FilterSpaces(System.String)">
            summary[ Filters spaces from a a string. /summary[
        </member>
        <member name="M:SGCore.Util.Serializer.SplitBlocks(System.String,System.Boolean)">
            summary[ Split a serialized string by its top level blocks /summary[
        </member>
        <member name="T:SGCore.Util.ServerData.Packet">
            <summary> Internal enumerator to parse packets </summary>
        </member>
        <member name="F:SGCore.Util.ServerData.dataDelim">
            <summary> Delimiter to parse data </summary>
        </member>
        <member name="M:SGCore.Util.ServerData.Update(System.String)">
            <summary> Updates data only </summary>
            <param name="fullGloveString"></param>
        </member>
        <member name="T:SGCore.Util.SGConnect_Android">
            <summary> Interface for the Android Library </summary>
            Since there is no Native Bluetooth SDK for Android, we have to use .aar files for now.
            There is no way to import such methods in C#, nor easily in C++. So instead, our Unity back-end handles Sending/Receiving to the API, and data ends up in this class.
        </member>
        <member name="T:SGCore.Util.SGConnect_Android.AndrSGDevice">
            <summary> Represents a block of memory for one SGDevice </summary>
        </member>
        <member name="F:SGCore.Util.SGConnect_Android.devices">
            <summary> The devices currently in memory </summary>
        </member>
        <member name="F:SGCore.Util.SGConnect_Android.scanningActive">
            <summary> Whether or not the devices have been initialized </summary>
        </member>
        <member name="F:SGCore.Util.SGConnect_Android.instance">
            <summary> Singleton instance of the android interface so we can access it statically.. </summary>
        </member>
        <member name="T:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs">
            <summary> Contains event data when one wishes to send data over Android </summary>
        </member>
        <member name="P:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs.DeviceIndex">
            <summary> Which of our devices to send haptics to. </summary>
        </member>
        <member name="P:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs.ChannelIndex">
            <summary> The Channel to send it to  </summary>
        </member>
        <member name="P:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs.HapticCommand">
            <summary> The actual haptics string to send over. </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.AndroidHapticEventArgs.#ctor(System.Int32,System.Int32,System.String)">
            <summary> Create a new instance of AndroidHapticEventArgs </summary>
            <param name="devIndex"></param>
            <param name="channel"></param>
            <param name="cmd"></param>
        </member>
        <member name="T:SGCore.Util.SGConnect_Android.AndroidHapticEventHandler">
            <summary> Delegate for the AndroidHapticEvent event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SGCore.Util.SGConnect_Android.AndroidHapticEvent">
            <summary> Fires when a new haptic command must be sent to the Android library. </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.#ctor">
            <summary> Default constructor for Instance </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.Cs_ActiveDevices">
            <summary> Check the number of devices detected by the system </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.Cs_ConnectionsRunning">
            <summary> Returns true if a device is currently posting data to this Interface. </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Util.SGConnect_Android.Cs_GetDeviceString(System.Int32,System.String@)" -->
        <member name="M:SGCore.Util.SGConnect_Android.Cs_GetSensorString(System.Int32,System.String@)">
            <summary> Retrieve lastes sensor data of a device </summary>
            <param name="deviceIndex"></param>
            <param name="sensorString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.Cs_SendHaptics(System.Int32,System.Int32,System.String)">
            <summary> Called from C# Code. Raises and event so that the Android Bridge can send it. </summary>
            <param name="deviceIndex"></param>
            <param name="channel"></param>
            <param name="hapticsToSend"></param>
            <returns>False if there is no event subscribers and nothing will therefre be sent...</returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.CS_GetConnectionStates(System.String@)">
            <summary> Retrieve states of each connection on this system.  </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_PostDeviceString(System.Int32,System.String)">
            <summary> Android-Only: Post a deviceString </summary>
            <param name="deviceIndex"></param>
            <param name="deviceString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_PostSensorData(System.Int32,System.String)">
            <summary> Android-Only: Post latest sensor data </summary>
            <param name="deviceIndex"></param>
            <param name="sensorData"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_Init">
            <summary> (Android Only) Let the software know we're active </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_Dispose">
            <summary> (Android Only) Once done with the devices, clear them from memory </summary>
        </member>
        <member name="M:SGCore.Util.SGConnect_Android.An_PostDeviceStates(System.String)">
            <summary> Android-Only: Post a Device State String if needed.  </summary>
        </member>
        <member name="T:SGCore.Util.StrStuff">
            <summary> Utility class to convert strings into useable values. </summary>
        </member>
        <member name="M:SGCore.Util.StrStuff.ToInt(System.String,System.Int32)">
            <summary> Convert a string into an integer value </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.StrStuff.ToFloat(System.String,System.Single)">
            <summary> Convert a string into a decimal value. </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.StrStuff.DegString(System.Single)">
            <summary> Convert a radian notation into a readable degrees string.  </summary>
            <param name="rad"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.StrStuff.QuickSplit(System.String,System.Char,System.Int32)">
            <summary> 
            Retrieve a single section from a delimited string at a specific index.
            It is much faster at lower indices.
            Use when only one section of a string is interesting to you.
            </summary>
            <param name="input"></param>
            <param name="delim"></param>
            <param name="getIndex"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Util.UDPSocket">
            <summary> Contains common functions for UPD Sockets </summary>
        </member>
        <member name="F:SGCore.Util.UDPSocket.client">
            <summary> Actual UDPClient to do work </summary>
        </member>
        <member name="F:SGCore.Util.UDPSocket.remoteEndPoint">
            <summary> used to access data. </summary>
        </member>
        <member name="P:SGCore.Util.UDPSocket.Port">
            <summary> Port that was created for this Socket </summary>
        </member>
        <member name="P:SGCore.Util.UDPSocket.IP">
            <summary> IP (default localHost) </summary>
        </member>
        <member name="P:SGCore.Util.UDPSocket.Connected">
            <summary> Whether or not this socket is conencted </summary>
        </member>
        <member name="P:SGCore.Util.UDPSocket.Address">
            <summary> The IP address of this socket. </summary>
        </member>
        <member name="M:SGCore.Util.UDPSocket.#ctor">
            <summary> Basic Constructor </summary>
        </member>
        <member name="M:SGCore.Util.UDPSocket.Finalize">
            <summary> Ensure Dispose is called </summary>
        </member>
        <member name="M:SGCore.Util.UDPSocket.Connect(System.Int32,System.String)">
            <summary> Connect to a specific IP Port. </summary>
            <param name="_port"></param>
            <param name="_IP"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.UDPSocket.Dispose">
            <summary> Dispose Unmanaged Resources </summary>
        </member>
        <member name="T:SGCore.Util.UDPReceiver">
            <summary> A UDPReceiver which reads data in a readthread (since it's blocking) </summary>
        </member>
        <member name="F:SGCore.Util.UDPReceiver.receiveThread">
            <summary> Thread to receive data </summary>
        </member>
        <member name="F:SGCore.Util.UDPReceiver.getData">
            <summary> Keeps the thread alive </summary>
        </member>
        <member name="F:SGCore.Util.UDPReceiver.lastReceivedUDPPacket">
            <summary> Last data received by UDP </summary>
        </member>
        <member name="F:SGCore.Util.UDPReceiver.sf_Packet">
            <summary> Semaphore to protect simultaneous access </summary>
        </member>
        <member name="P:SGCore.Util.UDPReceiver.pingTime_ms">
            <summary> Time in between data received </summary>
        </member>
        <member name="P:SGCore.Util.UDPReceiver.LastData">
            <summary> Accessor for the last data received from UDP Socket </summary>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.#ctor">
            <summary> Basic Constructor </summary>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.Finalize">
            <summary> Ensure stuff gets disposed </summary>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.Connect(System.Int32,System.String)">
            <summary> Connect to a specific IP address and start up the Readthread. </summary>
            <param name="_port"></param>
            <param name="_IP"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.Dispose">
            <summary> Dispose of unmanaged resources. </summary>
        </member>
        <member name="M:SGCore.Util.UDPReceiver.ReceiveData">
            <summary> Is run by the Thread. </summary>
        </member>
        <member name="T:SGCore.Util.UDPSender">
            <summary> Sends Strings over UDP. </summary>
        </member>
        <member name="M:SGCore.Util.UDPSender.#ctor">
            <summary> Basic constructor </summary>
        </member>
        <member name="M:SGCore.Util.UDPSender.Finalize">
            <summary> Ensure stuff gets disposed </summary>
        </member>
        <member name="M:SGCore.Util.UDPSender.Connect(System.Int32,System.String)">
            <summary> Connects to a specific IP address </summary>
            <param name="_port"></param>
            <param name="_IP"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Util.UDPSender.SendString(System.String)">
            <summary> Send a string over the socket. </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.CV.CV_Tracking_Depth">
            <summary> How much of the CV tracking is being used. Used by other APIs. </summary>
        </member>
        <member name="F:SGCore.CV.CV_Tracking_Depth.Disabled">
            <summary> No computer-vision is enabled. </summary>
        </member>
        <member name="F:SGCore.CV.CV_Tracking_Depth.WristOnly">
            <summary> Use CV only for the wrist position / rotation </summary>
        </member>
        <member name="F:SGCore.CV.CV_Tracking_Depth.WristAndHandPose">
            <summary> Use CV for both the wirst location and Hand Position  </summary>
        </member>
        <member name="T:SGCore.CV.CV_HandPoints">
            <summary> Used to access specific positions from the CV output, which is an array of Vect3D positions. </summary>
            <remarks> Declared in CVHandOutput.cs because these enums are used to index the jointPositions array in that class. </remarks>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_WRIST">
            <summary> The position of the wrist as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_THUMB_CMC">
            <summary> The position of the Thumb CMC Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_THUMB_MCP">
            <summary> The position of the Thumb MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_THUMB_IP">
            <summary> The position of the Thumb IP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_THUMB_TIP">
            <summary> The position of the Thumb tip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_INDEX_MCP">
            <summary> The position of the Index MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_INDEX_PIP">
            <summary> The position of the Index PIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_INDEX_DIP">
            <summary> The position of the Index DIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_INDEX_TIP">
            <summary> The position of the Index fingertip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_MIDDLE_MCP">
            <summary> The position of the Middle MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_MIDDLE_PIP">
            <summary> The position of the Middle PIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_MIDDLE_DIP">
            <summary> The position of the Middle DIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_MIDDLE_TIP">
            <summary> The position of the Middle fingertip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_RING_MCP">
            <summary> The position of the Ring MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_RING_PIP">
            <summary> The position of the Ring PIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_RING_DIP">
            <summary> The position of the Ring DIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_RING_TIP">
            <summary> The position of the Ring fingertip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_PINKY_MCP">
            <summary> The position of the Pinky MCP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_PINKY_PIP">
            <summary> The position of the Pinky PIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_PINKY_DIP">
            <summary> The position of the Pinky DIP Joint as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_PINKY_TIP">
            <summary> The position of the Pinky fingertip as determined by the CV Model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandPoints.CV_All">
            <summary> Utility enumerator to check if an array contains enough values. </summary>
        </member>
        <member name="T:SGCore.CV.CV_HandOutput">
            <summary> Contains output from one of our CV Model, specifically that for a hand / glove. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandOutput.timeStamp">
            <summary> Simulation time When this Data was received. Used for data smoothing. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandOutput.jointPositions">
            <summary> 21 positions, representing the wrist and finger positions in 3D (world)space. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandOutput.handedNess">
            <summary> 0 = left hand, 1 = right hand. Use IsRight for a simple boolean access. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandOutput.rightHandThreshold">
            <summary> If the handednNess is above this threshold, the hand is considered, a 'right hand' </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandOutput.certaintyFactor">
            <summary> How certain is it that this is an actual hand that we're tracking.  </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandOutput.fingerCertainties">
            <summary> How certain we are about each finger.  </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandOutput.forDevice">
            <summary> Which Device this data has been generated for </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandOutput.forHwVersion">
            <summary> (sub)hardware version that this data has been generated for. </summary>
        </member>
        <member name="P:SGCore.CV.CV_HandOutput.IsValid">
            <summary> Returns true if enough Data is available. </summary>
        </member>
        <member name="P:SGCore.CV.CV_HandOutput.IsRight">
            <summary> Returns true if the CV Model estimated this to be a right hand.  </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandOutput.#ctor(SGCore.Kinematics.Vect3D[],SGCore.DeviceType,System.String,System.Single)">
            <summary> Create a new CVHandOutput instance, with an autmatically generated TimeStamp.</summary>
            <param name="CVHandPoints"></param>
            <param name="forDeviceType"></param>
            <param name="subHwVersion"></param>
            <param name="rightHandedNess"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandOutput.#ctor(SGCore.Kinematics.Vect3D[],SGCore.DeviceType,System.String,System.Single,System.Single)">
            <summary> Create a new CVHandOutput instance with a custom timestamp. </summary>
            <param name="CVHandPoints"></param>
            <param name="forDeviceType"></param>
            <param name="subHwVersion"></param>
            <param name="rightHandedNess"></param>
            <param name="time"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandOutput.GetPosition(SGCore.CV.CV_HandPoints)">
            <summary> Safely retrieve the location of a specific joint. </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandOutput.MatchesDevice(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Returns true if this pose was made for a specific hand, device, and sub-hw version. </summary>
            <param name="isRight"></param>
            <param name="type"></param>
            <param name="hwVer"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandOutput.MatchesDevice(SGCore.CV.CV_HandOutput)">
            <summary> Returns true if this pose was made for the same device as another pose. </summary>
            <param name="otherPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandOutput.ToString">
            <summary> Get a simple notation of this CVHandOutput. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandOutput.PrintKeyPoints(System.String)">
            <summary> Prints all of the joint positions within this CVHandOutput. </summary>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.CV.CV_Kinematics">
            <summary> Kinematic Algorithms for Computer Vision. Much like JointKinematics, this static class contains the fance mathematics. </summary>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateTrackingData(SGCore.CV.CV_HandOutput,SGCore.CV.CV_HandDataPoint@,System.Boolean)">
            <summary> Converts CV output (21 joint positions + handed-ness) into a handDataPoint. Returns true if the calculation is succesful. </summary>
            <param name="pose"></param>
            <param name="dataPoint"></param>
            <param name="naturalLimits">If true, joint angles are clamped within their natural limits. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateHandPoseAngles(SGCore.CV.CV_HandOutput,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@,SGCore.Kinematics.Vect3D[][]@,System.Boolean)">
            <summary> Calculates the  wrist location and hand angles and based on the 21 keypoints + handedness in our CV Output. </summary>
            <param name="pose"></param>
            <param name="wristWorldPos"></param>
            <param name="wristWorldRot"></param>
            <param name="handAngles"></param>
            <param name="naturalLimits"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateWristLocation(SGCore.CV.CV_HandOutput,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Calculate the wrist position and -rotation from a set of keypoints that describe the finger. </summary>
            <param name="pose"></param>
            <param name="wristWorldPos"></param>
            <param name="wristWorldRot"></param>
        </member>
        <member name="F:SGCore.CV.CV_Kinematics.cmcLimitLeft">
            <summary> It's a right hand if our we process it as a right hand and the CMC joint is 'below' the wrist by this much. </summary>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CheckForRightHand(SGCore.Kinematics.Vect3D[],System.Boolean@)">
            <summary> In case  Martijn's Data doesn't say, to a manual check for the left/right handedness. 90% accurate so far. </summary>
            <param name="cvPositions"></param>
            <param name="rightHanded"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.EstimateAbd(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Calculates the most likely Abduction (z) angle. All of these positons must be relative to the first joint (CMC or MCP), in the thumb/finger coordinate system. </summary>
            <param name="medialJoint"></param>
            <param name="distalJoint"></param>
            <param name="fingerTip"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateLastFlexion(System.Single,System.Single,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D)">
            <summary> Calculates the flexion of the last joint, based on  </summary>
            <param name="j0Flex"></param>
            <param name="j1Flex"></param>
            <param name="tipRelToj0"></param>
            <param name="j2RelToj0"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_Kinematics.CalculateHandAngles(SGCore.CV.CV_HandOutput,SGCore.Kinematics.Quat,System.Boolean)">
            <summary> The actual hand angle calculations. First we define a "working plane"; joint start rotation + abduction. j0 flexion is calculated using aTan2, j1 flexion using vector.anglebetween.
            finally, j2 flexion is calculated using aTan2 again, using j0's reference frame. </summary>
            <param name="pose"></param>
            <param name="wristWorldRot"></param>
            <param name="naturalLimits"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:SGCore.CV.CV_HandLayer" -->
        <member name="F:SGCore.CV.CV_HandLayer.requestedDeviceCount">
            <summary> The amount of devices that should be visible to the CV camera. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandLayer.forDevice">
            <summary> Which deviceType are detected and are being used to run the model. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandLayer.forHwVer">
            <summary> Optional sub-hardware-type that is being used to run the moddel </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandLayer.simStart">
            <summary> Initialized upon the dll being loaded. The automatic simulation time will be based on this class </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandLayer.smoothedData">
            <summary> Hand Data smoothers, with entries for each hand / glove / hw combinations. Expecting there won't be more than 2 of these. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.GetSimulationTime">
            <summary> Retrieve the current simulation time - used for generating timestamps. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.DataIndex(SGCore.CV.CV_HandOutput)">
            <summary> Returns the index within smoothedData that matches the handednedd / glove / subtype combination of a particular output. </summary>
            <param name="cvData"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.DataIndex(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Returns the index within smoothedData that matches the handednedd / glove / subtype combination. </summary>
            <param name="rightHand"></param>
            <param name="devType"></param>
            <param name="hwVer"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.PostHandData(SGCore.CV.CV_HandOutput)">
            <summary> Post new CV output once it becomes available. Will be used to calculate smoothed Data </summary>
            <param name="cvData"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.ClearCVData">
            <summary> Clear all Data from memory. Useful if you're restarting. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.PoseAvailable(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Returns true if data is available for a hand of a specific handedness / DeviceType / hwVersion </summary>
            <param name="rightHand"></param>
            <param name="deviceType"></param>
            <param name="hwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.TryGetPose(System.Boolean,SGCore.DeviceType,System.String,SGCore.CV.CV_HandDataPoint@,System.Boolean)">
            <summary> Returns true if  the data was succesfully gathered. Simulation time is gathered GetSimulationTime(). </summary>
            <param name="rightHand"></param>
            <param name="deviceType"></param>
            <param name="hwVersion"></param>
            <param name="handData"></param>
            <param name="clampValues"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandLayer.TryGetPose(System.Single,System.Boolean,SGCore.DeviceType,System.String,SGCore.CV.CV_HandDataPoint@,System.Boolean)">
            <summary> Returns true if  the data was succesfully grathered for a custom timeStamp. </summary>
            <param name="currentTime"></param>
            <param name="rightHand"></param>
            <param name="deviceType"></param>
            <param name="hwVersion"></param>
            <param name="handData"></param>
            <param name="clampValues"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.CV.CV_HandDataPoint">
            <summary> CVHandOutput converted into HandAngles + wrist location. Has all the information needed to determine when and how to convert this data into an actual HandPose. </summary>
            <remarks> Can generate a "smoothed" version of this via the HandDatSmoothing or just return the latets one. </remarks>
        </member>
        <member name="F:SGCore.CV.CV_HandDataPoint.timeStamp">
            <summary> The data point's timestamp, used for smoothing </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataPoint.handAngles">
            <summary> The HandAngles caluclated at ttimeStamp </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataPoint.wristWorldPosition">
            <summary> The wrist position calculated at timeStamp </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataPoint.wristWorldRotation">
            <summary> The wrist rotation calculated at timeStamp </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataPoint.rightHand">
            <summary> Whether or not this data point was generated for a left- or right hand </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataPoint.globalCertainty">
            <summary> Certainties of the whole hand tracking. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataPoint.fingerCertainties">
            <summary> Certainites of individual fingers. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandDataPoint.#ctor">
            <summary> Created empty arrays and data. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandDataPoint.#ctor(System.Boolean,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D[][],System.Single,System.Single[],System.Single)">
            <summary> Create a new instance of a HandDataPoint with a custom timestamp. </summary>
            <param name="isRight"></param>
            <param name="wristPos"></param>
            <param name="wristRot"></param>
            <param name="fingerAngles"></param>
            <param name="time"></param>
            <param name="globalCert"></param>
            <param name="fingerCert"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataPoint.#ctor(System.Boolean,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D[][],System.Single,System.Single[])">
            <summary> Create a new instance of a HandDataPoint using an autmatically generated timestamp. </summary>
            <param name="isRight"></param>
            <param name="wristPos"></param>
            <param name="wristRot"></param>
            <param name="fingerAngles"></param>
            <param name="globalCert"></param>
            <param name="fingerCert"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataPoint.ToString">
            <summary> Prints the tracking data of this HandDataPoint </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataPoint.ToHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Convert the handAngles etc of this HandDataPoint into an acual HandPose </summary>
            <param name="handDimensions"></param>
            <param name="handPose"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataPoint.ToHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Convert the handAngles etc of this HandDataPoint into an acual HandPose </summary>
            <param name="handDimensions"></param>
            <param name="handPose"></param>
            <param name="wristPosition"></param>
            <param name="wristRotation"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataPoint.InterpolateData(SGCore.CV.CV_HandDataPoint,SGCore.CV.CV_HandDataPoint,System.Single,System.Boolean)">
            <summary> Interpolate beween two HandDataPoints to generate a new one </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="t"></param>
            <param name="clampOutput"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataPoint.InterpolateData(System.Single,SGCore.CV.CV_HandDataPoint,SGCore.CV.CV_HandDataPoint,System.Boolean,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@,SGCore.Kinematics.Vect3D[][]@)">
            <summary> Interpolate all Hand Data between two points. </summary>
            <param name="t"></param>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="clampOutput"></param>
            <param name="wristPos"></param>
            <param name="wristRot"></param>
            <param name="handAngles"></param>
        </member>
        <member name="T:SGCore.CV.CV_HandDataSmoother">
            <summary> Keeps track of a small history of CV Outputs to compensate for low(er) update rates. For example, running a VR simulation at 90Hz while sampling at 30. </summary>
        </member>
        <member name="T:SGCore.CV.CV_HandDataSmoother.SmoothingMethod">
            <summary> The way handPoses are smoothed in this class. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.SmoothingMethod.None">
            <summary> None. You'll always get the latest pose received. No performance increase, but might result in a "stop-motion" effect on lower framerates.  </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.SmoothingMethod.InterpolateBehind">
            <summary> Pretend you're one sample behind, and interpolate along the exact paths. More accurate, but we will lag 1 frame behind. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.SmoothingMethod.ExtrapolateAhead">
            <summary> Take the last two handPoses and estimate the current values based on extrapolation. Is percieved as "faster", but is more likely to overhoot during sudden changes in direction.  </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.initialInput">
            <summary> What the HandPos was originally made for. Used to deterime which DeviceType / Handedness / subHW version this data was generated for. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.maxDataPoints">
            <summary> The maximum amount of points we keep track of for smoothed hand data. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.lastFrames">
            <summary> The last X amount of frames this data keeps in memory. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.smoothMethod">
            <summary> The way in which we're smoothing the incoming data </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.lastSmoothedData">
            <summary> When using SmoothingMethod.ExtrapolateAhead: The last dmoothed data, used to determine projection and PosAtPrediction when both are null. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.projection">
            <summary> When using SmoothingMethod.ExtrapolateAhead: What the next frame is estimated to look like, based on the last two data points. </summary>
        </member>
        <member name="F:SGCore.CV.CV_HandDataSmoother.posAtPrediction">
            <summary> When using SmoothingMethod.ExtrapolateAhead: The variables we had calculated to be at during the last GetSmoothedPose call. </summary>
            <remarks> Interpolating from this to the projection as opposed to the last two frames, so that we don't "jump" around. </remarks>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.#ctor(SGCore.CV.CV_HandOutput)">
            <summary> Create a new instance of Smoothed Hand Data, using a first frame. </summary>
            <param name="firstFrame"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.MatchesDevice(SGCore.CV.CV_HandOutput)">
            <summary> Returns true if this Smoother was created for the same device as the one of this cvPose. Used in CVHandLayer </summary>
            <param name="cvPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.MatchesDevice(System.Boolean,SGCore.DeviceType,System.String)">
            <summary> Returns true if this Smoother was created for a particular hand / deviceType / hw. Used in CVHandLayer </summary>
            <param name="isRight"></param>
            <param name="type"></param>
            <param name="hwVer"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.ClearFrames">
            <summary> Clear smoothing data. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.FrameCount">
            <summary> The amount of frames currently in this smoother (0 .. maxDataPoints). </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.GetFrame(System.Int32,SGCore.CV.CV_HandDataPoint@)">
            <summary> Safely retrieve a HandDataPoint out of this class' frame buffer. </summary>
            <param name="index"></param>
            <param name="frame"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.AddFrame(SGCore.CV.CV_HandOutput)">
            <summary> Post new CVHandOutput into this Smoother, which will converted into handAngles and calculate the appropriate values.. </summary>
            <param name="nextFrame"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.UpdateProjection">
            <summary> Updates Projection values, which is used when using SmoothingMethod.ExtrapolateAhead. </summary>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.SetLastSmoothed(SGCore.CV.CV_HandDataPoint)">
            <summary> Since the last smoothed pose is updated every time I request one, I need to keep track of it When using SmoothingMethod.ExtrapolateAhead </summary>
            <param name="newSmoothedData"></param>
        </member>
        <member name="M:SGCore.CV.CV_HandDataSmoother.GetSmoothedPose(System.Single,SGCore.CV.CV_HandDataPoint@,System.Boolean)">
            <summary> Based on the last X frames in this buffer, each with an earlier timestamp, Retrieve Smoothed Hand Data at currentTime </summary>
            <param name="currentTime">Time at which this data is requested, used to interpolate / extrapolate. </param>
            <param name="smoothedData"> Output: Smoothed Hand Data </param>
            <param name="clampValues"> If true, any smoothed output pose cannot 'extend' beyond the latest (predicted) values. </param>
            <returns></returns>
        </member>
        <member name="T:SGCore.HapticChannelType">
            <summary> Different types of Haptic Channels - with different behaviours </summary>
        </member>
        <member name="F:SGCore.HapticChannelType.StreamingChannel">
            <summary> This type of haptic channel can be constantly overridden. SGConnect will only send a command if a change occurs. Ideal for Force-Feedback. </summary>
        </member>
        <member name="F:SGCore.HapticChannelType.FireAndForgetChannel">
            <summary> These commands must be sent once, after thire queue is cleared. </summary>
        </member>
        <member name="T:SGCore.HapticChannelInfo">
            <summary> Contains information on Haptic channels as recieved via SGConnect.  </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.streamingType">
            <summary> Byte used to identify streaming channels </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.fireNforgetType">
            <summary> byte used to indicate fire-and-forget channels. </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.streamIndices">
            <summary> Becuase the names are dependent of device index, and I want to be able to regenerate them, I need to keep track of the original number... </summary>
        </member>
        <member name="F:SGCore.HapticChannelInfo.fNfIndices">
            <summary> Becuase the names are dependent of device index, and I want to be able to regenerate them, I need to keep track of the original number... </summary>
        </member>
        <member name="M:SGCore.HapticChannelInfo.#ctor">
            <summary> Creates a default HapticChannelInfo, with solely a single streaming haptic Channel </summary>
        </member>
        <member name="M:SGCore.HapticChannelInfo.#ctor(System.Int32[],System.Int32[])">
            <summary>  </summary>
            <param name="streamInd"></param>
            <param name="fireNforgetInd"></param>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetStreamChannelCount">
            <summary> Returns the amount of streaming channels available for haptics. Will indicate if a device can support the haptics you're trying to send through it. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetFireAndForgetChannelCount">
            <summary> Returns the amount of fire-and-forget channels available for haptics. Will indicate if a device can support the haptics you're trying to send through it. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetTotalChannelCount">
            <summary> retrieve the total amount of channels for this device. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetAddress_Unguarded(SGCore.HapticChannelType,System.Int32)">
            <summary> Returns the address that corresponds to the nth channel of a specific type. It's unguarded, which means I dont check the validity of index - could result in an exception. Optimized piece of code for for loops. </summary>
            <param name="type"></param>
            <param name="typeIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetIPCParams_Unguarded(SGCore.HapticChannelType,System.Int32,System.Int32@,System.String@)">
            <summary> Returns the address that corresponds to the nth channel of a specific type. It's unguarded, which means I dont check the validity of index - could result in an exception. Optimized piece of code for for loops. Used for Internals </summary>
            <param name="type"></param>
            <param name="typeIndex"></param>
            <param name="addressString"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.RegenerateAddresses(System.Int32)">
            <summary> Regenerate the channel names for a specific device Index in shared memory. </summary>
            <param name="forDeviceIndex"></param>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GetAllAddresses">
            <summary> Returns an array of all the haptic addrsses stored for this info channel. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.GenerateAddress(System.Int32,System.Int32)">
            <summary> Generate a single IPCAddress for an address. </summary>
            <param name="deviceIndex"></param>
            <param name="channelIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticChannelInfo.Parse(System.String)">
            <summary> Parse HapticChannelInfo received through IPC into useable data </summary>
            <param name="ipcString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Calibration.CalibrationStage">
            <summary> Startup Stage used to indicate where of not a glove must be recalibrated. </summary>
        </member>
        <member name="F:SGCore.Calibration.CalibrationStage.MoveFingers">
            <summary> We've only just started up. User needs to move their hands so we know if we're still in the same sensor range. </summary>
        </member>
        <member name="F:SGCore.Calibration.CalibrationStage.CalibrationNeeded">
            <summary> After moving, we've determined that a calibration must happen for proper hand tracking to happen. </summary>
        </member>
        <member name="F:SGCore.Calibration.CalibrationStage.Calibrating">
            <summary> After moving, we've determined that a calibration must happen for proper hand tracking to happen. </summary>
        </member>
        <member name="F:SGCore.Calibration.CalibrationStage.Done">
            <summary> We've determined that this needs no (more) calibration to function as intended. </summary>
        </member>
        <member name="T:SGCore.Calibration.HG_CalCheck">
            <summary> An algorithm that checks whether or not our current user is running in the same calibration range as last time. </summary>
        </member>
        <member name="P:SGCore.Calibration.HG_CalCheck.CalibrationStage">
            <summary> The current stage of this algorithm </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.lastRange">
            <summary> The calibration range from last time, that we are checking against. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.currentRange">
            <summary> The calibration range measured as of right now. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.perfectThresholdTime">
            <summary> If we're 'around' the lastRange for this amount of time, we're calling it 'done'. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.timer_atThreshold">
            <summary> Time that we've been around the last range for. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.movedMinimum">
            <summary> Whether or not we've moved a minimum amount. Something that even someone with the smallest hands can do. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.minMoveTime">
            <summary> After moving the minimum amount of time but not reaching the perivous range, we'll say the hand is too small. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.timer_MinMove">
            <summary> Time since we made the minumum amount of movement </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.outOfBoundsTime">
            <summary> The amount of time the current values can be out of range for. Catches a minor case where sensor jitter causes us to be outside of the range. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.timer_outOfBounds">
            <summary> Time we've been out of bounds for. </summary>
        </member>
        <member name="P:SGCore.Calibration.HG_CalCheck.ReachedConclusion">
            <summary> Whether or not his algorithm has determined if calibration is required. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_CalCheck.#ctor(SGCore.Calibration.SensorRange)">
            <summary> The last calibration range can be null, at which point you defnitely need calibration. </summary>
            <param name="lastCalibrationRange"></param>
        </member>
        <member name="M:SGCore.Calibration.HG_CalCheck.Reset">
            <summary> Reset the calibrationCheck. so it may be used again. This does not reset the LastRange. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_CalCheck.CheckRange(SGCore.Kinematics.Vect3D[],System.Single,SGCore.DeviceType)">
            <summary> Using the currently received Sensor Values, check if calibration is required. This function will have to be called until a conclusion can be reached. </summary>
            <param name="currentValues"></param>
            <param name="deltaTime_s"></param>
            <param name="deviceType"></param>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.sgThreshold">
            <summary> SenseGlove: How far from the threshold one can be where we would still call it 'the same as before' </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.novaThreshold">
            <summary> Nova: How far from the threshold one can be where we would still call it 'the same as before' </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.sgMinFlex">
            <summary> SenseGlove: The minumum amount of sensor flexion movement before we start testing for a smaller hand. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.novaMinFlex">
            <summary> Nova: The minumum amount of sensor flexion movement before we start testing for a smaller hand. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.sgMinAbd">
            <summary> SenseGlove: The minumum amount of sensor movement on the thumb abduction before we start testing for a smaller hand. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalCheck.novaMinAbd">
            <summary> Nova: The minumum amount of sensor movement on the thumb abduction before we start testing for a smaller hand. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_CalCheck.NeedsCheck(SGCore.DeviceType)">
            <summary> Returns true if this DeviceType requires a calibration check. </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalCheck.OutOfBounds(SGCore.Calibration.SensorRange,SGCore.Kinematics.Vect3D[],SGCore.DeviceType)">
            <summary> Checks if current values are operating out of the previous range. Returns -1 if all is fine. 0...4 to indicate which finger is out of bounds. </summary>
            <param name="previousRange"></param>
            <param name="currentValues"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalCheck.MovedMinimum(SGCore.Kinematics.Vect3D[],SGCore.DeviceType)">
            <summary> Returns true if the user has moved enough in both flexion and thumb abduction movement to be considered 'active' </summary>
            <param name="currentRange"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalCheck.MatchesLast(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[],SGCore.DeviceType)">
            <summary> Returns true if the current sensor values have moved roughly as much as last time. </summary>
            <param name="currentRange"></param>
            <param name="lastRange"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalCheck.GetDebugString(SGCore.Kinematics.Vect3D[],SGCore.DeviceType)">
            <summary> Returns a string value informing me which fingers still need to move. Move Thumb, Index, Middle, Ring, Pinky etc. </summary>
            <param name="currentRange"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Calibration.CalDataPoint">
            <summary> A data point for Calibration, stored in a separate class so we can add / tweak it wihtout affecting the function calls. </summary>
        </member>
        <member name="F:SGCore.Calibration.CalDataPoint.calibrationValues">
            <summary> Actual calibration values. </summary>
        </member>
        <member name="F:SGCore.Calibration.CalDataPoint.stage">
            <summary> The Calibration stage this belongs to. </summary>
        </member>
        <member name="M:SGCore.Calibration.CalDataPoint.#ctor(System.Int32,SGCore.Kinematics.Vect3D[])">
            <summary> Create a new data point </summary>
            <param name="currSate"></param>
            <param name="calVals"></param>
        </member>
        <member name="M:SGCore.Calibration.CalDataPoint.ToLogData(System.String)">
            <summary> Log Calibration values for storing on disk </summary>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Calibration.HG_CalibrationSequence">
            <summary> A sequence which collects data points untill specific criteria have been met. It must be 'fed' an Update command from your program in order to work. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalibrationSequence.iGlove">
            <summary> Glove linked to this calibration sequence. Will attempt to gram data from this glove evey time Update() is called. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalibrationSequence.calibrationPoints">
            <summary> Calibration points colledted during this calibration process. One is added every thme the "Update()" function is called.
            Used to create a profile after the calibration finishes. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalibrationSequence.maxDataPoints">
            <summary> The maximum buffer size for calibration points. Once calibrationPoints exceeds this value, the  </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_CalibrationSequence.elapsedTime">
            <summary> How much time has elapsed during this calibration sequence. Useful for logging or for automated functions. </summary>
        </member>
        <member name="P:SGCore.Calibration.HG_CalibrationSequence.ManualCompleted">
            <summary> Used to determine if the user has manually ended the sequence, to prevent us from adding any more calibration points. </summary>
        </member>
        <member name="P:SGCore.Calibration.HG_CalibrationSequence.HandModel">
            <summary> Kinematic information to generate a calibration preview pose. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.#ctor">
            <summary> Basic constructor for subclasses to inherit from </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.#ctor(SGCore.HapticGlove)">
            <summary> Create a new instance of a base HapitcGlove Calibration Sequence. </summary>
            <param name="gloveToCalibrate"></param>
        </member>
        <member name="P:SGCore.Calibration.HG_CalibrationSequence.CurrentStageInt">
            <summary> If a sequence consists of multiple stages, this integer will show you which one is currently active. </summary>
        </member>
        <member name="P:SGCore.Calibration.HG_CalibrationSequence.LinkedGlove">
            <summary> The Glove linked to this Calibration Sequence. Can be changed or re-assigned. </summary>
        </member>
        <member name="P:SGCore.Calibration.HG_CalibrationSequence.DataPointCount">
            <summary> Returns the amount of calibration points collected so far </summary>
        </member>
        <member name="P:SGCore.Calibration.HG_CalibrationSequence.AutoCompleted">
            <summary> Whether or not this sequence was completed as per it's own rules </summary>
            <returns></returns>
        </member>
        <member name="P:SGCore.Calibration.HG_CalibrationSequence.Completed">
            <summary> Returns true if this sequence is marked as 'complete' and can begin compiling a profile. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.Reset">
            <summary> Resets this calibration sequence's data, but not it's LinkedGlove. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.AddDataPoint(SGCore.Kinematics.Vect3D[])">
            <summary> Safely adds calibration data. Automatically done within 'Update' </summary>
            <param name="calibrationData"></param>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.Update(System.Single)">
            <summary> Update this calibration sequence with new data. We use deltaTime to check for things like stability. </summary>
            <param name="deltaTime_s"></param>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.ConfirmCurrentStep">
            <summary> Manual confirmation of whatever step we're supposed to making at the moment. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.CompileRange(SGCore.Calibration.SensorRange@)">
            <summary> Compile a min/max range from the datapoints collected by this sequence. Returns true if it's actually possible. </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.CompileProfile(SGCore.DeviceType,System.Boolean,SGCore.HandProfile@)">
            <summary> Compile a profile from the datapoints collected by this sequence. Returns true if it's actually possible.  </summary>
            <param name="forDevice"></param>
            <param name="rightHand"></param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.CompileProfile(SGCore.Calibration.SensorRange,SGCore.DeviceType,System.Boolean,SGCore.HandProfile@)">
            <summary> Converts a calibration range taken from a Calibration sequence, and converts it into a profile. Use this if you're not actually using the sequence. </summary>
            <param name="range"></param>
            <param name="forDevice"></param>
            <param name="rightHand"></param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.GetHandPose(SGCore.HandPose@)">
            <summary> Returns the current HandPose; either the one we should be making, or what it would look like at the moment.  </summary>
            <param name="currentPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.GetHandPose(System.Boolean,SGCore.HandPose@)">
            <summary> Returns the current HandPose; either the one we should be making, or what it would look like at the moment.  </summary>
            <param name="rightHand"></param>
            <param name="currentPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Retrieve a handPose based on set hand dimensions. </summary>
            <param name="handDimensions"></param>
            <param name="currentPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.GetCurrentInstuction(System.String)">
            <summary> Retrieve instructions on what to do during the current step. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_CalibrationSequence.GetDebugInfo">
            <summary> Retrieve debug information from the sequence </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Calibration.HG_QuickCalibration">
            <summary> A quick version that just requires you to open / close your hand for a few seconds, and compiles a profile out of that. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_QuickCalibration.autoEndAfter">
            <summary> time, in seconds, after which this sequence stops gathering data. Based on the DeltaTime variable passed in the Update() function. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_QuickCalibration.autoEndTime">
            <summary> Default time in seconds, to end this sequence. 15 seconds is very quick for some people. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_QuickCalibration.smoothingSamples">
            <summary> When compiling the final profile, we use a Weighted Moving Average filter with this period to filer out some outliers. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_QuickCalibration.movedTime">
            <summary> Time after you've first started moving. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_QuickCalibration.sensorRange">
            <summary> The min/max values recorded during this calibration sequence. </summary>
        </member>
        <member name="F:SGCore.Calibration.HG_QuickCalibration.tempProfile">
            <summary> A temporary profile to apply the sensorRange to. Used to generate a 'preview' HandPose. </summary>
        </member>
        <member name="P:SGCore.Calibration.HG_QuickCalibration.CanAnimate">
            <summary> Determines if the user has moved enough so that we can animate. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.#ctor(SGCore.HapticGlove)">
            <summary> Create a new instance of a QuickCalibration for Haptic Gloves. </summary>
            <param name="gloveToCalibrate"></param>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.#ctor(SGCore.HapticGlove,System.Single)">
            <summary> Create a new instance of a QuickCalibration for Haptic Gloves. </summary>
            <param name="gloveToCalibrate"></param>
            <param name="endAfter_s"></param>
        </member>
        <member name="P:SGCore.Calibration.HG_QuickCalibration.AutoCompleted">
            <summary> This sequence autocmpletes after its autoEndTime has elapsed. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.ConfirmCurrentStep">
            <summary> After we confirm the current step, we're basically done. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.Reset">
            <summary> Resets datapoints, min/max ranges and profile. </summary>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.Update(System.Single)">
            <summary> Update this calibration sequence with new data. We use deltaTime to check for things like stability. </summary>
            <param name="deltaTime_s"></param>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.AddDataPoint(SGCore.Kinematics.Vect3D[])">
            <summary> Add a new datapoint to this sequence's collection. Updates the range and profile used to generate a preview. </summary>
            <param name="calibrationData"></param>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.CompileRange(SGCore.Calibration.SensorRange@)">
            <summary> Compile a sensor range from the data points collected while the sequence was running. Smoothed by a Moving Average Filter. </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.GetCurrentInstuction(System.String)">
            <summary> Retrieve instructions on what to do during the current step.  </summary>
            <param name="nextStepKey"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.GetHandPose(System.Boolean,SGCore.HandPose@)">
            <summary> Returns a 'preview' of what a HandPose with this sequence's current settings would look like.  </summary>
            <param name="rightHand"></param>
            <param name="currentPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Returns a 'preview' of what a HandPose with this sequence's current settings would look like. </summary>
            <param name="handDimensions"></param>
            <param name="currentPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.HG_QuickCalibration.GetDebugInfo">
            <summary> Returns the Debug info. </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Calibration.SensorRange">
            <summary> A calibrationRange that contains minimum / maximum sensor values of a HapticGlove. Used in calibration </summary>
        </member>
        <member name="F:SGCore.Calibration.SensorRange.minVals">
            <summary> The minimum sensor values of this sensor range </summary>
        </member>
        <member name="F:SGCore.Calibration.SensorRange.maxVals">
            <summary> The maximum sensor values of this sensor range </summary>
        </member>
        <member name="P:SGCore.Calibration.SensorRange.Range">
            <summary> The difference between min and max values in this Sensor Range. </summary>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.#ctor">
            <summary> Create a new instance of a SensorRange with values at 0, 0 </summary>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.#ctor(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[])">
            <summary> Create a new SensorRange with predefined Min/Max values. </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.#ctor(SGCore.Calibration.SensorRange)">
            <summary> Deep copy another calibration range into a new instance. </summary>
            <param name="copy"></param>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.ForCalibration">
            <summary> Generates a Sensor Range where minumum values are float.MaxValue and maximum values are float.MinValue. </summary>
            <returns></returns>
        </member>
        <member name="P:SGCore.Calibration.SensorRange.MinValues">
            <summary> Access the lowest values values of this range. </summary>
        </member>
        <member name="P:SGCore.Calibration.SensorRange.MaxValues">
            <summary> Access the highest values values of this range. </summary>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.UpdateRange">
            <summary> Update the Range based on the current minVals and MaxVals. </summary>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.CheckForExtremes(SGCore.Kinematics.Vect3D[])">
            <summary> In otherValues are greater/small than the current range, update to them </summary>
            <param name="otherValues"></param>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.ToString(System.Boolean)">
            <summary> Convert this SensorRange into a string rotation [min ... max] </summary>
            <param name="yOnly"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.RangeString(System.Boolean)">
            <summary> Report the Range value of this SensorRange, separated by a comma </summary>
            <param name="yOnly"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.CheckMax(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D@)">
            <summary> Evaluate maxVals so that it contains the highest x, y, and z values between currVals and maxVals. </summary>
            <param name="currVals"></param>
            <param name="maxVals"></param>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.CheckMin(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Vect3D@)">
            <summary> Evaluate minVals so that it contains the lowest x, y, and z values between currVals and minVals. </summary>
            <param name="currVals"></param>
            <param name="minVals"></param>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.Serialize">
            <summary> Serialize this SensorRange into a string representation, that can be deserialized later. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Calibration.SensorRange.Deserialize(System.String)">
            <summary> Convert a serialized SensorRange back into the appropriate class. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.HG_HandProfiles">
            <summary> A helpful class to store / access calibration profiles on / off disk. </summary>
        </member>
        <member name="F:SGCore.HG_HandProfiles.leftProfile">
            <summary> Profile for the left hand </summary>
        </member>
        <member name="F:SGCore.HG_HandProfiles.rightProfile">
            <summary> Profile for the right hand </summary>
        </member>
        <member name="F:SGCore.HG_HandProfiles.profileDir">
            <summary> The location on disk where the profiles are stoed and retrieved from. Differs in Windows and Android. </summary>
        </member>
        <member name="F:SGCore.HG_HandProfiles.leftHandFile">
            <summary> Name of the file containing the left-hand profile in ProfileDirectory </summary>
        </member>
        <member name="F:SGCore.HG_HandProfiles.rightHandFile">
            <summary> Name of the file containing the right-hand profile in ProfileDirectory </summary>
        </member>
        <member name="F:SGCore.HG_HandProfiles.rangeDir">
            <summary> A SubDirectory of ProfileDirectory to store the last calibration ranges used for a device. </summary>
        </member>
        <member name="F:SGCore.HG_HandProfiles.triedLoading">
            <summary> Determines if we hava tried to load a profile from disk yet. If yes, and it still doesn't exist, we generate one. </summary>
        </member>
        <member name="P:SGCore.HG_HandProfiles.ProfileDirectory">
            <summary> Returns the directory where our HandProfiles are stored. </summary>
        </member>
        <member name="P:SGCore.HG_HandProfiles.RightHandProfile">
            <summary> Access the latest Right Hand Profile </summary>
        </member>
        <member name="P:SGCore.HG_HandProfiles.LeftHandProfile">
            <summary> Access the latest Left Hand Profile </summary>
        </member>
        <member name="M:SGCore.HG_HandProfiles.GetProfile(System.Boolean)">
            <summary> Retrieve a left- or right handed profile. </summary>
            <param name="rightHand"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HG_HandProfiles.SetProfile(SGCore.HandProfile)">
            <summary> Store a profile in the global variables and on disk. The profile determines if this is a left- or right hand. </summary>
            <param name="profile"></param>
        </member>
        <member name="M:SGCore.HG_HandProfiles.SetProfile(SGCore.HandProfile,System.Boolean)">
            <summary> Store a profile in the global variables and on disk. You determine if this is a left- or right hand. </summary>
            <param name="profile"></param>
            <param name="rightHand"></param>
        </member>
        <member name="M:SGCore.HG_HandProfiles.RestoreDefaults">
            <summary> Restore both profiles back to their default values. </summary>
        </member>
        <member name="M:SGCore.HG_HandProfiles.RestoreDefaults(System.Boolean)">
            <summary> Restore the left- or right hand profiles back to their default values. </summary>
            <param name="rightHand"></param>
        </member>
        <member name="M:SGCore.HG_HandProfiles.TryLoadFromDisk">
            <summary> Load the latest profiles from disk. Automatically called when you first try to access a profile.
            Exposed so you can force-reload profiles. </summary>
        </member>
        <member name="M:SGCore.HG_HandProfiles.LoadProfile(System.String,SGCore.HandProfile@)">
            <summary> Load a profile form a file, return true if it was succesfully deserialized. </summary>
            <param name="filePath"></param>
            <param name="currProfile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HG_HandProfiles.SaveLastRange(SGCore.Calibration.SensorRange,SGCore.HapticGlove)">
            <summary> Stores the last sensor range of a glove. </summary>
            <param name="currentRange"></param>
            <param name="forGlove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HG_HandProfiles.LoadLastRange(SGCore.HapticGlove,SGCore.Calibration.SensorRange@)">
            <summary> Loads the last sensor range of a glove. </summary>
            <param name="forGlove"></param>
            <param name="lastRange"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Nova.Nova_Calibration">
            <summary> Contain utility code to assist in calibrating your Nova Glove. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_Calibration.ApplyInterpolationValues_DefaultCalibration(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[],SGCore.Nova.Nova_Profile@)">
            <summary> Apply a glove's default interpolation values to a profile, using the 'default' hand angles from calibration </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_Calibration.ApplyInterpolationValues(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Vect3D[][],SGCore.Nova.Nova_Profile@)">
            <summary> Apply a set of sensor-to-joint-angle interplations to a nova profile. </summary>
            <param name="retractedValues"></param>
            <param name="extendedValues"></param>
            <param name="retractedAngles"></param>
            <param name="extendedAngles"></param>
            <param name="profile"></param>
        </member>
        <member name="T:SGCore.Nova.Nova_HapticStream">
            <summary> A buffer to queue and flush Nova commands specifically. Not guarateed to work with other devices. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.FingerForceLevels">
            <summary> The force-feedback levels of each finger that is desired for this frame (0 .. 1). </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.fingerFFBUpdate">
            <summary> Whether or not the finger FFB data has been updated this frame, or if we need to fall back to the 'last command' </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.lastFFBLevels">
            <summary> The last FFB levels that were sent to the glove. Used as a fallback in case there are no updates needed. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.AddForceLevel(System.Int32,System.Single)">
            <summary> Sets the force level for a specific finger in the buffer. </summary>
            <param name="level01"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.StoreLastFFB(System.Single[])">
            <summary> Copy a set of FFB levels into the 'previous command', which will be used as a fallback value in case no change is made to a specific finger. </summary>
            <param name="levels"></param>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.NextThresholdCmd">
            <summary> The Next Threshold command to send next frame. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.lastThresholds">
            <summary> The last sent threshold command. Used to check if an update is required. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.LastThresholdCmd">
            <summary> Access the last sent threshold command. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.FingerVibroLevels">
            <summary> The finger vibration levels that are desired for this frame. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.fingerVibroUpdate">
            <summary> whether or not there have been updates to the finger vibration this frame </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.lastVibroLevels">
            <summary> The last vibro that were sent to the glove. Used as a fallback when no update is made. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.AddVibrationLevel(System.Int32,System.Single)">
            <summary> Sets the amplitude for a specific finger in the buffer. </summary>
            <param name="amplitude"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.StoreLastVibro(System.Single[])">
            <summary> Copy a set of amplitiudes into the 'previous command', which will be used as a fallback value in case no change is made to a specific finger. </summary>
            <param name="levels"></param>
        </member>
        <member name="P:SGCore.Nova.Nova_HapticStream.WristVibroLevel">
            <summary> The desired Thumper vibration level for this frame </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.wristVibroUpdate">
            <summary> Whether or not a thumper command was sent this frame </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_HapticStream.lastWristLevel">
            <summary> The last vibro that were sent to the glove. Used as a fallback in case there isn't anything sent this frame </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.AddWristCommand(System.Single)">
            <summary> Sets the Latest Wrist Level to a desired level </summary>
            <param name="amplitude"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.StoreLastWrist(System.Single)">
            <summary> Copy an amplitiude into the 'previous command', which will be used as a fallback value in case no change is made to the wrist. </summary>
            <param name="wrist"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.#ctor">
            <summary> Create a new Nova HapticStream </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.CompileTraditionalCommands(System.Single[]@,System.Single[]@,System.Single@)">
            <summary> Compile the commands into a set of traditional Nova Commands. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.ClearAllCommands">
            <summary> Clears any active command(s) on the Nova Glove, completely resetting the stream. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticStream.ResetBuffer">
            <summary> Removes all non-active or elapsed Nova effects from the stream, ready for the next frame. </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_VibroMotor">
            <summary> Specific vibration motor location(s) for the Nova's </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_VibroMotor.AllMotors">
            <summary> All possible motor locations. Warning: May not give you the best haptic feeling. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_VibroMotor.BackOfHand">
            <summary> Vibration motor located at the back of the hand. A.k.a. "The Thumper" </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_VibroMotor.ThumbTip">
            <summary> Vibration motor located at the tip of the thumb </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_VibroMotor.IndexFingerTip">
            <summary> Vibration motor located at the tip of the index finger </summary>
        </member>
        <member name="T:SGCore.Nova.WaveformType">
            <summary> Waveform type for an advanced Buzz Command </summary>
        </member>
        <member name="F:SGCore.Nova.WaveformType.Sine">
            <summary> Smooth sine wave </summary>
        </member>
        <member name="F:SGCore.Nova.WaveformType.Square">
            <summary> Can shift duty Cycle </summary>
        </member>
        <member name="F:SGCore.Nova.WaveformType.SawUp">
            <summary> Inverse of SawDown  </summary>
        </member>
        <member name="F:SGCore.Nova.WaveformType.SawDown">
            <summary> Inverse of SawUp </summary>
        </member>
        <member name="F:SGCore.Nova.WaveformType.Triangle">
            <summary> Triangle waveform </summary>
        </member>
        <member name="F:SGCore.Nova.WaveformType.Noise">
            <summary> A random, noisy signal </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_Waveform">
            <summary> Allows for extended vibration commands. Can be applied to any finger, and any actuator, but there is no guarantee the associated actuator will actually do so. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.minAttackTime">
            <summary> The maximum attack time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.maxAttackTime">
            <summary> The maximum attack time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.minSustainTime">
            <summary> The minimum value for sustain time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.maxSustainTime">
            <summary> The maximum sustain time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.minDecayTime">
            <summary> The maximum attack time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.maxDecayTime">
            <summary> The maximum attack time, in seconds. Used for Encoding. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.freqRangeMin">
            <summary> Minimum Frequency Range </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.freqRangeMax">
            <summary> Maximum Frequency Range </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.maxRepeatAmount">
            <summary> Maximum amount a singnal is allowed to repeat, limited by encoding. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.minAmplitude">
            <summary> The minimum master control 'volume'. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.maxAmplitude">
            <summary> The maximum master control 'volume'. </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.minFreqFactor">
            <summary> Minimum value of minimum frequency factor </summary>
        </member>
        <member name="F:SGCore.Nova.Nova_Waveform.maxFreqFactor">
            <summary> Maximum value of minimum frequency factor</summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.Amplitude">
            <summary> The total amplitude of the wavefrom, represented by 0 (off) or 1 (maximum value) </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.WaveType">
            <summary> The Type of waveform pattern that is used. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.Infinite">
            <summary> Whether or not this Waveform is infinitely repeating </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.RepeatAmount">
            <summary> The amount of times to repeat this waveform. 1 is the default. If set to 0, repreats indefinitely. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.AttackTime">
            <summary> Time, in seconds, before the signal reaches its maximum amplitude. Limited to 0.01 - 1s. Set to 0 for an instant start. Linear only </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.SustainTime">
            <summary> Time, in seconds, to keep the signal at one Amplidue. Limited to 0.01 - 1s. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.DecayTime">
            <summary> Time it takes for the effect to fade out after AttackTime+SuatainTime has passed. Limited to 0.01 - 1s. Set to 0 for instant stop. Linear only </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.FrequencyStart">
            <summary> The Wavefrom Frequency at the start of the wavefrom. Limited between [10 - 500Hz] for Nova Gloves </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.FrequencyEnd">
            <summary> The Frequency at the end of the waveform. Keep the same as FrequencyStart to have one conitnuous frequency.  Limited between [10 - 500Hz] for Nova Gloves </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.FrequencySwitchTime">
            <summary> value of [0..1], repesenting a perentage of total time (attack+sustain+decay). After that moment passes, we increase the frequency by FrequencySwicth factor </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.FrequencySwitchFactor">
            <summary> After a certain % of the waveform (FrequencySwitchTime) plays, multiply the frequency by this factor [1x .. 3x]  </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.EffectTime">
            <summary> The total command time. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.TotalEffectTime">
            <summary> Time total time for the entire effect (effecttime multipled by the repeatamount) </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_Waveform.FrequencyJumps">
            <summary> If true, the frequency of this waveform jumps at any time during its playtime by FrequencySwitchFactor. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_Waveform.#ctor">
            <summary> Default constructor with all values set to 0 - even the frequency? </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_Waveform.#ctor(SGCore.Nova.Nova_Waveform)">
            <summary> Create a new BuzzCommand with the exact same parameters. </summary>
            <param name="wfToCopy"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_Waveform.#ctor(System.Single,System.Single)">
            <summary> A basic waveform to vibrate at a specific amplitude for a specific duration  </summary>
            <param name="amplitude"> Should be between 0 (off) and 1 (full vibration force) </param>
            <param name="duration"> A time in seconds, limited from 0 to 1s? </param>
        </member>
        <member name="M:SGCore.Nova.Nova_Waveform.#ctor(System.Single,System.Single,System.Single)">
            <summary> A basic waveform to vibrate at a specific amplitude for a specific duration  </summary>
            <param name="amplitude"></param>
            <param name="duration"> A time in seconds, limited from 0 to 1s? </param>
            <param name="frequency"> 10 Hz to 510 Hz </param>
        </member>
        <member name="M:SGCore.Nova.Nova_Waveform.ToString">
            <summary> Create an easy-enough string representation of this custom waveform. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_Waveform.Equals(SGCore.Nova.Nova_Waveform)">
            <summary> Returns true if a Waveform has the exact same parameters as this one. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Nova.Nova_HapticEncoder">
            <summary> Non-exposed class that converts command classes into encoded strings. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticEncoder.RepeatByte(System.Int32,System.Boolean)">
            <summary> Encode a 'repeat' byte based on the amount of times someone wants to repeat it, vs whether or not its set to infinite. </summary>
            <param name="repeatAmout"></param>
            <param name="infinite"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticEncoder.ToNovaCommand(SGCore.Nova.Nova_Waveform,SGCore.Nova.Nova_VibroMotor)">
            <summary> Encodes the values of a Nova_Waveform into a command that can be sent to the Nova Glove. </summary>
            <param name="waveform"></param>
            <param name="motor"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_HapticEncoder.DecodeWaveform(System.String,SGCore.Nova.Nova_Waveform@,SGCore.Nova.Nova_VibroMotor@)">
            <summary> Decode a command back into a waveform (though it won't be exactly the same due to the resolution of said encoding). </summary>
            <param name="command"></param>
            <param name="waveform"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Nova.NovaGlove">
            <summary> A soft glove with detachable force-feedback and sensor module. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.hapticsByte">
            <summary> Byte indicating a new Sense Glove haptic command. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.minCalRange">
            <summary> Minumum calibration value distance until we apply the range. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.gloveInfo">
            <summary> Contains Nova-specific device information. Contained inside its own class. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.hapticStream">
            <summary> Special Nova Haptic Stream to buffer commands. </summary>
        </member>
        <member name="F:SGCore.Nova.NovaGlove.lastTraditionalCmd">
            <summary> Used to more eaailty detect change in setting FFB / vibro command. </summary>
        </member>
        <member name="P:SGCore.Nova.NovaGlove.SupportsThresholds">
            <summary> If true, this Nova Glove supports sending special firmware commands to lock brakes at specific sensor values. </summary>
            <remarks> Defined here because 1) we only need to know this once, and 2) support is not only dependent on hardware, but also on the channels detected in the software's IPC </remarks>
        </member>
        <member name="P:SGCore.Nova.NovaGlove.SupportsCustomWaveforms">
            <summary> If true, this Nova Glove supports sending custom 'fire-and-forget' waveforms, </summary>
            <remarks> Defined here because 1) we only need to know this once, and 2) support is not only dependent on hardware, but also on the channels detected in the software's IPC </remarks>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.#ctor(SGCore.Nova.Nova_GloveInfo)">
            <summary> Create a new instance of a Nova Glove that is not yet linked  viaIPC. </summary>
            <param name="deviceInfo"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SetHapticChannels(SGCore.HapticChannelInfo)">
            <summary> Re-evaluate the support for additional functions after this is assigned. </summary>
            <param name="channels"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToString">
            <summary> Returns this Nova's DeviceID. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetDeviceID">
            <summary> Returns this Nova Glove's DeviceID, a.k.a. it's unique serial number. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetFirmwareVersion">
            <summary> Returns the main firmware version of this Nova. (ex: v4.2 -> 4) </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetSubFirmwareVersion">
            <summary> Returns the sub-firmware version of this Nova. (ex: v4.2 -> 2) </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetHardwareVersion">
            <summary> Returns the hardware (sub) identifier of this Nova Glove; "1.0, 1.1, 1.X". Used to filter for glove functions. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetDeviceType">
            <summary> Return the SGCore deviceType wihtout having to cast. Used to deterime which icons to show, etc. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.HasBattery">
            <summary> Returns true if this device operates on a battery </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.IsCharging">
            <summary> Returns true if this device is currently charging </summary>
            <returns> </returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetBatteryLevel(System.Single@)">
            <summary> Returns the device's battery level, as a value between 0 (empty) and 1 (full). </summary>
            <param name="battLvl"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.IsRight">
            <summary> Returns true if this Nova Glove is made for the right hand. If false, it's a left hand. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetGloveModel">
            <summary> Access DeviceInfo of this Nova </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetSensorData(SGCore.Nova.Nova_SensorData@)">
            <summary> Get the latest Sensor Data from this Sense Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetIMURotation(SGCore.Kinematics.Quat@)">
            <summary> Retrieve Nova rotation </summary>
            <param name="IMU"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.Nova.Nova_Profile,SGCore.HandPose@)">
            <summary> Retrieve a new hand pose using this glove, based on (calibrated) user data. </summary>
            <param name="handModel"></param>
            <param name="profile"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandProfile,SGCore.HandPose@)">
            <summary> Retrieve a new hand pose using this glove, based on (calibrated) user data. </summary>
            <param name="handGeometry"></param>
            <param name="handProfile"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalculateHandPose_Nova_1_X(SGCore.Kinematics.BasicHandModel,SGCore.Nova.Nova_SensorData,SGCore.Nova.Nova_Profile)">
            <summary> Calculate a HandPose based on a glovePose and a solver. Nova 1.X series </summary>
            <remarks> Use this when you already have a GlovePose </remarks>
            <param name="handModel"></param>
            <param name="novaData"></param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.StopHaptics">
            <summary> End all haptic effects on the SenseGlove, at the end of your simulation. </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.StopVibrations">
            <summary> Stops all vibrotactile actuators on the Nova Glove, but does not affect the force-feedback. </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToNovaCommand(System.Single[],System.Single[],System.Single)">
            <summary> Converts a set of commands into a series of bytes (string) this glove can understand. </summary>
            <param name="ffbLevels">Force-Feedback levels for each finger</param>
            <param name="buzzLevels">Vibration levels for each finger</param>
            <param name="wristLevel">Value between 0 and 1 for the wirst amplitude to set</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ToNovaCommand(SGCore.Haptics.ThresholdCmd)">
            <summary> Converts a Threshold command into a Nova Glove command. </summary>
            <param name="thresholds"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucessfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Nova.NovaGlove.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.Nova.NovaGlove.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0 means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Nova.NovaGlove.QueueVibroLevels(System.Single[])" -->
        <member name="M:SGCore.Nova.NovaGlove.QueueVibroLevel(SGCore.Finger,System.Single)">
            <summary> Queue a command to set the vibration amplitude of a particular finger to a specific level </summary>
            <param name="amplitude"> Value will be clamped between [0...1], where 0.0 means no vibration, and 1.0 means full vibration. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <remarks> Devices that 'only' have on/off vibration control will treat any value > 0.0 as 1.0. </remarks>
            <returns>Returns true if the command was sucessfully added to the queue. If false, the device might not support the chosen finger(s) or have the appropriate firmware.</returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueWristLevel(System.Single)">
            <summary> Queue a command to the vibration amplitude of a general wrist actuator to a set level.  </summary>
            <param name="amplitude"> The amplitude of the wrist vibration, where 0.0 means no vibration, and 1.0 means full vibration. </param>
            <returns> Returns true if the wrist command has been sucesfully queued. If false, the device might not support direct wrist control or have the appropriate firmware.  </returns>
            <remarks> This one isn't contained in an interface as it's not used outside of the NovaGlove class. </remarks>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueThresholdCmd(SGCore.Finger,System.Single)">
            <summary> Queue a command to autmatically engage a finger's Force-Feedback when the sensor value exceeds a set threshold. </summary>
            <param name="sensorValueThreshold"></param>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueClearThreshold(SGCore.Finger)">
            <summary> Queue a command to clear the threshold for a specific finger. </summary>
            <param name="finger"></param>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueClearThresholds">
            <summary> Queue a command to clear the thresholds for each finger. </summary>
            <returns> Returns true if the command was queued. If false, the device does not have the required firmware for these commands. </returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueThresholdCmd_Flexion(SGCore.Finger,System.Single)">
            <summary> Stops the glove when flexing pas this point. </summary>
            <param name="finger"></param>
            <param name="flexionThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.QueueThresholdCmd_Flexions(System.Boolean[],System.Single[])">
            <summary> Queue a command for all of the fingers. When thresholdsActive is false, we turn off the thresholds for that finger </summary>
            <param name="thresholdsActive"></param>
            <param name="flexionThresholds"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.FlexionToThreshold(System.Single,SGCore.Finger)">
            <summary> Nova-Specific. Take a Flexion value and convert it into raw ADC values. </summary>
            <param name="flexion"></param>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.FlexionToThreshold(System.Single,SGCore.Finger,SGCore.Kinematics.HandInterpolator)">
            <summary> Converts a flexion value [0..1] to a raw adv value, based on a HandInterpolator + movement. </summary>
            <param name="flexion"></param>
            <param name="finger"></param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SupportsMotor(SGCore.Nova.Nova_VibroMotor)">
            <summary> Returns true if this Nova Glove has access to this specific motor installed. </summary>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ChannelIndex(SGCore.Nova.Nova_VibroMotor)">
            <summary> Returns the channel index for a particular motor. Can make this a s complex as I want for the Nova GLove(s). </summary>
            <param name="motor"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ValidateWaveform(SGCore.Nova.Nova_Waveform@,SGCore.Nova.Nova_VibroMotor@)">
            <summary> Ensures the waveform that is to be sent to this Nova Glove has the appropriate parameters. </summary>
            <param name="waveform"></param>
            <param name="motor"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendCustomWaveform(SGCore.Nova.Nova_Waveform,SGCore.Nova.Nova_VibroMotor)">
            <summary> Directly sends a custom waveform to the Nova Glove. </summary>
            <param name="waveform"></param>
            <param name="motor"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_BuzzCmd,SGCore.Haptics.ThumperCmd)">
            <summary> Send Haptic Commands to this Glove. Updates Last Commands. Backwards-Compatibility. </summary>
            <param name="ffb"></param>
            <param name="buzz"></param>
            <param name="thumper"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="ffb"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendHaptics(SGCore.Haptics.SG_BuzzCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="buzz"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendHaptics(SGCore.Haptics.ThumperCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="thumper"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_BuzzCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="buzz"></param>
            <param name="ffb"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.Parse(System.String)">
            <summary> Deserializes a Sense Glove from its CString. Returns a nullptr if unsuccesful. </summary>
             <param name="cString"></param>
             <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetCalibrationValues(SGCore.Kinematics.Vect3D[]@)">
            <summary>  Retrieve calibration values of this glove, as an array of size 5, containing x (roll), y (flexion), z (abduction) values. </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetCalibrationValues(SGCore.Nova.Nova_SensorData,SGCore.Nova.Nova_GloveInfo@)">
            <summary> Convert a SenseGlove GlovePose into calibrationValues. </summary>
            <param name="sData"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ApplyCalibration(SGCore.HandProfile@)">
            <summary> Applies the calibration range of this Nova a HandProfile </summary>
            <param name="profile"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.ApplyCalibration(SGCore.Nova.Nova_Profile@)">
            <summary> Applies the calibration range of this SenseGlove to a Nova_Profile </summary>
            <param name="profile"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalibrateInterpolation(SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Vect3D[],SGCore.Nova.Nova_Profile@)">
            <summary> Generate a profile based on min </summary>
            <param name="minValues"></param>
            <param name="maxValues"></param>]
            <param name="profile"></param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the Nova.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalculateGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location without requiring an object reference.. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="rightHand">Whether or not this is a left or right handed glove.</param>
            <param name="hardwareVersion">Can be left blank for DK 1 offsets</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalculateGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Nova.Nova_GloveInfo,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location without requiring an object reference.. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="gloveInfo">Glove information.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets. </summary>
            <remarks> The simplest interface, using default offsets </remarks>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.CalculateWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Nova.Nova_GloveInfo,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets, without needing an object reference. </summary>
            <remarks> The simplest interface, using default offsets </remarks>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="gloveInfo">Whether this is right or left hand</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetNovaGlove(System.Boolean,SGCore.Nova.NovaGlove@)">
            <summary> Retrieve the first connected Nova Glove, for a specific hand. </summary>
            <param name="rightHand"></param>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetNovaGlove(SGCore.Nova.NovaGlove@)">
            <summary> Retrieve the first connected Nova Glove</summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.NovaGlove.GetNovaGloves">
            <summary> Returns a list of all connected Nova Gloves. </summary>
            <returns></returns>
        </member>
        <member name="P:SGCore.Nova.Nova_GloveInfo.IsRight">
            <summary> Determines if this is a right-handed Nova. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_GloveInfo.ImuCorrection">
            <summary> The IMU correction of this Nova. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_GloveInfo.Equals(SGCore.Nova.Nova_GloveInfo)">
            <summary> Returns true if one Nova has the same properties as another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="F:SGCore.Nova.Parsing.Nova_CVar.AllC">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_Profile.Reset">
            <summary> Resets this profile to default values. </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_SensorLocation">
            <summary> Used to access a sensor Movement of the Nova_SensorData class. </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_SensorData">
            <summary> Sensor Data coming from a Nova Glove, converted into useful values. </summary>
        </member>
        <member name="T:SGCore.Nova.Nova_SensorData.NovaData">
            <summary> Enumerators for Nova Data position in the parseable string. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.SensorValues">
            <summary> Pronation/Supination, Flexion/Extension and Abduction/Adduction values for each finger. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.IMURotation">
            <summary> Quaternion rotation relative to magnetic north. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.ParsedValues">
            <summary> The number of values that were parsed from the sensor string. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.IMUParsed">
            <summary> Whether or not the IMU values were all succesfully parsed. </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.IsCharging">
            <summary> Returns true if this NovaGlove is connected to a power source </summary>
        </member>
        <member name="P:SGCore.Nova.Nova_SensorData.BatteryLevel">
            <summary> A value between 0..1 that represents the battery level of this Nova Glove (0 .. 100%). Returns -1 if the value wasn't received. </summary>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.#ctor(SGCore.Kinematics.Vect3D[][],System.Int32,SGCore.Kinematics.Quat,System.Boolean,System.Single,System.Boolean)">
            <summary>  </summary>
            <param name="values"></param>
            <param name="numberOfVals"></param>
            <param name="imuRot"></param>
            <param name="imuComplete"></param>
            <param name="battLvl"></param>
            <param name="charging"></param>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Empty">
            <summary> Generates empty data </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.ToString">
            <summary> Create a readable string representation of this Sensor Data </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Equals(SGCore.Nova.Nova_SensorData)">
            <summary> Returns true if this sensor data contains the same values as another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.GetSensorValue(SGCore.Finger,SGCore.Nova.Nova_SensorLocation)">
            <summary> Returns the sensor movement of a specific finger. </summary>
            <param name="finger"></param>
            <param name="location"> If a Nova glove has only one flexion sensor, it will return the same value for Flexion_Proximal and Flexion_Distal.</param>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Parse(System.String,SGCore.Nova.Nova_GloveInfo@)">
            <summary> Parse the bytes as they come in from the device into useable values. </summary>
            <param name="rawData"></param>
            <param name="gloveInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Serialize">
            <summary> Convert this sensor data into a string so it can be stored on disk. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Nova.Nova_SensorData.Deserialize(System.String)">
            <summary> Convert this sensor data into ta string representation.  </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SG.SG_HapticStream">
            <summary> A buffer to queue and flush SenseGlove DK1 commands specifically. Not guarateed to work with other devices. </summary>
        </member>
        <member name="P:SGCore.SG.SG_HapticStream.FingerForceLevels">
            <summary> The force-feedback levels of each finger that is desired for this frame (0 .. 1). </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticStream.fingerFFBUpdate">
            <summary> Whether or not the finger FFB data has been updated this frame, or if we need to fall back to the 'last command' </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticStream.lastFFBLevels">
            <summary> The last FFB levels that were sent to the glove. Used as a fallback in case there are no updates needed. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.AddForceLevel(System.Int32,System.Single)">
            <summary> Sets the force level for a specific finger in the buffer. </summary>
            <param name="level01"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.StoreLastFFB(System.Single[])">
            <summary> Copy a set of FFB levels into the 'previous command', which will be used as a fallback value in case no change is made to a specific finger. </summary>
            <param name="levels"></param>
        </member>
        <member name="P:SGCore.SG.SG_HapticStream.FingerVibroLevels">
            <summary> The finger vibration levels that are desired for this frame. </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticStream.fingerVibroUpdate">
            <summary> whether or not there have been updates to the finger vibration this frame </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticStream.lastVibroLevels">
            <summary> The last vibro that were sent to the glove. Used as a fallback when no update is made. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.AddVibrationLevel(System.Int32,System.Single)">
            <summary> Sets the amplitude for a specific finger in the buffer. </summary>
            <param name="amplitude"></param>
            <param name="finger"></param>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.StoreLastVibro(System.Single[])">
            <summary> Copy a set of amplitiudes into the 'previous command', which will be used as a fallback value in case no change is made to a specific finger. </summary>
            <param name="levels"></param>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.#ctor">
            <summary> Create a new Nova HapticStream </summary>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.CompileTraditionalCommands(System.Single[]@,System.Single[]@,SGCore.Haptics.SG_ThumperCmd@)">
            <summary> Compile the commands into a set of traditional Nova Commands. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.ClearAllCommands">
            <summary> Clears any active command(s) on the Nova Glove, completely resetting the stream. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HapticStream.ResetBuffer">
            <summary> Removes all non-active or elapsed Nova effects from the stream, ready for the next frame. </summary>
        </member>
        <member name="T:SGCore.SG.SenseGlove">
            <summary> Interface for the Sense Glove; and exoskeleton Force-Feedback glove. </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.gloveModel">
            <summary> Contains all data regarding this Sense Glove </summary>
            <remarks> 
            We're not using a generic DeviceModel as that would require casting
            its DeviceModel to an SGModel each frame. Adding this interface here is faster
            </remarks>
        </member>
        <member name="F:SGCore.SG.SenseGlove.hapticsByte">
            <summary> Byte indicating a new Sense Glove haptic command. </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.thumperByte">
            <summary> Byte indicating a new Thumper command. </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.hapticStream">
            <summary> Buffer to keep track of all incoming commands </summary>
        </member>
        <member name="F:SGCore.SG.SenseGlove.lastHapticCmd">
            <summary> Used to check for a difference. </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.#ctor(SGCore.SG.SG_GloveInfo)">
            <summary> Create a new instance of a Sense Glove. </summary>
            <param name="myModel"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetDeviceType">
            <summary> Get the DeviceType enumerator of this SenseGlove, used in DeviceList enumeration. </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetDeviceID">
            <summary> Retrieve this Sense Glove's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetHardwareVersion">
            <summary> Retrieve thisglove's hardware (sub) version.  </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetFirmwareVersion">
            <summary> Retrieve this device's firmware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSubFirmwareVersion">
            <summary> Retrieve this device's sub-firmware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.IsRight">
            <summary> Check if this Sense Glove is right handed. </summary>
            <remarks> While the variable is stored in SG_GloveModel, added direct access here since its frequently used. </remarks>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGloveModel">
            <summary> Retrieve this glove's hardware model, which contains its hardware data. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.ToString">
            <summary> Create a string representation of this device for reporting purposes. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSensorData(SGCore.SG.SG_SensorData@)">
            <summary> Get the latest Sensor Data from this Sense Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetIMURotation(SGCore.Kinematics.Quat@)">
            <summary> SenseGlove's IMU Rotation </summary>
            <param name="IMU"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGlovePose(SGCore.SG.SG_GlovePose@)">
            <summary> Get the pose of this Sense Glove's hardware, based on its latest Sensor Data. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGlovePose(SGCore.SG.SG_SensorData,SGCore.SG.SG_GlovePose@)">
            <summary> Get the pose of this Sense Glove's hardware based on a set of Sensor Data. </summary>
            <param name="sData"></param>
            <param name="pose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.SG.SG_HandProfile,SGCore.HandPose@)">
            <summary> Retrieve a new hand pose using this glove, based on (calibrated) user data. </summary>
            <param name="profile"></param>
            <param name="solver"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.ToSenseGloveCmd(System.Single[],System.Single[],SGCore.Haptics.SG_ThumperCmd)">
            <summary> Convert amplitudes into a SenseGlove command </summary>
            <param name="ffbLevels"></param>
            <param name="buzzLevels"></param>
            <param name="thumperCmd"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucessfully sent to SenseCom. Returns false if no changes to commands were detected. </returns>
            <remarks> Generic function across any Haptic Interface in SGCore </remarks>
        </member>
        <member name="M:SGCore.SG.SenseGlove.StopHaptics">
            <summary> End all haptic effects on the SenseGlove, at the end of your simulation. </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.StopVibrations">
            <summary> Stop all vibrations on the SenseGlove </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.SG.SenseGlove.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.SG.SenseGlove.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0 means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.SG.SenseGlove.QueueVibroLevels(System.Single[])" -->
        <member name="M:SGCore.SG.SenseGlove.QueueVibroLevel(SGCore.Finger,System.Single)">
            <summary> Queue a command to set the vibration amplitude of a particular finger to a specific level </summary>
            <param name="amplitude"> Value will be clamped between [0...1], where 0.0 means no vibration, and 1.0 means full vibration. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <remarks> Devices that 'only' have on/off vibration control will treat any value > 0.0 as 1.0. </remarks>
            <returns>Returns true if the command was sucessfully added to the queue. If false, the device might not support the chosen finger(s) or have the appropriate firmware.</returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SupportsWristActuator">
            <summary> Returns tru if this device support wrist actuation </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.QueueWristCommand(SGCore.Haptics.SG_ThumperCmd)">
            <summary> Queue a command to the wrist actuator, a.k.a. the Thumper. These effects are hard-coded on the driver. </summary>
            <param name="effectToPlay"> The Thumper effect to play. </param>
            <returns> Returns true if the wrist command has been sucesfully queued. If false, the device might not support direct wrist control or have the appropriate firmware.  </returns>
            <remarks> This one isn't contained in an interface as it's not used outside of the SenseGlove class. </remarks>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_BuzzCmd,SGCore.Haptics.ThumperCmd)">
            <summary> Send Haptic Commands to this Glove. Updates Last Commands. Backwards-Compatibility. </summary>
            <param name="ffb"></param>
            <param name="buzz"></param>
            <param name="thumper"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="ffb"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SendHaptics(SGCore.Haptics.SG_BuzzCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="buzz"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_BuzzCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="buzz"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateGlovePose(SGCore.SG.SG_SensorData,SGCore.SG.SG_GloveInfo)">
            <summary> Calculates a GlovePose based on gloveAngles and a glove model. </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateGlovePose(SGCore.Kinematics.Vect3D[][],SGCore.SG.SG_GloveInfo)">
            <summary> Calculates a GlovePose based on gloveAngles and a glove model. </summary>
            <remarks> Use this when you already have gloveAngles collected </remarks>
            <param name="gloveAngles"></param>
            <param name="gloveModel"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateHandPose(SGCore.SG.SG_GlovePose,SGCore.Kinematics.BasicHandModel,SGCore.SG.SG_HandProfile)">
            <summary> Calculate a HandPose based on a glovePose and a solver. </summary>
            <remarks> Use this when you already have a GlovePose </remarks>
            <param name="glovePose"></param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.Parse(System.String)">
            <summary> Deserializes a Sense Glove from its CString. Returns a nullptr if unsuccesful. </summary>
             <param name="cString"></param>
             <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSenseGloves(System.Boolean)">
            <summary> Retrieve all connected Sense Gloves. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSenseGlove(SGCore.SG.SenseGlove@)">
            <summary> Retrieve the first connected Sense Glove connected to this System </summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSenseGlove(System.Boolean,SGCore.SGDevice@)">
            <summary> Retrieve the first (connected) right- or left handed sense glove as an abstract SGDevice. </summary>
            <param name="rightHanded"></param>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetSenseGlove(System.Boolean,SGCore.SG.SenseGlove@)">
            <summary> Retrieve the first (connected) right- or left handed sense glove. </summary>
            <param name="rightHanded"></param>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetCalibrationValues(SGCore.Kinematics.Vect3D[]@)">
            <summary>  Retrieve calibration values of this glove, as an array of size 5, containing x (roll), y (flexion), z (abduction) values. </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetCalibrationValues(SGCore.SG.SG_GlovePose)">
            <summary> Convert a SenseGlove GlovePose into calibrationValues. </summary>
            <param name="glovePose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGlove.ResetCalibrationRange">
            <summary> Resets this glove's calibration range to a base level </summary>
        </member>
        <member name="M:SGCore.SG.SenseGlove.ApplyCalibration(SGCore.HandProfile@)">
            <summary> Applies the calibration range of this SenseGlove to a HandProfile </summary>
            <param name="profile"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.ApplyCalibration(SGCore.SG.SG_HandProfile@)">
            <summary> Applies the calibration range of this SenseGlove to a SG_HandProfile </summary>
            <param name="profile"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,System.Boolean,SGCore.Finger,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location without requiring an object reference.. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="rightHand">Whether or not this is a left or right handed glove.</param>
            <param name="mountedOn">Which finger module the hardware is mounted on. Default is Middle finger.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.CalculateWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,System.Boolean,SGCore.Finger,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location without requiring an object reference.. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="rightHand">Whether or not this is a left or right handed glove.</param>
            <param name="mountedOn">Which finger module the hardware is mounted on. Default is Middle finger.</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
            <param name="gloveWristOffPos"></param>
            <param name="gloveWristOffRot"></param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Finger,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="mountedOn">Which finger module the hardware is mounted on.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets. </summary>
            <remarks> The simplest interface, using default offsets </remarks>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="M:SGCore.SG.SenseGlove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets. </summary>
            <param name="refPosition"></param>
            <param name="refRotation"></param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="gloveWristOffPos">Position offset, in mm, from the glove origin to wrist (default = 0,0,-30 mm)</param>
            <param name="gloveWristOffRot">Rotation offset from the glove origin to wrist (default = 0,-5,0 degrees)</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="T:SGCore.SG.SenseGloveVars">
            <summary> "Database" class containing Sense Glove internal variables </summary>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GetStdCString(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary> Retrieve a basic Cstring for a Sense Glove of a specific Hardware Version. Used for debugging / unit tests. </summary>
             <param name="hwVersion"></param>
             <param name="fwVersionMain"></param>
             <param name="fwVersionSub"></param>
             <param name="rightHand"></param>
             <returns> Returns an empty string when an invalid glove version is requested. </returns>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GetSensorString(System.String,System.Single)">
            <summary> Retrieve an example sensor string of a Sense Glove with a particular hardware- and firmware version. </summary>
            <param name="hwVersion"></param>
            <param name="fwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GetStartPositions(System.String,System.Boolean)">
            <summary> Retrieve the starting positions of a particular Sense Glove. </summary>
            <param name="hwVersion"></param>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GetStartRotations(System.String,System.Boolean)">
            <summary> Retrieve the starting rotations of a particular Sense Glove. </summary>
            <param name="hwVersion"></param>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GetGloveLengths(System.String)">
            <summary> Retrieve the glove finger lengths of a particular Sense Glove. </summary>
            <param name="hwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GetSensors(System.String)">
            <summary> Get the number of sensors of a SenseGlove </summary>
            <param name="hwVersion"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GetIMUCorrection(System.String,System.Int32,System.Int32)">
            <summary> Get the default IMUCorrection for the SenseGlove </summary>
            <param name="hwVersion"></param>
            <param name="fwVersionMain"></param>
            <param name="fwVersionSub"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GetFunctions(System.String,System.Int32,System.Int32)">
            <summary> Check all functionality of a SenseGlove </summary>
            <param name="hwVersion"></param>
            <param name="fwVersionMain"></param>
            <param name="fwVersionSub"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SenseGloveVars.GenerateGloveModel(System.String,System.Int32,System.Int32,System.Boolean,System.String)">
            <summary> Generate a custom glove info. </summary>
            <param name="hwVersion"></param>
            <param name="fwVersionMain"></param>
            <param name="fwVersionSub"></param>
            <param name="rightHand"></param>
            <param name="customID"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SG.SG_GlovePose">
            <summary> Represents a pose of a Sense Glove exoskeleton. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.JointPositions">
            <summary> Positions of each glove joint, relative to the Glove's Origin. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.JointRotations">
            <summary> Quaternion rotation of each glove joint, relative to the Glove Origin. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.GloveAngles">
            <summary> Glove joint angles in euler notation, relative to the last segment. </summary>
            <remarks> Essentially sensor angles, though placed in their proper xyz notation </remarks>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.IsRight">
            <summary> Determines if this GlovePose was created for a left- or right hand. </summary>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.#ctor(System.Boolean,SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Quat[][],SGCore.Kinematics.Vect3D[][])">
            <summary> Creates a new instance of a SG_GlovePose </summary>
            <param name="right"></param>
            <param name="positions"></param>
            <param name="rotations"></param>
            <param name="jointAngles"></param>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.IdlePose(SGCore.SG.SG_GloveInfo)">
            <summary> Returns an idle pose for the Sense Glove if no data can be found. </summary>
            <param name="glove"> The glove model to use for the idle position. </param>
            <returns></returns>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.ThimblePositions">
            <summary> The position of the tip of the 'thimbles', the furthest link on each glove link. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.ThimbleRotations">
            <summary> The (quaternion) rotation of the 'thimbles', the furthest link on each link.  </summary>
        </member>
        <member name="P:SGCore.SG.SG_GlovePose.TotalGloveAngles">
            <summary> Sum of the Sensor angles in each (xyz) direction. "Total Pronation / Flexion / Abduction" </summary>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.CalculateFingerTips(SGCore.SG.SG_HandProfile)">
            <summary> Calculate fingertip positions based on a user profile. </summary>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.CalculateFingerTips(SGCore.Kinematics.Vect3D[])">
            <summary> Calculate fingertip positions, knowing the offset between thimble and fingertips. </summary>
            <param name="fingerOffsets"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.Equals(SGCore.SG.SG_GlovePose)">
            <summary> Returns true if this GlovePOse equals another. </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.Serialize">
            <summary> Convert a GlovePose into a string that can be unpacked later </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GlovePose.Deserialize(System.String)">
            <summary> Convert a serialized SG_GlovePose back into a useable class. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SG.SG_FingerSolver">
            <summary> How this Sense Glove converts sensor data into a HandPose. </summary>
        </member>
        <member name="F:SGCore.SG.SG_FingerSolver.Interpolation">
            <summary> Hand angles are interpolated based on the total flexion / abduction of the exoskeleton </summary>
        </member>
        <member name="T:SGCore.SG.SG_ThumbSolver">
            <summary> How this Sense Glove converts sensor data into a HandPose. </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumbSolver.Interpolation">
            <summary> Hand angles are interpolated based on the total flexion / abduction of the exoskeleton </summary>
        </member>
        <member name="F:SGCore.SG.SG_ThumbSolver.DistanceBased">
            <summary> Hand angles are interpolated based on the total flexion / abduction of the exoskeleton </summary>
        </member>
        <member name="T:SGCore.SG.SG_HandProfile">
            <summary> Contains everything a Sense Glove needs to calculate a HandPose. </summary>
        </member>
        <member name="P:SGCore.SG.SG_HandProfile.IsRight">
            <summary> Whether this profile has been created for a left or right hand. </summary>
        </member>
        <member name="P:SGCore.SG.SG_HandProfile.ThumbSolver">
            <summary> Solver property that determines _how_ HandPoses are calcaulted. </summary>
        </member>
        <member name="P:SGCore.SG.SG_HandProfile.FingerSolver">
            <summary> Solver property that determines _how_ finger poses are calcaulted. </summary>
        </member>
        <member name="P:SGCore.SG.SG_HandProfile.InterpolationSet">
            <summary> Interpolation set to estimate joint angles. </summary>
        </member>
        <member name="P:SGCore.SG.SG_HandProfile.FingerThimbleOffset">
            <summary> Offset from thimble to fingertip, used for Inverse Kinematics. </summary>
        </member>
        <member name="F:SGCore.SG.SG_HandProfile.dThimbleOffset">
            <summary> Default offset from thimble to fingertip. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HandProfile.#ctor(System.Boolean,SGCore.Kinematics.HandInterpolator,SGCore.SG.SG_ThumbSolver,SGCore.SG.SG_FingerSolver,SGCore.Kinematics.Vect3D[])">
            <summary>  Create a new Hand Profile for the Sense Glove. </summary>
            <param name="right"></param>
            <param name="interpolator"></param>
            <param name="thumbSolvr"></param>
            <param name="fingerSolvr"></param>
            <param name="fingerThimbleOffset"></param>
        </member>
        <member name="M:SGCore.SG.SG_HandProfile.Default(System.Boolean)">
            <summary> Retrieve a 'new' profile, for either a left or right hand. </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_HandProfile.Reset">
            <summary> Resets this profile to default values. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HandProfile.Serialize">
            <summary> Convert this profile and its calibration data into a portable string representation.. </summary>
        </member>
        <member name="M:SGCore.SG.SG_HandProfile.Deserialize(System.String)">
            <summary> Convert a string representation of an SG_HandProfile into useable data. </summary>
        </member>
        <member name="T:SGCore.SG.SG_Functions">
            <summary> Functions that a Sense Glove cound have. </summary>
        </member>
        <member name="F:SGCore.SG.SG_Functions.SG_BuzzMotors">
            <summary> Vibration Motors to send haptic pulses to individual fingers  </summary>
        </member>
        <member name="F:SGCore.SG.SG_Functions.SG_ForceFeedback">
            <summary> Brakes which can inhibit grasping motions to create force feedback. </summary>
        </member>
        <member name="F:SGCore.SG.SG_Functions.SG_Thumper">
            <summary> A Thumper Module for global feedback. </summary>
        </member>
        <member name="F:SGCore.SG.SG_Functions.SG_AllFunctions">
            <summary> Utility value used for enumeration. It can also be used to check if a Sense Glove has all possible functionalities. </summary>
        </member>
        <member name="T:SGCore.SG.SG_GloveInfo">
            <summary> Contains device information about a Sense Glove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.IsRight">
            <summary> Check if this Sense Glove belongs to a left or right hand. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.NumberOfSensors">
            <summary> The number of Sensors in this SenseGlove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.ImuCorrection">
            <summary> The IMU correction of this Sense Glove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.StartPositions">
            <summary> The starting positions of each Sense Glove finger, relative to the glove origin </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.StartRotations">
            <summary> The starting rotations of each Sense Glove finger, relative to the glove origin </summary>
        </member>
        <member name="P:SGCore.SG.SG_GloveInfo.GloveLengths">
            <summary> The lengths of each Sense Glove finger section, in mm. </summary>
        </member>
        <member name="F:SGCore.SG.SG_GloveInfo.functions">
            <summary> Whether this device has a specific function (T/F). </summary>
            <remarks> Functions are dependent on Device Type. </remarks>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.#ctor(System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D[],SGCore.Kinematics.Quat[],SGCore.Kinematics.Vect3D[][],System.Boolean[])">
            <summary> Create a new Sense Glove device model </summary>
            <param name="ID"></param>
            <param name="hwVer"></param>
            <param name="fwVerMain"></param>
            <param name="fwVerSub"></param>
            <param name="rightHand"></param>
            <param name="noSensors"></param>
            <param name="imuCorr"></param>
            <param name="startPos"></param>
            <param name="startRot"></param>
            <param name="lengths"></param>
            <param name="functionality"></param>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.GetStartPosition(SGCore.Finger)">
            <summary> Retrieve the starting position of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.GetStartRotation(SGCore.Finger)">
            <summary> Retrieve the starting rotation of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.GetGloveLengths(SGCore.Finger)">
            <summary> Retrieve the finger section lengths of a specific finger. </summary>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.HasFunction(SGCore.SG.SG_Functions)">
            <summary> Check if this Sense Glove has a particular function. </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ToGloveAngles(System.Single[][])">
            <summary> Place incoming sensor data into the right xyz format, according to this glove's model. </summary>
            <param name="sensorAngles"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ToString">
            <summary> Create a string representation for fast logging. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ToString(System.Boolean)">
            <summary> Create a string representation for logging. </summary>
            <param name="shortNotation">If set to false, an more extensive log is created.</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.Serialize">
            <summary> Convert this SG_GloveInfo into a serialized string to use later. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.Deserialize(System.String)">
            <summary> Convert a serialized GloveInfo string back into a SG_GloveInfo class. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.Parse(System.String,SGCore.SG.SG_GloveInfo@,System.Boolean)">
            <summary> Create an instance of the SGModel from its string representation. </summary>
            <param name="cString"></param>
            <param name="model"></param>
            <param name="updateOldModels">if set to true, it will automatically update older glove models to ones measured in CAD.</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ParseLengthString(System.String)">
            <summary> Parse a section of constants into a set of glove lengths. </summary>
            <param name="rawLengths"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.ParseStartValues(System.String,SGCore.Kinematics.Vect3D[]@,SGCore.Kinematics.Quat[]@)">
            <summary> Parse a section of constants into a set starting positions and -rotations. </summary>
            <param name="rawValues"></param>
            <param name="startPos"></param>
            <param name="startRot"></param>
        </member>
        <member name="M:SGCore.SG.SG_GloveInfo.Equals(SGCore.SG.SG_GloveInfo,System.Boolean)">
            <summary> Check if this GloveInfo contains the same data as another. </summary>
            <param name="other"></param>
            <param name="geometryOnly">If set to true, we're only checking if the geometry is the same.</param>
            <returns></returns>
        </member>
        <member name="T:SGCore.SG.SG_HapticEncoder">
            <summary> Converts SenseGlove Haptics into commands </summary>
        </member>
        <member name="F:SGCore.SG.SG_HapticEncoder.maxForce">
            <summary> The maximum force, in Newton, that a Nova's Force-Feedback motors can apply. </summary>
        </member>
        <member name="T:SGCore.SG.SG_SensorData">
            <summary> Processed Sensor Data coming from a Sense Glove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_SensorData.ParsedValues">
            <summary> The total amount of sensor values that were parsed in the string (used to check for validity / sensor placement). </summary>
        </member>
        <member name="P:SGCore.SG.SG_SensorData.SensorAngles">
            <summary> Glove angles in radians, sorted by finger, from proximal to distal </summary>
        </member>
        <member name="P:SGCore.SG.SG_SensorData.ImuValues">
            <summary> Quaternion rotation of the IMU within the Sense Glove. </summary>
        </member>
        <member name="P:SGCore.SG.SG_SensorData.ImuParsed">
            <summary> Whether or not the IMU was properly parsed. </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.#ctor(System.Single[][],SGCore.Kinematics.Quat,System.Int32,System.Boolean)">
            <summary> Create a new instance of a Sense Glove Sensor Data class. </summary>
            <param name="angles"></param>
            <param name="imu"></param>
            <param name="sNumber"></param>
            <param name="imuComplete"></param>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.GetAngles(SGCore.Finger)">
            <summary> Get the glove angles of a specific finger segment </summary>
             <param name="finger"></param>
             <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.GetAngleSequence">
            <summary> Returns all glove angles in a sequence, without splitting them per finger. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.ToString">
            <summary> Retrieve a simple representaton of this sensor data for debugging purposes. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.Parse(System.String,SGCore.SG.SG_GloveInfo)">
            <summary> Deserialize Sense Glove sensor data from a raw char[] recieved through IPC. </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.Empty">
            <summary> Returns sensor data with no values. </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.Serialize">
            <summary> Serialize this HandProfile into a string representation </summary>
        </member>
        <member name="M:SGCore.SG.SG_SensorData.Deserialize(System.String)">
            <summary> Deserialize a HandProfile back into useable values. </summary>
        </member>
        <member name="T:SGCore.Diagnostics.DebugLevel">
            <summary> Levels of debugging available from the Sense Glove API. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.Disabled">
            <summary> No debug messages will be sent. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.ErrorsOnly">
            <summary> Send only messages if errors are caught. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.CalibrationMessages">
            <summary> Send messages from calibration algorithms </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.DeviceParsing">
            <summary> Send messages from device Parsing. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.Backend_Communication">
            <summary> Send messages related to backed communications. Mostly relevant when using Ports / Android Strings. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.Haptics_Sent">
            <summary> Which haptics are eventually sent to the glove </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.Haptics_Queue">
            <summary> Which haptics are added into our queue. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugLevel.ALL">
            <summary> For those we have no place for yet. </summary>
        </member>
        <member name="T:SGCore.Diagnostics.DebugArgs">
            <summary> Debugging arguments containing the message sent and its level. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugArgs.message">
            <summary> The message sent by the Debugger. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.DebugArgs.debugLv">
            <summary> The Debug level of the accompanying message </summary>
        </member>
        <member name="M:SGCore.Diagnostics.DebugArgs.#ctor(System.String,SGCore.Diagnostics.DebugLevel)">
            <summary> Create a new Instance of DebugArgs. </summary>
            <param name="msg"></param>
            <param name="lv"></param>
        </member>
        <member name="T:SGCore.Diagnostics.Debugger">
            <summary> Singleton class that reports debug messages. Can be subscribed to by other programs. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.Debugger.debugLv">
            <summary> The current debug level of the Sense Glove Debugger. </summary>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.#ctor">
            <summary> Empty Constructor to create the instance. </summary>
        </member>
        <member name="F:SGCore.Diagnostics.Debugger.defaultDebugLvl">
            <summary> The Default debug level for any application </summary>
        </member>
        <member name="F:SGCore.Diagnostics.Debugger.instance">
            <summary> Instance of the Debugger to which events can be subscribed. </summary>
        </member>
        <member name="P:SGCore.Diagnostics.Debugger.Instance">
            <summary> Access the Debugger instance. </summary>
        </member>
        <member name="P:SGCore.Diagnostics.Debugger.DebugLevel">
            <summary> The debug level of the Debugger </summary>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.Log(System.String,SGCore.Diagnostics.DebugLevel)">
            <summary>
            Attempt to post output to the System.Console class. If that fails, try to write to the System.Diagnostics.Debug class.
            </summary>
            <param name="message">The message to write to the user.</param>
            <param name="level"></param>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.SetConnectionLibCollection(System.Boolean)">
            <summary> Enable / Disable debug queueing on the SGConnect library. </summary>
            <param name="active"></param>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.GetConnectionLibMessages(System.String@)">
            <summary> Gte queued messages from the Connection library, provided it is running from this same main thread. </summary>
            <param name="messages"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Diagnostics.Debugger.MessageRecievedEventHandler">
            <summary> Delegate for the DebugMessageRecieved event. </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="E:SGCore.Diagnostics.Debugger.DebugMessageRecieved">
            <summary> Fires when a new message is recieved by the Debugger. </summary>
        </member>
        <member name="M:SGCore.Diagnostics.Debugger.OnMessageRecieved(System.String,SGCore.Diagnostics.DebugLevel)">
            <summary> Constructs DebugArs and Fires the MessageRecieved event. </summary>
            <param name="msg"></param>
            <param name="lvl"></param>
        </member>
        <member name="T:SGCore.DeviceList">
            <summary> Interface for SenseCom, allows the retrieval of Devices and Data. </summary>
        </member>
        <member name="F:SGCore.DeviceList.devices">
            <summary> A list of all devices that have been detected via the SenseComm executable. </summary>
        </member>
        <member name="F:SGCore.DeviceList.connStateDelim">
            <summary> Delimiter for the connection state </summary>
        </member>
        <member name="M:SGCore.DeviceList.ActiveDevices">
            <summary> Retrieve the number of devices that have been detected by the SenseComm executable. </summary>
        </member>
        <member name="M:SGCore.DeviceList.GetDevices">
            <summary> Retrieve all Sense Glove Devices that were once connected to this system. </summary>
        </member>
        <member name="M:SGCore.DeviceList.GetDevices``1">
            <summary> Retrieve a list of SGDevices of a specific class. </summary>
            <typeparam name="T"> Subclass of SGDevice. </typeparam>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.SenseCommRunning">
            <summary> Returns true if the SenseComm program is running. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.CheckDevices">
            <summary> Check the IPC for new data, and add any new devices to our list. </summary>
            <remarks> Should be called whenver any GetDevices functions is called. </remarks>
        </member>
        <member name="M:SGCore.DeviceList.GetAddress(System.Int32,System.String)">
            <summary> Retrieve Device Address </summary>
            <param name="ipcAddress"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetConnectionType(System.Int32,System.String)">
            <summary> Retieve this device's connectionType. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.IsConnected(System.Int32,System.String)">
            <summary> Returns true if the device at  this connection side is properly connected. </summary>
            <param name="ipcAddress"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.PacketsPerSecondReceived(System.Int32,System.String)">
            <summary> Retrieve the device's Packets per Second Variable </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.PacketsPerSecondSent(System.Int32,System.String)">
            <summary> Retrieve the device's Packets per Second sent Variable </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetSensorDataString(System.Int32,System.String,System.String@)">
            <summary> Retrieve the latest sensor data string from the device at ipcAddress. </summary>
            <param name="ipcAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetConnectionStates">
            <summary> Retrieve the Connection States inside the SGConnect Library. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.SendHaptics(System.Int32,System.String,System.Int32,System.String)">
            <summary> Send command(s) in string format to the device at ipcAddress. </summary>
            <param name="deviceIndex"></param>
            <param name="ipcAddress"></param>
            <param name="commands"></param>
            <param name="channelIndex"> Sent for Android </param>
            <returns> Returns true if the command has been sent succesfully. </returns>
        </member>
        <member name="M:SGCore.DeviceList.Initialize">
            <summary> Initialize Communications - Required when compiled with Sockets Mode </summary>
        </member>
        <member name="M:SGCore.DeviceList.Dispose">
            <summary> Initialize Communications - Not required when compiled with Sockets Mode </summary>
        </member>
        <member name="M:SGCore.DeviceList.GetPingTime(System.Double@)">
            <summary> Server-side only. Returns the time between clientside responses. </summary>
            <param name="pingTime_ms"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.Deserialize(System.String,SGCore.SGDevice@)">
            <summary> Factory function to deserialize an SGDevice out of a DeviceList string. </summary>
            <remarks> Intended use: Returns true if serialization is succesfull, false if errors occured. In that case output = null. </remarks>
            <param name="serialized"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetDeviceStringAt(System.Int32,System.String,System.Int32)">
            <summary> Grab data from the Device string (connected/pps/type) at a specific index. </summary>
            <param name="ipcIndex"></param>
            <param name="ipcAddress"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.DeviceList.GetHapticString(System.Int32,System.String,System.String@)">
            <summary> Retrieve the string that SenseCom wants to send to the device. </summary>
            <param name="ipcIndex"></param>
            <param name="ipcAddress"></param>
            <param name="hapticStr"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.DeviceModel">
            <summary> Base class containing the minimum amount of data for device models. </summary>
        </member>
        <member name="P:SGCore.DeviceModel.DeviceID">
            <summary> Unique identifier of this device. </summary>
        </member>
        <member name="P:SGCore.DeviceModel.HardwareVer">
            <summary> Hardware (sub) version of this Sense Glove Device. </summary>
        </member>
        <member name="P:SGCore.DeviceModel.FirmwareVer">
            <summary> Firmware version running on the device's MicroController. (as v4.12, this is the 4) </summary>
        </member>
        <member name="P:SGCore.DeviceModel.SubFirmwareVer">
            <summary> Sub firmware version runnning on the device's microcontroller (as v4.12, this is the .12) </summary>
        </member>
        <member name="M:SGCore.DeviceModel.ParseFunctions(System.Int32,System.Int32)">
            <summary> Convert an integer into an array of functions. </summary>
            <param name="value"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.DeviceType">
            <summary> Specific Sense Glove Device Types. </summary>
        </member>
        <member name="F:SGCore.DeviceType.UNKNOWN">
            <summary> This device is not recognized by the Sense Glove API. </summary>
        </member>
        <member name="F:SGCore.DeviceType.BETADEVICE">
            <summary> A Device that is in development, with direct access to sensor data and commands. </summary>
        </member>
        <member name="F:SGCore.DeviceType.SENSEGLOVE">
            <summary> An exoskeleton glove that provides force- and haptic feedback. </summary>
        </member>
        <member name="F:SGCore.DeviceType.NOVA">
            <summary> A soft glove with force feedback and optional on-board sensors. </summary>
        </member>
        <member name="T:SGCore.Finger">
            <summary> One of the fingers on the hand </summary>
        </member>
        <member name="F:SGCore.Finger.Thumb">
            <summary> Responsible for our evolutionary success! </summary>
        </member>
        <member name="F:SGCore.Finger.Index">
            <summary> Used to point at what you want </summary>
        </member>
        <member name="F:SGCore.Finger.Middle">
            <summary> On its own, this one is used to indicate frustration. </summary>
        </member>
        <member name="F:SGCore.Finger.Ring">
            <summary> If you like it then you should have put a ___ on it </summary>
        </member>
        <member name="F:SGCore.Finger.Pinky">
            <summary> The little finger. </summary>
        </member>
        <member name="T:SGCore.HandPose">
            <summary> Contains all variables required to draw or analyze a virtual hand. </summary>
        </member>
        <member name="F:SGCore.HandPose.isRight">
            <summary> Whether or not this HandPose was created to be a right- or left hand. </summary>
        </member>
        <member name="F:SGCore.HandPose.jointPositions">
            <summary> Positions of all hand joints relative to the Sense Glove origin. From thumb to pinky, proximal to distal. </summary>
        </member>
        <member name="F:SGCore.HandPose.jointRotations">
            <summary> Quaternion rotations of all hand joints. From thumb to pinky, proximal to distal. </summary>
        </member>
        <member name="F:SGCore.HandPose.handAngles">
            <summary> Euler representations of all possible hand angles. From thumb to pinky, proximal to distal. </summary>
        </member>
        <member name="M:SGCore.HandPose.#ctor(System.Boolean,SGCore.Kinematics.Vect3D[][],SGCore.Kinematics.Quat[][],SGCore.Kinematics.Vect3D[][])">
            <summary> Create a new instance of HandPose. </summary>
            <param name="right"></param>
            <param name="jointPos"></param>
            <param name="jointRot"></param>
            <param name="hAngles"></param>
        </member>
        <member name="M:SGCore.HandPose.Equals(SGCore.HandPose,System.Boolean)">
            <summary> Returns true if this HandPose contains the same values as another. </summary>
            <param name="other"></param>
            <param name="anglesOnly">Optional parameters to compare hand angles only.</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.GetNormalizedFlexion(System.Int32,System.Boolean)">
            <summary> Returns the total flexion of a specific finger as a value between 0 (fully extended) and 1 (fully flexed). </summary>
            <remarks> Separate function because we use it multiple times, protected because we don't want indexOutOfRange exceptions. </remarks>
        </member>
        <member name="M:SGCore.HandPose.GetNormalizedFlexion(SGCore.Finger,System.Boolean)">
            <summary> Returns the total flexion of a specific finger as a value between 0 (fully extended) and 1 (fully flexed). </summary>
            <remarks> Useful for animation or for detecting gestures </remarks>
        </member>
        <member name="M:SGCore.HandPose.GetNormalizedFlexion(System.Boolean)">
            <summary> Returns the total flexion the fingers as a value between 0 (fully extended) and 1 (fully flexed). </summary>
            <remarks> Useful for animation or for detecting gestures </remarks>
        </member>
        <member name="M:SGCore.HandPose.ToJointIndex(SGCore.Kinematics.FingerMovement)">
            <summary> Check which joint index a particlar finger movement is linked to. </summary>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.ToJointIndex(SGCore.Kinematics.ThumbMovement)">
            <summary> Check which joint index a particlar thumb movement is linked to. </summary>
            <param name="movement"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.GetJointAngle(SGCore.Kinematics.FingerMovement,SGCore.Finger)">
            <summary> Returns a specific Joint Angle of a finger, in radians. </summary>
            <param name="movement"></param>
            <param name="finger"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.GetJointAngle(SGCore.Kinematics.FingerMovement,System.Int32)">
            <summary> Returns a specific Joint Angle of a finger, in radians. This version is useful for iteration. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.GetThumbAngle(SGCore.Kinematics.ThumbMovement)">
            <summary> Returns a specific Joint Angle of the thumb, in radians </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.Serialize">
            <summary> Create a string representation of this HandPose to store on disk. It can later be deserialized. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.Deserialize(System.String)">
            <summary> Unpack a HandPose back into its Class representation. </summary>
            <param name="serializedString"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.ToString">
            <summary> Returns a string representation of this HandPose. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.FromHandAngles(SGCore.Kinematics.Vect3D[][],System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Generate a HandPose based on articulation angles (handAngles). </summary>
            <param name="handAngles"></param>
            <param name="rightHanded"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.DefaultIdle(System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Create a new instance of a left or right handed Pose that is "idle"; in a neutral position. </summary>
            <param name="right"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.FlatHand(System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Generates a HandPose representing an 'open hand', used in calibration to determine finger extension. </summary>
            <param name="rightHand"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.ThumbsUp(System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Generates a HandPose representing a 'thumbs up', used in calibration to determine finger flexion, thumb extension and adduction. </summary>
            <param name="rightHand"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandPose.Fist(System.Boolean,SGCore.Kinematics.BasicHandModel)">
            <summary> Generates a HandPose representing a 'fist', used in calibration to determine, thumb flexion and abduction. </summary>
            <param name="rightHand"></param>
            <param name="handDimensions"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.HandProfile">
            <summary> Generic HandProfile that works for both ann HapticGloves. </summary>
        </member>
        <member name="F:SGCore.HandProfile.rhFileName">
            <summary> The name of the .txt file containing the right hand profile. </summary>
        </member>
        <member name="F:SGCore.HandProfile.lhFileName">
            <summary> The name of the .txt file containing the left hand profile. </summary>
        </member>
        <member name="M:SGCore.HandProfile.GetProfileDir">
            <summary> Retrieve the directory where HandProfiles are commonly stored. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandProfile.GetProfileFileName(System.Boolean)">
            <summary> Returns the filename for a profile for a particular hand. </summary>
            <param name="isRight"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandProfile.GetLatestProfile(System.Boolean,SGCore.HandProfile@)">
            <summary> Retrieve the latest profile from disk. If none exists or if the profile Directory does not exist, latestProfile will be the default. </summary>
            <param name="rightHand"></param>
            <param name="latestProfile"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandProfile.StoreProfile(SGCore.HandProfile)">
            <summary> Store a profile on disk for other programs to use. The profile's isRight parameter determines where it's saved.. </summary>
            <param name="profileToStore"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HandProfile.ResetCalibration(System.Boolean,System.Boolean)">
            <summary> Resets the profile for a particular hand, also on disk. </summary>
            <param name="rightHand"></param>
            <param name="onDisk"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.HapticGlove">
            <summary> A type of glove that includes finger tracking and/or force-feedback methods. </summary>
        </member>
        <member name="F:SGCore.HapticGlove.minValues">
            <summary> The minimum calibration values measured by this glove. </summary>
        </member>
        <member name="F:SGCore.HapticGlove.maxValues">
            <summary> The maximum calibration values measured by this glove. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.GetDeviceType">
            <summary> Retrieve this HapticGlove's DeviceType. Used to distinguish between SenseGove and Nova Gloves. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetDeviceID">
            <summary> Return this HapitcGlove's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHardwareVersion">
            <summary> Retrieve this glove's hardwareversion (DK1, etc). </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetFirmwareVersion">
            <summary> Retrieve this device's main firmware version. v4.12 returns 4. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetSubFirmwareVersion">
            <summary> Retrieve this device's sub firmware version. v4.12 returns 12. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.IsRight">
            <summary> Returns true if this glove is made for a right hand. If false, it's a left hand. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetIMURotation(SGCore.Kinematics.Quat@)">
            <summary> Retrieve this glove's IMU rotation, if if has any </summary>
            <param name="IMU"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandProfile,SGCore.HandPose@)">
            <summary> Calculate the Hand Pose of this device, provided it has Hand Tracking available  </summary>
            <param name="handGeometry"></param>
            <param name="handProfile"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHandPose(SGCore.Kinematics.BasicHandModel,SGCore.HandPose@)">
            <summary> Returns the latest hand pose for a specific hand ggeometry, using the latest profile on disk. </summary>
            <param name="handGeometry"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHandPose(SGCore.HandPose@)">
            <summary> Retruns the latest handPose using a default HandGeometry and the latest profile stored on disk. </summary>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetHandPose(SGCore.HandProfile,SGCore.HandPose@)">
            <summary> Calculate the Hand Pose of this device, provided it has Hand Tracking available, using a default hand geometry. </summary>
            <param name="handProfile"></param>
            <param name="handPose"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.StopHaptics">
            <summary> Stops all Haptic effects if any are currently playing. Useful at the end of simulations or when resetting. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.StopVibrations">
            <summary> Stops all vibrations, but does not affect the force-feedback </summary>
        </member>
        <member name="M:SGCore.HapticGlove.SendHaptics">
            <summary> Take all active commands in the device queue, compile them into one and send them to the device. </summary>
            <returns> Returns true if the message was sucesfully sent to SenseCom. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.HapticGlove.QueueFFBLevels(System.Single[])" -->
        <member name="M:SGCore.HapticGlove.QueueFFBLevel(SGCore.Finger,System.Single)">
            <summary> Set the Force-Feedback value of a particular finger to a specific level </summary>
            <param name="level01"> Value will be clamped between [0...1], where 0.0f means no Force-Feedback, and 1.0 means full force-feedback. </param>
            <param name="finger"> The finger to which to send the command. </param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.QueueVibroLevels(System.Single[])">
            <summary> Queue a vibrotactile level for each finger. </summary>
            <param name="amplitudes"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.QueueVibroLevel(SGCore.Finger,System.Single)">
            <summary> Queue a vibrotactle level for a specific finger </summary>
            <param name="finger"></param>
            <param name="amplitude"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="ffb"></param>
        </member>
        <member name="M:SGCore.HapticGlove.SendHaptics(SGCore.Haptics.SG_BuzzCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="buzz"></param>
        </member>
        <member name="M:SGCore.HapticGlove.SendHaptics(SGCore.Haptics.ThumperCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="thumper"></param>
        </member>
        <member name="M:SGCore.HapticGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_BuzzCmd)">
            <summary> Send Haptic Commands to this Glove. </summary>
            <param name="buzz"></param>
        </member>
        <member name="M:SGCore.HapticGlove.SendHaptics(SGCore.Haptics.SG_FFBCmd,SGCore.Haptics.SG_BuzzCmd,SGCore.Haptics.ThumperCmd)">
            <summary> Send Haptic Commands to this Glove. Updates Last Commands. Backwards-Compatibility. </summary>
            <param name="ffb"></param>
            <param name="buzz"></param>
            <param name="thumper"></param>
        </member>
        <member name="M:SGCore.HapticGlove.GetHapticGloves(System.Boolean)">
            <summary> Get all Haptic Gloves connected to this system. They may or may not be connected </summary>
            <param name="connectedOnly">If false, we'll return all haptic gloves ever detected during this session</param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetGlove(SGCore.HapticGlove@)">
            <summary> Get the first Haptic Glove connected to this System </summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetGlove(System.Boolean,SGCore.HapticGlove@)">
            <summary> Get the first left/right Haptic Glove connected to this System </summary>
            <param name="glove"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.GetCalibrationValues(SGCore.Kinematics.Vect3D[]@)">
            <summary> Retrieve calibration values of this glove, as an array of size 5, containing x (roll), y (flexion), z (abduction) values. </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.HapticGlove.ResetCalibrationRange">
            <summary> Reset Calbratrion range for this Device. </summary>
        </member>
        <member name="M:SGCore.HapticGlove.UpdateCalibrationRange">
            <summary> Updates calibration values only  </summary>
        </member>
        <member name="M:SGCore.HapticGlove.UpdateCalibrationRange(SGCore.Kinematics.Vect3D[])">
            <summary> Updates calibration values only </summary>
        </member>
        <member name="M:SGCore.HapticGlove.GetCalibrationRange(SGCore.Kinematics.Vect3D[]@,SGCore.Kinematics.Vect3D[]@)">
            <summary> Access the minumum- and maximum sensor values measured by this Haptic Glove, in this session. </summary>
            <param name="minimumVals"></param>
            <param name="maximumVals"></param>
        </member>
        <member name="M:SGCore.HapticGlove.UpdateCalibration(SGCore.HandProfile@)">
            <summary> Updates Calibration values and applies it to the Profile. </summary>
            <param name="profile"></param>
        </member>
        <member name="M:SGCore.HapticGlove.ApplyCalibration(SGCore.HandProfile@)">
            <summary> Apply this glove's calibration range to a handProfile </summary>
            <param name="profile"></param>
        </member>
        <member name="M:SGCore.HapticGlove.GetWristLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the wrist, based on a reference location and default glove-hand offsets. </summary>
            <remarks> The simplest interface, using default offsets </remarks>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="wristPos">The 3D Position of the wrist, in mm, relative to your origin</param>
            <param name="wristRot">The 3D Rotation of the wrist, relative to your origin</param>
        </member>
        <member name="M:SGCore.HapticGlove.GetGloveLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.PosTrackingHardware,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieve the location of the glove origin, based on a reference location. </summary>
            <param name="refPosition">Position of the tracked object, in mm, relative to your origin</param>
            <param name="refRotation">Rotation of the tracked object relative to your origin</param>
            <param name="trackingHardware">The hardware mounted on the SenseGlove.</param>
            <param name="glovePos">The 3D Position of the glove, in mm, relative to your origin</param>
            <param name="gloveRot">The 3D Rotation of the glove, relative to your origin</param>
        </member>
        <member name="T:SGCore.SenseCom">
            <summary> SenseCom application interface </summary>
        </member>
        <member name="M:SGCore.SenseCom.RegisterExe">
            <summary> Registers current process as the latest SenseCom build. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.RegisterExe(System.String)">
            <summary> Register a particular path as the SenseGlove executable location </summary>
            <param name="exePath"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.GetExePath(System.String@)">
            <summary> Retrieve the location of SenseGlove executable </summary>
            <param name="exePath"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.ScanningActive">
            <summary> Retruns true if SenseCom scanning is active. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.GetCurrentExeDir(System.String@)">
            <summary> Returns the directory of the current process </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SenseCom.StartupSenseCom">
            <summary> Force-starts the SenseCom application if it is active on the system </summary>
            <returns></returns>
        </member>
        <member name="T:SGCore.Parsing.SG_CVar">
            <summary> Sense Glove C string Variables, enumerated for our convinience. </summary>
        </member>
        <member name="F:SGCore.Parsing.SG_CVar.AllC">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="T:SGCore.Parsing.SG_SVar">
            <summary> Sense Glove sensor string Variables, enumerated for our convinience. </summary>
        </member>
        <member name="F:SGCore.Parsing.SG_SVar.AllS">
            <summary> Utility value used in iteration / checking lengths </summary>
        </member>
        <member name="T:SGCore.SGConnect">
            <summary> The only class within the DLL to allow access to the SGComm C++ library. </summary>
            <remarks> Should therefore only contain static methods. </remarks>
        </member>
        <member name="M:SGCore.SGConnect.I_GetSGConnectionInfo(System.Boolean,System.Text.StringBuilder)">
            <summary> Retrieve the devices detected by the SenseComm. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_ActiveDevices">
            <summary> Retrieve the devices detected by the SenseComm. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetDeviceString(System.String,System.Text.StringBuilder)">
            <summary> Gets the raw string from the DeviceList memory block. </summary>
            <param name="deviceAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetSensorString(System.String,System.Text.StringBuilder)">
            <summary>  Get the raw (unprocessed) sensor data of the SGDevice at index, as discovered by SenseCom  </summary>
            <param name="deviceAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_WriteHaptics(System.String,System.String)">
            <summary>  </summary>
            <param name="deviceAddress"></param>
            <param name="commands"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetHapticString(System.String,System.Text.StringBuilder)">
            <summary> Retrives a Haptic String </summary>
            <param name="deviceAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_ScanningActive">
            <summary> Scheck if the SenseCom scanning is running. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetLibraryVersion(System.Text.StringBuilder)">
            <summary> Check if the SenseCom scanning is running. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetConnectionStates(System.Text.StringBuilder)">
            <summary> Check if the SenseCom scanning is running. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_Init">
            <summary> Internal Init </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_Dispose">
            <summary> Internal Dispose </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_SetDebugLevel(System.Int32)">
            <summary> Internal SetDebugLvl </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_GetDebugLevel">
            <summary> Internal GetDebugLvl </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.I_ReleaseIdleConnections">
            <summary> Release Idle Connections </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.InitCommunications">
            <summary>  Returns 1 if the communications were initialized of, 0 if this wasn't possible, -1 if the dll is missing. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.DisposeCommunications">
            <summary> Returns 1 if the communications were disposed of, 0 if this wasn't possible, 2 if we are already disposing. -1 if the dll is missing. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.GetSGConnectVersion(System.String@)">
            <summary> Retrieve the library version of SGConnect that is paired with this DLL. </summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.SetDebugLevel(System.Int32)">
            <summary> Set the internal debug level of the SGConnect library. 0 .. 6.  </summary>
            <param name="newLevel"></param>
        </member>
        <member name="M:SGCore.SGConnect.GetDebugLevel">
            <summary> Get the debug level of the current Library </summary>
        </member>
        <member name="M:SGCore.SGConnect.GetConnectionStates(System.String@)">
            <summary> Retrieve the connection states in a list </summary>
            <param name="connectionsList"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.GetSGConnectionInfo(System.Boolean,System.String[]@)">
            <summary> Retrieve the connection states in a list </summary>
            <param name="withBT"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.ReleaseIdleConnections">
            <summary> Attempts to release the idle connections on your system... </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.Validate_DLLs">
            <summary> Returns true if SenseCom and it's relevant C++ Redistibutables have been succesfully connected. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGConnect.GetHapticString(System.String,System.String@)">
            <summary> Wrapper for the extenal method. </summary>
            <param name="deviceAddress"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="T:SGCore.Library">
            <summary> Contains info about this DLL </summary>
        </member>
        <member name="T:SGCore.Library.BackEndType">
            <summary> The type of back-end communcation </summary>
        </member>
        <member name="F:SGCore.Library.BackEndType.SharedMemory">
            <summary> Back-end info comes from shared memory on the device </summary>
        </member>
        <member name="F:SGCore.Library.BackEndType.AndroidStrings">
            <summary> Back-end Data comes from an Android Library </summary>
        </member>
        <member name="F:SGCore.Library.BackEndType.Sockets">
            <summary> Back-end Data comes from Sockets (QuarkVR Server Mode) </summary>
        </member>
        <member name="M:SGCore.Library.GetBackEndType">
            <summary> Check wwhat back-end connections are used for this version of SGConnect </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.Library.BackEndVersion">
            <summary> Back-End version in string notation </summary>
            <returns></returns>
        </member>
        <member name="P:SGCore.Library.Version">
            <summary> C# Core library version in a string notation </summary>
        </member>
        <member name="P:SGCore.Library.SGConnectVersion">
            <summary> Version of the SConnect Library, provided this project has a reference to one. </summary>
        </member>
        <member name="T:SGCore.SGDevice">
            <summary> A Sense Glove device that can send / recieve data via the SenseComm program. </summary>
        </member>
        <member name="T:SGCore.SGDevice.ConnectionType">
            <summary> The type of connection this device is using </summary>
        </member>
        <member name="F:SGCore.SGDevice.ConnectionType.Unknown">
            <summary> This device has been disconnected, or this version of SGCore does not recognize the type of connection. </summary>
        </member>
        <member name="F:SGCore.SGDevice.ConnectionType.Serial">
            <summary> USB Serial port connection. Used for DK1 SenseGloves </summary>
        </member>
        <member name="F:SGCore.SGDevice.ConnectionType.BluetoothSerial">
            <summary> Blueooth connection through Serial ports. Used for Wireless Kits and early Nova prototypes. </summary>
        </member>
        <member name="F:SGCore.SGDevice.ConnectionType.BluetoothAndroid">
            <summary> Bluetooth Connection Via Android/Java SDK </summary>
        </member>
        <member name="F:SGCore.SGDevice.deviceIndex">
            <summary> The index of this device inside the SenseComm program. Used to access shared memory. </summary>
        </member>
        <member name="F:SGCore.SGDevice.ipcAddress">
            <summary> Internal shared memory adress. </summary>
        </member>
        <member name="F:SGCore.SGDevice.lastCmdID">
            <summary> used to generate new cmd ids when sending special commands </summary>
        </member>
        <member name="F:SGCore.SGDevice.hapticChannels">
            <summary> Contains information regarding this device's Haptics. </summary>
        </member>
        <member name="M:SGCore.SGDevice.GetDeviceType">
            <summary> Retrieve the DeviceType of this SGDevice. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetDeviceID">
            <summary> Retrieve this device's unique identifier. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetHardwareVersion">
            <summary> Retrieve this device's hardware version. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetFirmwareVersion">
            <summary> Retrieve this device's main firmware version. v4.12 returns 4. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetSubFirmwareVersion">
            <summary> Retrieve this device's sub firmware version. v4.12 returns 12. </summary>
        </member>
        <member name="M:SGCore.SGDevice.FirmwareString">
            <summary> Retreive the Device's firmware as a string. Ex. "v4.7" </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.SetHapticChannels(SGCore.HapticChannelInfo)">
            <summary>  </summary>
            <param name="channels"></param>
        </member>
        <member name="M:SGCore.SGDevice.GetAddress">
            <summary> Retrieve this Device's Serial/Bluetooth address. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetConnectionType">
            <summary> Retrieve the connection type of this Sense Glove. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.IsConnected">
            <summary> Check if this device is currently connected to the system. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.PacketsPerSecondReceived">
            <summary> Retrieve the device's Packets per Second Variable </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.PacketsPerSecondSent">
            <summary> Retrieve the device's Packets per Second Variable </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetDeviceIndex">
            <summary> Retrieve the index of this device within SenseComm. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.IsWireless">
            <summary> Returns true if this device is connected over a connection other than usb cable. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.HasBattery">
            <summary> Returns true if this device operates on abattery </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.IsCharging">
            <summary> Returns true if this device is currently charging </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetBatteryLevel(System.Single@)">
            <summary> Returns the device's battery level, as a value between 0 (empty) and 1 (full). </summary>
            <param name="battLvl"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetHapticChannelCount">
            <summary> The number of haptic channels this device can support. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.GetHapticChannelCount(SGCore.HapticChannelType)">
            <summary> How many channels of a specific type this SGDevice posesses. </summary>
            <param name="channelType"></param>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.SetDeviceIndex(System.Int32)">
            <summary> Change this device's index within the SenseComm. Warning: Can cause errors. </summary>
            <remarks> Which is why its internal. </remarks>
            <param name="newIndex"></param>
        </member>
        <member name="M:SGCore.SGDevice.ToString">
            <summary> Retrieve a String representation of this object. </summary>
            <returns></returns>
        </member>
        <member name="M:SGCore.SGDevice.ParseFirmware(System.String,System.Int32@,System.Int32@)">
            <summary> Parse a main and sub firmware version from its raw (v4.12) notation </summary>
            <param name="rawFW"></param>
            <param name="mainVer"></param>
            <param name="subVer"></param>
        </member>
        <member name="T:SGCore.PosTrackingHardware">
            <summary> Tracking Hardware used for positional tracking. </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.Custom">
            <summary> Custom tracking hardware, we don't apply any offsets </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.ViveTracker">
            <summary> HTC Vive Tracker (v1.0 or v2.0). </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.OculusTouch">
            <summary> Oculus Touch controller (left or right) for Rift S and Quest 1 </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.Quest2Controller">
            <summary> Touch controller for Oculus Quest 2 </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.PicoNeo2">
            <summary> Pico Neo 2 Controller(s) </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.PicoNeo3">
            <summary> Pcio Neo 3 Controllers(s) </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.ViveFocus3WristTracker">
            <summary> Wrist tracker for the Vive Focus 3 </summary>
        </member>
        <member name="F:SGCore.PosTrackingHardware.QuestProController">
            <summary> Oculus Touch Controller that comes with the Meta Quest Pro. </summary>
        </member>
        <member name="T:SGCore.Tracking">
            <summary> Utility class containing tracking offset information </summary>
        </member>
        <member name="F:SGCore.Tracking.zeroOffset_trackerPos">
            <summary> If true, we set glove-tracker position offsets to zero - used for debugging </summary>
        </member>
        <member name="F:SGCore.Tracking.zeroOffset_trackerRot">
            <summary> If true, we set glove-tracker rotation offsets to zero - used for debugging </summary>
        </member>
        <member name="F:SGCore.Tracking.zeroOffset_handPos">
            <summary> If true, we set glove-hand position offsets to zero - used for debugging </summary>
        </member>
        <member name="F:SGCore.Tracking.zeroOffset_handRot">
            <summary> If true, we set glove-hand position offsets to zero - used for debugging </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SGCore.Tracking.CalculateLocation(SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D,SGCore.Kinematics.Quat,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)" -->
        <member name="F:SGCore.Tracking.sg_fingerToGloveOrigin_Pos">
            <summary> Positional offset from each finger to the glove origin </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_fingerToGloveOrigin_Rot">
            <summary>  </summary>
        </member>
        <member name="M:SGCore.Tracking.GetSenseGloveOffset_Glove_Mount(System.Boolean,SGCore.Finger,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Get the position and rotation offsets to go from the glove origin to the mounted position </summary>
            <remarks> Based on CAD. needs to be inverted when going from tracker to glove origin. </remarks>
            <param name="rightHand"></param>
            <param name="toFinger"></param>
            <param name="iPos"></param>
            <param name="iRot"></param>
        </member>
        <member name="M:SGCore.Tracking.GetSenseGloveOffset_Tracker_Mount(SGCore.PosTrackingHardware,System.Boolean,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Get the offset to get from the TrackedHardware to a SenseGlove mounting location. Combined with Glove-Mount offset to get the glove location. </summary>
            <param name="hardware"></param>
            <param name="rightHand"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="F:SGCore.Tracking.sg_gloveWristOffsetPos">
            <summary> Default position offset from glove origin to wrist location, in mm. </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_gloveWristOffsetRot">
            <summary> Default rotation offset from glove origin to wrist location. </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_viveToAttach_Pos">
            <summary> Vive Tracker origin to Finger rotational offset </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_viveToAttach_Rot">
            <summary> Vive Tracker origin to Finger rotational offset </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_ocTouchToAttach_Pos">
            <summary> Oculus Touch origin to Finger rotational offset </summary>
        </member>
        <member name="F:SGCore.Tracking.sg_ocTouchToAttach_Rot">
            <summary> Oculus Touch origin to Finger rotational offset </summary>
        </member>
        <member name="M:SGCore.Tracking.GetNovaOffset_Glove_Wrist(System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Returns the Offsets that will bring us from the Nova origin to the wrist position. </summary>
            <param name="rightHand"></param>
            <param name="hardwareVersion"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="M:SGCore.Tracking.GetNovaOffset_Glove_Wrist(SGCore.Nova.Nova_GloveInfo,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Returns the Offsets that will bring us from the Nova origin to the wrist position. </summary>
            <param name="gloveInfo"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="M:SGCore.Tracking.GetNovaOffset_Tracker_Glove(SGCore.PosTrackingHardware,System.Boolean,System.String,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary> Retrieves Offsets for a particular device. </summary>
            <param name="hardware"></param>
            <param name="rightHand"></param>
            <param name="hardwareVersion"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
        <member name="M:SGCore.Tracking.GetNovaOffset_Tracker_Glove(SGCore.PosTrackingHardware,SGCore.Nova.Nova_GloveInfo,SGCore.Kinematics.Vect3D@,SGCore.Kinematics.Quat@)">
            <summary>  Retrieves Offsets for a particular device. </summary>
            <param name="hardware"></param>
            <param name="gloveInfo"></param>
            <param name="posOffset"></param>
            <param name="rotOffset"></param>
        </member>
    </members>
</doc>
